var documenterSearchIndex = {"docs":
[{"location":"block_averages/#Block-averages","page":"Block averages","title":"Block averages","text":"","category":"section"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"Performs an analysis of the convergence of some property (usually the mean) in a time-series. ","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"Computes the block average of time-dependent data, to compute the standard error of the mean and, to detect sampling problems. A didactical explanation of block averaging is available here.  ","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"The package also outputs the autocorrelation function of the property, and the characteristic time of the correlation decay. ","category":"page"},{"location":"block_averages/#Data-that-is-not-time-correlated","page":"Block averages","title":"Data that is not time-correlated","text":"","category":"section"},{"location":"block_averages/#Compute-the-average-of-a-random-variable-x:","page":"Block averages","title":"Compute the average of a random variable x:","text":"","category":"section"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"julia> using MolSimToolkit \n\njulia> x = rand(10_000);\n\njulia> b = block_average(x)\n-------------------------------------------------------------------\nBlockAverageData{Float64}\n-------------------------------------------------------------------\nEstimated value (mean by default) = 0.4977014924716461\nLength of data series: 10000\n\nBlock size ranges: (1, 10000)\n\nMaximum standard error (error, block size): (0.005790454921861948, 5000)\n\nDeviations in last 3 blocks:\n         percentual: [2.8893559885598195, -1.1634393325014705, 0.0]  \n           absolute: [0.014380367877881106, -0.005790454921861976, 0.0]  \n\nAutocorrelation is first zero with lag: 2\nCharacteristic time of autocorrelation decay: \n        as fraction of series length: 2.0182708552030272e-5\n                            absolute: 0.2018270855203027\n-------------------------------------------------------------------\n\njulia> using Plots\n\njulia> plot(b, title=\"Uncorrelated data\")","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"Results in:","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"(Image: random.png)","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"Thus, the worst block estimate converges very rapidly to the true mean, the standard error of the mean is very small, and the autocorrelation decays very quickly. Since the data is not correlated along the series, the characteristic time may not be meaningful. ","category":"page"},{"location":"block_averages/#Data-that-is-time-correlated","page":"Block averages","title":"Data that is time-correlated","text":"","category":"section"},{"location":"block_averages/#Poorly-sampled-data","page":"Block averages","title":"Poorly-sampled data","text":"","category":"section"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"The data above is not correlated in the input x vector. If the data is correlated, one can observe that in the dependence of the estimates of the average and error from the data. One can generate a test data (sort of a monte-carlo simulation of a particle in an harmonic well) using:","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"julia> x = BlockAverages.test_data(1_000);","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"Which in this run produced:","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"julia> plot(x; xlabel=\"time\", ylabel=\"value\", label=nothing)","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"(Image: bad_sampling.png)","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"The error of the estimate of the mean is, now, dependent on the block size, and we cannot see any convergence of the error, indicating that the sampling is not enough to obtain a reliable estimate of the mean value of x:  ","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"julia> b = block_average(x, lags=1:500)\n-------------------------------------------------------------------\nBlockAverageData{Float64}\n-------------------------------------------------------------------\nEstimated value (mean by default) = -0.5616539552467762\nLength of data series: 1000\n\nBlock size ranges: (1, 1000)\n\nMaximum standard error (error, block size): (0.24081057091463817, 500)\n\nDeviations in last 3 blocks:\n         percentual: [80.94415878065803, 42.87525595877488, -0.0]  \n           absolute: [-0.4546260693327965, -0.2408105709146382, 0.0]  \n\nAutocorrelation is first zero with lag: 194\nCharacteristic time of autocorrelation decay: \n        as fraction of series length: 0.06981859583876429\n                            absolute: 69.8185958387643\n-------------------------------------------------------------------","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"Note that we have adjusted the range of lags of the autocorrelation function in this case.","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"Several characteristics of the output indicate the poor convergence of the series: 1) The mean should be 0. for this property; 2) the maximum standard error occurs with a block size which is half the length of the series (there is no plateau); 3) the standard error of the mean is of the order of the mean value; 4) The autocorrelation is first zero at ~20% of the length of the data set. ","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"The corresponding plot is obtained with:","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"julia> using Plots\n\njulia> plot(b, title=\"Bad sampling\")","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"(Image: bad_sampling_result.png)","category":"page"},{"location":"block_averages/#Properly-sampled-data","page":"Block averages","title":"Properly sampled data","text":"","category":"section"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"If we increase the sampling by generating longer simulation:","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"julia> x = BlockAverages.test_data(10^6);","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"The obtained set is now much better sampled,","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"(Image: good_sampling.png)","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"The convergence analysis of the series produces:","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"julia> b = block_average(x, lags=1:100:10^5, max_block_size=10^5)\n-------------------------------------------------------------------\nBlockAverageData{Float64}\n-------------------------------------------------------------------\nEstimated value (mean by default) = -0.05498853009368246\nLength of data series: 1000000\n\nBlock sizes: [1, 2, ..., 62500, 100000]\n\nMaximum standard error (error, block size): (0.18706372724807982, 31250)\n\nDeviations in last 3 blocks:\n         percentual: [-2805.4693758538297, -2600.14341058853, -1393.4253407524507]  \n           absolute: [1.5426863720104287, 1.4297806418103753, 0.7662241128326587]  \n\nAutocorrelation is first zero with lag: 14701\nCharacteristic time of autocorrelation decay: \n        as fraction of series length: 0.0036203287638847167\n                            absolute: 3620.328763884717\n-------------------------------------------------------------------","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"Note that the average value of x here is closer to zero, and that the maximum standard error of the mean is consistent the true value being around zero. The correlation decays fast relative to the length of the data series.","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"The corresponding plots are:","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"julia> using Plots\n\njulia> plot(b, title=\"Good sampling\")","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"(Image: good_sampling_result.png)","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"The plateau of standard errors (second plot) in intermediate values of block sizes is typical of a properly sampled data set, and can be used as an the uncertainty in the property estimate. ","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"For example, for an ever better sampled data, there is a very clear plateau of standard errors, which are smaller than those of the above example:","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"julia> x = BlockAverages.test_data(10^7)\n\njulia> b = block_average(x, max_block_size=10^5, lags=1:100:10^5);\n\njulia> plot(b)","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"(Image: best_sampling.png)","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"(here we have computed the statistics only up to blocks of size 10^5)","category":"page"},{"location":"block_averages/#Visualizing-the-distribution-of-the-mean","page":"Block averages","title":"Visualizing the distribution of the mean","text":"","category":"section"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"Once the overall correlation is understood from the time-series block analysis, one can  visualize the distribution of the computed value (the mean in general) for a given block size. A relatively good fit to a gaussian distribution is expected. For instance, let us choose a block size of 25_000, from a set similar to the one above:","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"julia> using MolSimToolkit, Plots\n\njulia> x = BlockAverages.test_data(10^7) \n\njulia> d = block_distribution(x; block_size = 25_000)\n-------------------------------------------------------------------\nMeanDistribution{400}\n-------------------------------------------------------------------\nNumber of blocks: 400\nEstimated value: = 0.06462623778329132\nStandard error of the mean: 0.05641314321229929\nStandard deviation of the mean: 1.1282628642459858\n> block_mean contains the mean computed for each block.\n-------------------------------------------------------------------\n\njulia> histogram(d)","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"The last command will produce a plot similar to the following, in which the histogram of values is shown side by side with the gaussian function that corresponds to the  observed standard deviation and mean.","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"(Image: best_sampling.png)","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"The optimal block size should be that for which the distribution is closer to a gaussian.","category":"page"},{"location":"block_averages/#Reference-functions","page":"Block averages","title":"Reference functions","text":"","category":"section"},{"location":"block_averages/#MolSimToolkit.BlockAverages.block_average-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Real","page":"Block averages","title":"MolSimToolkit.BlockAverages.block_average","text":"block_average(\n    x::AbstractVector{T};\n    by = mean,\n    min_block_size::Integer = 1,\n    max_block_size::Integer = length(x),\n    lags::Union{Nothing,AbstractVector{<:Integer}} = nothing,\n) where {T<:Real}\n\nThis function peforms some convergence analysis for a property computed from a series of data, typically a time-series.  The data is given in vector x, and by defines the property to be estimated, typically, and by default, the mean value.\n\nTwo analyses are performed: a block averaging, in which the data is split in to blocks, and the mean value (or by value) in each block is computed idependently. The output will contain the worst estimate obtained for all blocks, and the standard error of the estimates, as a function of the block size. \n\nFinally, the autocorrelation function of the data is computed, and a single exponential is fitted, to obtain the characteristic time of the decay of the correlation. \n\nThe output will be a structure of type BlockAverageData{T}. See the corresponding help entry for more information.\n\nAll results can be plot with a convenience function BlockAverage.plot\n\nThe lags keyword can be tuned to define the range of intervals and length of the autocorrelation calculation, with important implications to the exponential fit and correlation curve shape. See the StatsBase.autocor help for  further information.\n\nExample\n\njulia> using MolSimToolkit\n\njulia> x = BlockAverages.test_data(10^6); # example data generator\n\njulia> b = block_average(x, lags=0:100:10^5)\n-------------------------------------------------------------------\nBlockAverageData{Float64}\n-------------------------------------------------------------------\nEstimated value (mean by default) = -0.13673023261452855\nLength of data series: 1000000\n\nBlock sizes: [1, 2, ..., 500000, 1000000]\n\nMaximum standard error (error, block size): (0.23264202379194165, 500000)\n\nDeviations in last 3 blocks:\n         percentual: [-349.5348293165444, -170.1467329817311, -0.0]  \n           absolute: [0.47791978519330647, 0.23264202379194168, 0.0]  \n\nAutocorrelation is first zero with lag: 16400\nCharacteristic time of autocorrelation decay: \n        as fraction of series length: 0.0037856443348888848\n                            absolute: 3785.6443348888847\n-------------------------------------------------------------------\n\njulia> using Plots\n\njulia> plot(b) # creates a plot with the results\n\n\n\n\n\n\n","category":"method"},{"location":"block_averages/#MolSimToolkit.BlockAverages.block_distribution-Tuple{Function, AbstractVector, Integer}","page":"Block averages","title":"MolSimToolkit.BlockAverages.block_distribution","text":"block_distribution(x_input::AbstractVector; block_size::Integer) = \n    block_distribution(mean, x_input, block_size::Integer)\nblock_distribution(by::Function, x_input::AbstractVector, block_size::Integer)\n\nGiven the data and the block size, computes the distribution of estimates of the  properties for each block. Returns a BlockDistribution{NBLOCKS} object. The block size must be an integer.\n\nExample\n\njulia> using MolSimToolkit\n\njulia> x = BlockAverages.test_data(10^7);\n\njulia> d = block_distribution(x; block_size = 25*10^3)\n-------------------------------------------------------------------\nBlockDistribution{400}\n-------------------------------------------------------------------\nNumber of blocks: 400\nEstimated value: = 0.025151622077551537\nStandard error of the mean: 0.05596145099711976\nStandard deviation of the mean: 1.119229019942395\n> block_mean contains the mean computed for each block.\n-------------------------------------------------------------------\n\nThe distribution is stored in the d.block_mean vector, and can be plotted with:\n\njulia> using Plots\n\njulia> histogram(d)\n\n\n\n\n\n","category":"method"},{"location":"block_averages/#MolSimToolkit.BlockAverages.BlockAverageData","page":"Block averages","title":"MolSimToolkit.BlockAverages.BlockAverageData","text":"struct BlockAverageData{T}\n\nStructure that contains the result of the block-average analysis of the sequence. \n\nx is the original data set. \n\nxmean is the property value computed for all data (usually the mean, but not necessarily)\n\nblocksize is an array of block sizes, in which the data was split.  By default it goes from 1 to length(x), with a number of points corresponding to the number of integer divisions of length(x).\n\nxmean_maxerr: The property is computed for each block, and the maximum error (difference between the property in the block and the average property) is stored in this array, for each blocks size. \n\nxmean_stderr: The standard error of the estimates of the property, meaning the standar  deviation of the estimates divided by the square root of the number of blocks. \n\nautocor: Is the autocorrelation function of the data, as a function of the lag. \n\nlags: Is the set of \"time\" lags for which the autocorrelation will be computed. Defined by the lags parameter of the block_average function, as a range. \n\ntau: The characteristic decay time of the autocorrelation function, as obtained by fitting of a single exponential, of the form exp(-t/tau) to the data. \n\n\n\n\n\n","category":"type"},{"location":"block_averages/#MolSimToolkit.BlockAverages.BlockDistribution","page":"Block averages","title":"MolSimToolkit.BlockAverages.BlockDistribution","text":"struct BlockDistribution{N}\n\nmean::Float64\nstd_of_the_mean::Float64\nblock_mean::Vector{Float64}\nstd_err_of_the_mean::Float64\n\n\n\n\n\n","category":"type"},{"location":"block_averages/#RecipesBase.plot-Tuple{BlockAverageData}","page":"Block averages","title":"RecipesBase.plot","text":"plot(\n    data::BlockAverageData; \n    xlims=nothing, \n    ylims=nothing,\n    xscale=:identity,\n    title=\"\",\n)\n\nFunction that creates a plot of output data from block_average. The optional  xlims, ylims, xscale, title, can be set to adjust the apparency of the plot.    \n\nExample\n\njulia> using MolSimToolkit, Plots\n\njulia> x = BlockAverages.test_data(10^6);\n\njulia> b = block_average(x, lags=0:100:10^5);\n\njulia> plot(b)\n\n\n\n\n\n","category":"method"},{"location":"block_averages/#Plots.histogram-Tuple{BlockDistribution}","page":"Block averages","title":"Plots.histogram","text":"histogram(md::BlockDistribution; bins=:auto)\n\nFunction that creates a histogram of the value of a property in the blocks, computed with the block_distribution function.  \n\nExample\n\njulia> using MolSimToolkit, Plots\n\njulia> x = BlockAverages.test_data(10^6);\n\njulia> md = block_distribution(x; block_size=10^5);\n\njulia> histogram(md)\n\n\n\n\n\n","category":"method"},{"location":"plotting_style/#Plotting-style","page":"Plotting style","title":"Plotting style","text":"","category":"section"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"This package provides a simple type to overload the default plotting styles of Plots, such figures that are prettier (in our oppinion) are produced. To use the style, add MolSimStyle as the first argument of the plotting functions. ","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"In brief, use the Plots plotting functions with, for example:","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"plot(MolSimStyle, x, y, xlabel = \"my x\")\n\nhistogram(MolSimStyle, x)\n\ncontourf(MolSimStyle, M, xlabel = \"my x\", ylabel = \"my z\")","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"by adding the first argument to the available plotting functions. ","category":"page"},{"location":"plotting_style/#Without-the-style","page":"Plotting style","title":"Without the style","text":"","category":"section"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"For example, without the style:","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"julia> using MolSimToolkit, Plots\n\njulia> x = sort(rand(10)); y = sort(rand(10));\n\njulia> plot(x,y)","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"produces:","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"(Image: )","category":"page"},{"location":"plotting_style/#With-the-style","page":"Plotting style","title":"With the style","text":"","category":"section"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"Now, with the style, we get:","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"julia> plot(MolSimStyle, x, y)","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"(Image: )","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"All other normal parameters of Plots function can be used to change the plot labels, titles, legends, font sizes, etc.","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"tip: Tip\nIn v1.21.3, if if setting fontfamily=\"Serif\", LaTeXStrings will be converted to \\mathsf to match the overall plot fonts. This behavior can be disabled with adjust_latex_font=false. ","category":"page"},{"location":"plotting_style/#Available-plotting-functions","page":"Plotting style","title":"Available plotting functions","text":"","category":"section"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"The Plots functions that are overloaded are:","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"Plots.plot\nPlots.plot!\nPlots.scatter\nPlots.scatter!\nPlots.histogram\nPlots.histogram!\nPlots.contour\nPlots.contour!\nPlots.contourf\nPlots.contourf!\nPlots.annotate!","category":"page"},{"location":"plotting_style/#The-annotate!-function","page":"Plotting style","title":"The annotate! function","text":"","category":"section"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"The annotate! function is special, because the overload does not have the  same level of flexibilty of the standard Plots.annotate! function. Here, it is used with","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"julia> using MolSimToolkit, Plots\n\njulia> x = sort(rand(10)); y = sort(rand(10));\n\njulia> plot(MolSimStyle, x, y)\n\njulia> annotate!(MolSimStyle, 0.7, 0.3, \"My note!\"; fontsize = 12)","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"where 7.0 and 3.0 are the coordinates. This will produce:","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"(Image: )","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"warning: Warning\nThese styles and methods can be changed without introducing breaking changes in the package version. ","category":"page"},{"location":"Dihedrals/#dihedrals","page":"Dihedral angle analysis","title":"Dihedral angle analysis","text":"","category":"section"},{"location":"Dihedrals/#MolSimToolkit.average_dihedrals","page":"Dihedral angle analysis","title":"MolSimToolkit.average_dihedrals","text":"average_dihedrals(sim::Simulation, v::AbstractVector{<:AbstractVector{<:Integer}}; degrees=true)\naverage_dihedrals(sim::Simulation, v::AbstractVector{<:AbstractVector{<:PDBTools.Atom}}; degrees=true)\n\nComputes the average dihedral angles for many sets of 4 vectors from a trajectory. The input is a vector of vectors,  containing the indices of the atoms forming the dihedral angles, or the PDBTools.Atom objects. \n\nThe function returns a vector with the average dihedral angles in radians or degrees.\n\nExample\n\njulia> using MolSimToolkit, MolSimToolkit.Testing, PDBTools\n\njulia> atoms = read_pdb(Testing.namd2_pdb);\n\njulia> cAs = select(atoms, \"name CA and residue < 5\"); # 4 atoms\n\njulia> r1b = select(atoms, \"residue 1 and backbone\"); # 4 atoms\n\njulia> inds = [ index.(cAs), index.(r1b) ]; # List of vector of indices\n\njulia> sim = Simulation(Testing.namd2_pdb, Testing.namd2_traj);\n\njulia> ds = average_dihedrals(sim, inds)\n2-element Vector{Float64}:\n -60.12860673875001\n  -0.3398274578758668\n\njulia> ats = [ cAs, r1b ]; # List of vectors of PDBTools.Atom\n\njulia> ds = average_dihedrals(sim, ats)\n2-element Vector{Float64}:\n -60.12860673875001\n  -0.3398274578758668\n\n\n\n\n\n\n","category":"function"},{"location":"Dihedrals/#MolSimToolkitShared.dihedral","page":"Dihedral angle analysis","title":"MolSimToolkitShared.dihedral","text":"dihedral(v1, v2, v3, v4; degrees=true)\ndihedral(v::AbstractVector; degrees=true)\n\nComputes the dihedral angle between the planes formed by the vectors v1-v2 and v2-v3, and v2-v3 and v3-v4. The input vectors must have 3 elements. The function returns the dihedral angle in radians or degrees.\n\nIf the input is a vector with 4 vectors, the function computes the dihedral angle between the planes  formed by the vectors v[1]-v[2] and v[2]-v[3], and v[2]-v[3] and v[3]-v[4].\n\nThe optional argument degrees specifies whether the output is in degrees (default) or radians.\n\n\n\n\n\n","category":"function"},{"location":"Dihedrals/#MolSimToolkitShared.dihedrals","page":"Dihedral angle analysis","title":"MolSimToolkitShared.dihedrals","text":"dihedrals(v::AbstractVector{<:AbstractVector}; degrees=true)\n\nComputes the dihedral angles for many sets of 4 vectors. The input is a vector of vectors, where each element is a vector with 4 vectors. The function returns a vector with the dihedral angles in radians or degrees.\n\nExample\n\njulia> using MolSimToolkitShared: dihedrals\n\njulia> v1 = [[-8.483, -14.912, -6.726], [-5.113, -13.737, -5.466], [-3.903, -11.262, -8.062], [-1.162, -9.64, -6.015]];\n\njulia> v2 = [[-9.229, -14.861, -5.481], [-8.483, -14.912, -6.726], [-7.227, -14.047, -6.599], [-7.083, -13.048, -7.303]];\n\njulia> dihedrals([v1,v2])\n2-element Vector{Float64}:\n  164.43481280739516\n -115.82544005374316\n\n\n\n\n\n","category":"function"},{"location":"Experimental/#Experimental-features","page":"Experimental features","title":"Experimental features","text":"","category":"section"},{"location":"Experimental/","page":"Experimental features","title":"Experimental features","text":"The features in this section are experimental, meaning that they are under active development, with possible early bugs and unstable interfaces. The semantic version of the package is not compromised to the changes of these features. ","category":"page"},{"location":"Experimental/","page":"Experimental features","title":"Experimental features","text":"Dihedral angle analysis\nSimulation reweighting\nCluster submission management\nm-value (protein transfer free energy) calculator","category":"page"},{"location":"system_setup/#System-setup","page":"System setup","title":"System setup","text":"","category":"section"},{"location":"system_setup/#Packmol-Input-Creator","page":"System setup","title":"Packmol Input Creator","text":"","category":"section"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"This module helps the setup of a Packmol input file, by computing the number of molecules and sizes necessary to build different systems. Currently (as of version 1.27.0) the module supports the construction of systems of a solute (macromolecule for example) solvated by a  a single solvent or a mixture of two solvents. ","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"Solute-Solvent system\nSolute-Solvent-Cossolvent system","category":"page"},{"location":"system_setup/#How-to-use-it","page":"System setup","title":"How to use it","text":"","category":"section"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"julia> using MolSimToolkit.PackmolInputCreator","category":"page"},{"location":"system_setup/#Running-Packmol","page":"System setup","title":"Running Packmol","text":"","category":"section"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"Packmol can be run directly from within Julia using the Packmol Julia package:","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"using Packmol\nrun_packmol(\"./box.inp\")","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"If everything runs correctly, the output PDB file of the system will be created.","category":"page"},{"location":"system_setup/#Solute-Solvent-system","page":"System setup","title":"Solute-Solvent system","text":"","category":"section"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"Here, SolutionBoxUS stands for Solute (U) and Solvent (S). The density of the solvent can be one of \"g/mL\" or \"mol/L\" (molarity).","category":"page"},{"location":"system_setup/#MolSimToolkit.PackmolInputCreator.SolutionBoxUS","page":"System setup","title":"MolSimToolkit.PackmolInputCreator.SolutionBoxUS","text":"SolutionBoxUS(; \n    solute_pdbfile::String, \n    solvent_pdbfile::String,\n    density::Float64,\n    density_units = \"g/mL\",\n    solute_molar_mass = nothing, # optional\n    solvent_molar_mass = nothing, # optional\n)\n\nSetup a system composed of a solute (U) and a solvent (S). \n\nThe mass or molar density can be provided, and the units are either \"g/mL\" or \"mol/L\". The default is \"g/mL\". \n\nThe molar masses of the solute and solvent can be provided manually. If not, they will be computed from the atom types in the PDB file.\n\n\n\n\n\n","category":"type"},{"location":"system_setup/#MolSimToolkit.PackmolInputCreator.write_packmol_input-Tuple{SolutionBoxUS}","page":"System setup","title":"MolSimToolkit.PackmolInputCreator.write_packmol_input","text":"write_packmol_input(\n    system::SolutionBoxUS;\n    input=\"box.inp\",\n    output=\"system.pdb\",\n    # box size\n    box_sides::AbstractVector{<:Real}, # or\n    margin::Real,\n    cubic::Bool = false,\n)\n\nFunction that generates an input file for Packmol for a Solute + Solvent system.\n\nThe box sides are given in Ångströms, and can be provided as a vector of 3 elements. Alternativelly, the margin can be provided, and the box sides will be calculated as the maximum and minimum coordinates of the solute plus the margin in all 3 dimensions.\n\nIf cubic is set to true, the box will be cubic, and the box sides will be equal in all 3 dimensions, respecting the minimum margin provided.\n\n\n\n\n\n","category":"method"},{"location":"system_setup/#Setting-up-the-system-properties","page":"System setup","title":"Setting up the system properties","text":"","category":"section"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"We initialize the system data structure, given the PDB files of one molecule of the polymer (poly_h.pdb), and one molecule of water:","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"# Directory of test files\ntest_dir = MolSimToolkit.PackmolInputCreator.PackmolInputCreatorDirectory*\"/test\"\n# Construction of system data structure\nsystem = SolutionBoxUSC(\n    solute_pdbfile = \"$test_dir/data/poly_h.pdb\",\n    solvent_pdbfile = \"$test_dir/data/water.pdb\",\n    density = 1.0,\n    density_units = \"g/mL\",\n    solute_molar_mass = nothing, # optional\n    solvent_molar_mass = nothing, # optional\n)","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"The molar masses of the components can be provided explicitly by the user. If not, they will be computed from the atom types in the PDB files, but this may fail if the mass of some atom type is unknown.","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"Finally, we can generate an input file for Packmol with:","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"write_packmol_input(\n    system; \n    margin = 20.0, \n    cubic = true,\n    input = \"box.inp\",\n    output = \"system.pdb\"\n)","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"The input parameter provides the name of the input file for Packmol that will be generated. ","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"The margin parameter sets the size of the box, which will take into consideration the maximum and minimum dimensions of the solute.  If cubic is set to true the box will be cubic, otherwise it will be orthorhombic but with different length in each direction, respecting the margin provided.","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"Alternatively, the size of the box can be provided explicitly with the box_sides = [ a, b, c ] parameters, where a, b, and c are the lengths of the box in each dimension. ","category":"page"},{"location":"system_setup/#Solute-Solvent-Cossolvent-system","page":"System setup","title":"Solute-Solvent-Cossolvent system","text":"","category":"section"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"Here, SolutionBoxUSC stands for Solute (U), Solvent (S), and Cossolvent (C).   The concentration units can be one of \"mol/L\" (molarity), \"x\" (molar fraction), \"vv\" (volume fraction), and \"mm\" (mass fraction). The density is assumed to be in g/mL. ","category":"page"},{"location":"system_setup/#MolSimToolkit.PackmolInputCreator.SolutionBoxUSC","page":"System setup","title":"MolSimToolkit.PackmolInputCreator.SolutionBoxUSC","text":"SolutionBoxUSC(; \n    solute_pdbfile::String, \n    solvent_pdbfile::String,\n    cossolvent_pdbfile::String,\n    density_table::Matrix{Float64},\n    concentration_units = \"x\",\n    solute_molar_mass = nothing, # optional\n    solvent_molar_mass = nothing, # optional\n    cossolvent_molar_mass = nothing, # optional\n)\n\nSetup a system composed of a solute (U) a solvent (S) and a cossolvent (C). \n\nThe concentration units of the density table can be provided explicitly and are assumed by default to be the molar fraction, x, of the cossolvent.\n\nThe molar masses of the solute, solvent, and cossolvent can be provided manually. If not, they will be computed from the atom types in the PDB file.\n\n\n\n\n\n","category":"type"},{"location":"system_setup/#MolSimToolkit.PackmolInputCreator.write_packmol_input-Tuple{SolutionBoxUSC}","page":"System setup","title":"MolSimToolkit.PackmolInputCreator.write_packmol_input","text":"write_packmol_input(\n    system::SolutionBoxUSC;\n    concentration::Real, \n    input=\"box.inp\",\n    output=\"system.pdb\",\n    # box size\n    box_sides::AbstractVector{<:Real}, # or\n    margin::Real,\n    cubic::Bool = false,\n)\n\nFunction that generates an input file for Packmol. \n\nThe box sides are given in Ångströms, and can be provided as a vector of 3 elements. Alternativelly, the margin can be provided, and the box sides will be calculated as the maximum and minimum coordinates of the solute plus the margin in all 3 dimensions.\n\nIf cubic is set to true, the box will be cubic, and the box sides will be equal in all 3 dimensions, respecting the minimum margin provided.\n\n\n\n\n\n","category":"method"},{"location":"system_setup/#MolSimToolkit.PackmolInputCreator.convert_concentration","page":"System setup","title":"MolSimToolkit.PackmolInputCreator.convert_concentration","text":"convert_concentration(\n    system::SolutionBoxUSC,\n    input_concentration, \n    units\n)\n\nConvert concentration from one unit to another. The input concentration is given in input_concentration, and the unit conversion  is given by units keyword, that can be one of the following pairs:\n\nThe supported concentration units are:\n\n\"mol/L\": molarity\n\"x\": molar fraction\n\"vv\": volume fraction\n\"mm\": mass fraction\n\nConversion among types consists in passing the units keyword argument, which is a pair of the form \"from\" => \"to\", where \"from\" and \"to\" are one of the supported units.\n\nExample\n\nFor example, to convert from molarity to molar fraction, use:\n\nconvert_concentration(system, 55.5, \"mol/L\" => \"x\")\n\nwhere system is a SolutionBoxUSC object, and 55.5 is the molarity.\n\n\n\n\n\n","category":"function"},{"location":"system_setup/#MolSimToolkit.PackmolInputCreator.convert_density_table!","page":"System setup","title":"MolSimToolkit.PackmolInputCreator.convert_density_table!","text":"convert_density_table!(system::SolutionBoxUSC, target_units)\n\nConverts the density table of the system from one unit to another. Returns the  input system with the density table converted to the new units.\n\nThe target units may be one of: \"mol/L\", \"x\", \"vv\", \"mm\".\n\nExample\n\nconvert_density_table!(system, \"mol/L\")\n\n\n\n\n\n","category":"function"},{"location":"system_setup/#Setting-up-the-system-properties-2","page":"System setup","title":"Setting up the system properties","text":"","category":"section"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"Here, we setup a system of a polymer solvated by water and ethanol. The densities as  a function of the molar fraction of ethanol are available in a data table:","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"density_table = [\n# x cossolvent (ethanol)     density (g/mL)\n         0.0000                 0.9981\n         0.0416                 0.9820\n         0.0890                 0.9685\n         0.1434                 0.9537\n         0.2066                 0.9369\n         0.2809                 0.9151\n         0.3695                 0.8923\n         0.4769                 0.8685\n         0.6098                 0.8450\n         0.7786                 0.8195\n         1.0000                 0.7906\n]","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"Next, we initialize the system data structure, given the PDB files of one molecule of the polymer (poly_h.pdb), and one molecule of water and ethanol:","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"# Directory of test files\ntest_dir = MolSimToolkit.PackmolInputCreator.PackmolInputCreatorDirectory*\"/test\"\n# Construction of system data structure\nsystem = SolutionBoxUSC(\n    solute_pdbfile = \"$test_dir/data/poly_h.pdb\",\n    solvent_pdbfile = \"$test_dir/data/water.pdb\",\n    cossolvent_pdbfile = \"$test_dir/data/ethanol.pdb\",\n    density_table = density_table,\n    concentration_units = \"x\", # molar fraction\n    solute_molar_mass = nothing, # optional\n    solvent_molar_mass = nothing, # optional\n    cossolvent_molar_mass = nothing, # optional\n)","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"The molar masses of the components can be provided explicitly by the user. If not, they will be computed from the atom types in the PDB files, but this may fail if the mass of some atom type is unknown.","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"tip: Tip\nThe density table can be converted among different units with the function convert_density_table!, which acts on the SystemBox object. For example:julia> convert_density_table!(system, \"mol/L\")","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"Finally, we can generate an input file for Packmol with:","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"write_packmol_input(\n    system; \n    concentration = 0.5,\n    margin = 20.0, \n    cubic = true,\n    input = \"box.inp\",\n    output = \"system.pdb\"\n)","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"The concentration can be given in molar fraction (x), molarity (mol/L), or volume fraction (vv). ","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"The input parameter provides the name of the input file for Packmol that will be generated. ","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"The margin parameter sets the size of the box, which will take into consideration the maximum and minimum dimensions of the solute. If cubic is set to true the box will be cubic, otherwise it will be orthorhombic but with different length in each direction, respecting the margin provided.","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"Alternatively, the size of the box can be provided explicitly with the box_sides = [ a, b, c ] parameters, where a, b, and c are the lengths of the box in each dimension. ","category":"page"},{"location":"Developer/#Developer-zone","page":"Developer zone","title":"Developer zone","text":"","category":"section"},{"location":"Developer/#Simulation","page":"Developer zone","title":"Simulation","text":"","category":"section"},{"location":"Developer/#MolSimToolkit.Simulation","page":"Developer zone","title":"MolSimToolkit.Simulation","text":"Simulation(pdb_file::String, trajectory_file::String; frames=[1,2,3,5])\nSimulation(pdb_file::String, trajectory_file::String; frames=9:2:20)\nSimulation(pdb_file::String, trajectory_file::String; first=1, last=nothing, step=1)\nSimulation(atoms::AbstractVector{<:AtomType}, trajectory_file::String; first=1, last=nothing, step=1)\n\nCreates a new Simulation object. \n\nThe first constructor creates a Simulation object from a PDB or mmCIF file and a trajectory file. It will use the PDBTools.Atom for the atom type, which will populate the atoms vector of the Simulation object. Currently, other atom types are supported, if the MolSimToolkit.atomic_mass(::AtomType) function is defined for the atom type.\n\nWith the second constructor, the atoms vector is passed as an argument. This is useful when the atoms are provided by a different source than the PDB file. \n\nThe frames or first, last, and step arguments can be used to specify the frames to be iterated over:\n\n- `frames` can be a vector of frame indices, e. g., `frames=[1,2,3,5]` or `frames=9:2:20`.\n- `first`, `last`, and `step` are Integers that specify the frames to be iterated over. \n  If `last` is not specified, the last frame in the trajectory will be used.\n\nA Simulation object contains a trajectory file and a PDB data of the atoms. It can be iterated over to obtain the frames in the trajectory. The Simulation object is a mutable struct that contains the following data, that can be retrieved by the corresponding functions:\n\nframe_range(::Simulation): the list of frames to be iterated over\nframe_index(::Simulation): the index of the current frame in the trajectory\nlength(::Simulation): the number of frames to be iterated over in the trajectory file, considering the current range\nraw_length(::Simulation): the number of frames in the trajectory file\natoms(::Simulation): the atoms in the simulation\n\nThe Simulation object can also be manipulated by the following functions:\n\nclose(::Simulation): closes the trajectory file\nrestart!(::Simulation): restarts the iteration over the trajectory file\nfirst_frame!(::Simulation): restarts the iteration over the trajectory file and places the current frame at the first frame in the trajectory\ncurrent_frame(::Simulation): returns the current frame in the trajectory\nnext_frame!(::Simulation): reads the next frame in the trajectory file and returns it. Moves the current frame to the next one.\nset_frame_range!(::Simulation; first, last, step): resets the range of frames to be iterated over. \nget_frame(::Simulation, iframe): returns the frame at the given index in the trajectory.\n\nOne important feature of the Simulation object is that it can be iterated over, frame by frame. \n\nThe pairs iterator can also be used to iterate over the frames, returning a tuple with the frame index and the frame itself. \n\nThe enumerate iterator can also be used to iterate over the frames, returning a tuple with the frame counter and the frame itself.\n\nExamples\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> simulation = Simulation(\n           Testing.namd_pdb, Testing.namd_traj; \n           first = 2, step = 2, last = 4,\n           # or frames = [2,4]\n       );\n\njulia> for frame in simulation \n           @show frame_index(simulation)\n           # show x coordinate of first atom \n           @show positions(frame)[1].x\n       end\nframe_index(simulation) = 2\n((positions(frame))[1]).x = 5.912472724914551\nframe_index(simulation) = 4\n((positions(frame))[1]).x = 7.346549034118652\n\njulia> for (i, frame) in pairs(simulation)\n           @show i, frame_index(simulation)\n       end\n(i, frame_index(simulation)) = (2, 2)\n(i, frame_index(simulation)) = (4, 4)  \n\njulia> for (i, frame) in enumerate(simulation)\n           @show i, frame_index(simulation)\n       end\n(i, frame_index(simulation)) = (1, 2)\n(i, frame_index(simulation)) = (2, 4)\n\n\n\n\n\n\n","category":"type"},{"location":"Developer/#MolSimToolkit.UnitCell","page":"Developer zone","title":"MolSimToolkit.UnitCell","text":"UnitCell{T}\n\nA structure to store the unit cell of a frame in the trajectory.\n\nThe matrix field contains the unit cell vectors as a static matrix of type SMatrix{3,3,T,9}. The valid field indicates whether the unit cell is valid (i.e., not all vectors are zero). The orthorhombic field indicates whether the unit cell is orthorhombic, which means that all off-diagonal elements are close to zero.\n\n\n\n\n\n","category":"type"},{"location":"Developer/#Base.close-Tuple{Simulation}","page":"Developer zone","title":"Base.close","text":"close(simulation::Simulation)\n\nCloses the trajectory file.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#Base.length-Tuple{Simulation}","page":"Developer zone","title":"Base.length","text":"length(simulation::Simulation)\n\nReturns the number of frames to be iterated over in the trajectory file, considering the current frame range.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.atoms-Tuple{Simulation}","page":"Developer zone","title":"MolSimToolkit.atoms","text":"atoms(simulation::Simulation)\n\nReturns the atoms in the simulation.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.current_frame-Tuple{Simulation}","page":"Developer zone","title":"MolSimToolkit.current_frame","text":"current_frame(simulation::Simulation)\n\nReturns the current frame in the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.first_frame!-Tuple{Simulation}","page":"Developer zone","title":"MolSimToolkit.first_frame!","text":"first_frame!(simulation::Simulation)\n\nRestarts the trajectory buffer, and places the current frame at the first frame in the trajectory.\n\nExample\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj; first=3);\n\njulia> first_frame!(simulation) \nSimulation \n    Atom type: Atom{Nothing}\n    PDB file: /test/data/namd/protein_in_popc_membrane/structure.pdb\n    Trajectory file: /test/data/namd/protein_in_popc_membrane/trajectory.dcd\n    Total number of frames: 5\n    Frames to consider: 1, 2, 3, 4, 5\n    Number of frames to consider: 5\n    Current frame: 3\n\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.frame_index-Tuple{Simulation}","page":"Developer zone","title":"MolSimToolkit.frame_index","text":"frame_index(simulation::Simulation)\n\nReturns the index of the current frame in the trajectory. Returns nothing  if no frame frame from the trajectory range has been read yet.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.frame_range-Tuple{Simulation}","page":"Developer zone","title":"MolSimToolkit.frame_range","text":"frame_range(simulation::Simulation)\n\nReturns the list of frames to be iterated over.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.get_frame-Tuple{Simulation, Integer}","page":"Developer zone","title":"MolSimToolkit.get_frame","text":"get_frame(simulation::Simulation, iframe::Integer)\n\nReturns the frame at the given index in the trajectory. \n\nExample\n\njulia> using MolSimToolkit, MolSimToolkit.Testing, PDBTools\n\njulia> sim = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> frame4 = get_frame(sim, 4)\n   Array{Atoms,1} with 20465 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     ILE     P      211        1   -0.397   12.048   37.441  1.00  0.00     1    PROT         1\n       2  HT1     ILE     P      211        1   -0.779   11.123   37.726  1.00  0.00     1    PROT         2\n       3  HT2     ILE     P      211        1   -0.393   12.662   38.280  1.00  0.00     1    PROT         3\n                                                       ⋮ \n   20463  SOD     SOD     S       13     4374  -11.686   23.749   19.935  1.00  0.00     1     SOD     20463\n   20464  SOD     SOD     S       14     4375  -34.214   38.148   55.179  1.00  0.00     1     SOD     20464\n   20465  SOD     SOD     S       15     4376    7.220  -52.702   66.223  1.00  0.00     1     SOD     20465\n\njulia> writePDB(frame4, \"frame4.pdb\")\n\nnote: Note\nThe get_frame function will read the frames in the trajectory until the desired frame is reached.  This can be slow for large trajectories. If the required frame is before the current frame of the  simulation, the simulation will be restarted. The simulation object is returned positioned in the required frame. \n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.next_frame!-Tuple{Simulation}","page":"Developer zone","title":"MolSimToolkit.next_frame!","text":"next_frame!(simulation::Simulation)\n\nReads the next frame in the trajectory file and returns it. Moves the current frame to the next one in the range to be considered (given by frame_range(simulation)).\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.path_pdb-Tuple{Simulation}","page":"Developer zone","title":"MolSimToolkit.path_pdb","text":"path_pdb(simulation::Simulation)\n\nReturns the path to the pdb file of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.path_trajectory-Tuple{Simulation}","page":"Developer zone","title":"MolSimToolkit.path_trajectory","text":"path_trajectory(simulation::Simulation)\n\nReturns the path to the trajectory file of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.raw_length-Tuple{Simulation}","page":"Developer zone","title":"MolSimToolkit.raw_length","text":"raw_length(simulation::Simulation)\n\nReturns the number of frames in the trajectory file.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.restart!-Tuple{Simulation}","page":"Developer zone","title":"MolSimToolkit.restart!","text":"restart!(simulation::Simulation)\n\nRestarts the iteration over the trajectory file.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.set_frame_range!-Tuple{Simulation}","page":"Developer zone","title":"MolSimToolkit.set_frame_range!","text":"set_frame_range!(simulation::Simulation; first=1, last=nothing, step=1)\n\nResets the frame range to be iterated over. This function will restart the iteration of the simulation trajectory.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#Positions","page":"Developer zone","title":"Positions","text":"","category":"section"},{"location":"Developer/#MolSimToolkit.positions-Tuple{Chemfiles.Frame}","page":"Developer zone","title":"MolSimToolkit.positions","text":"positions(frame::Chemfiles.Frame)\n\nReturn the positions of the atoms in a Chemfiles.Frame as a FramePositions object.\n\nThis is the default way to access the positions of the atoms in a simulation.\n\nExample\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> frame = current_frame(simulation);\n\njulia> p = positions(frame);\n\njulia> p[1].x \n5.912472724914551\n\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.FramePositions","page":"Developer zone","title":"MolSimToolkit.FramePositions","text":"FramePositions{T,P<:Point3D{T},M<:AbstractArray{T}} <: AbstractVector{P}\n\nContainer for the positions of a set of atoms. The positions are stored in a matrix, where each column corresponds to the coordinates of an atom. The container is used such that using the coodinates from a Chemfiles.Frame is transparent to the user, and the coordinates can be accessed as p[i] where i is the index of the atom. \n\nThe coordinates of the atom can be accessed as p[i].x, p[i].y, and p[i].z.\n\nA FramePositions object can be created with the positions function. The construction with FramePositions is not considered part of the public API.\n\nExample\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> frame = current_frame(simulation);\n\njulia> p = positions(frame)\n20465-element FramePositions{Float64, Point3D{Float64}, Chemfiles.ChemfilesArray}:\n [5.912472724914551, 10.768872261047363, 28.277008056640625]\n [5.040304183959961, 10.810898780822754, 27.71207046508789]\n ⋮\n [11.16289234161377, -37.30374526977539, 22.80788230895996]\n\njulia> p[1]\n3-element Point3D{Float64} with indices SOneTo(3):\n  5.912472724914551\n 10.768872261047363\n 28.277008056640625\n\njulia> p[1].x\n5.912472724914551\n\njulia> p[1].y\n10.768872261047363\n\njulia> p[1].z\n28.277008056640625\n\nIt is also possible to take slices and views of the positions:\n\njulia> p[1:2]\n2-element FramePositions{Float64, Point3D{Float64}, Matrix{Float64}}:\n [5.912472724914551, 10.768872261047363, 28.277008056640625]\n [5.040304183959961, 10.810898780822754, 27.71207046508789]\n\njulia> @view(coor[1:2])\n 2-element FramePositions{Float64, Point3D{Float64}, SubArray{Float64, 2, Chemfiles.ChemfilesArray, Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}, false}}:\n  [5.912472724914551, 10.768872261047363, 28.277008056640625]\n  [5.040304183959961, 10.810898780822754, 27.71207046508789]\n \n\n\n\n\n\n","category":"type"},{"location":"Developer/#MolSimToolkit.Point3D","page":"Developer zone","title":"MolSimToolkit.Point3D","text":"Point3D{T}\n\nA point in 3D space with coordinates x, y, and z of type T.\n\n\n\n\n\n","category":"type"},{"location":"Developer/#Unit-cell","page":"Developer zone","title":"Unit cell","text":"","category":"section"},{"location":"Developer/#MolSimToolkit.unitcell-Tuple{Chemfiles.Frame}","page":"Developer zone","title":"MolSimToolkit.unitcell","text":"unitcell(frame::Chemfiles.Frame)\n\nReturns the unit cell of the current frame in the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#Wrap-coordinates","page":"Developer zone","title":"Wrap coordinates","text":"","category":"section"},{"location":"Developer/#MolSimToolkitShared.wrap","page":"Developer zone","title":"MolSimToolkitShared.wrap","text":"wrap(x, xref, unit_cell_matrix::SMatrix{N,N,T}) where {N,T}\nwrap(x, xref, sides::AbstractVector)\n\nWraps the coordinates of point x such that it is the minimum image relative to xref. The unit cell  may be given a a static matrix of size (N,N) or as a vector of length N.\n\n\n\n\n\n","category":"function"},{"location":"Developer/#MolSimToolkitShared.wrap_to_first","page":"Developer zone","title":"MolSimToolkitShared.wrap_to_first","text":"wrap_to_first(x, unit_cell_matrix)\n\nWraps the coordinates of point x such that the returning coordinates are in the first unit cell with all-positive coordinates. The unit cell  has to be a matrix of size (N,N).\n\nExample\n\njulia> using MolSimToolkitShared: wrap_to_first\n\njulia> uc = [10.0 0.0 0.0; 0.0 10.0 0.0; 0.0 0.0 10.0]\n3×3 Matrix{Float64}:\n 10.0   0.0   0.0\n  0.0  10.0   0.0\n  0.0   0.0  10.0\n\njulia> wrap_to_first([15.0, 13.0, 2.0], uc)\n3-element Vector{Float64}:\n 5.0\n 3.0000000000000004\n 2.0\n\n\n\n\n\n","category":"function"},{"location":"intermittent_correlation/#Correlation-functions","page":"Intermittent correlation","title":"Correlation functions","text":"","category":"section"},{"location":"intermittent_correlation/#MolSimToolkit.intermittent_correlation-Union{Tuple{AbstractVector}, Tuple{F}} where F<:Function","page":"Intermittent correlation","title":"MolSimToolkit.intermittent_correlation","text":"intermittent_correlation(\n    data::AbstractVector; \n    maxdelta = length(data) ÷ 10, \n    types::Function = x -> true,\n    show_progress::Bool = true,\n)\n\nCalculate the intermittent correlation function of a time series. That is, computes the probability of finding a value of the same type at a step i + delta in the time series, given that it was present in step i.\n\nReturns an OffsetArray with indices 0:maxdelta, where the value at position 0 is 1.0, corresponding to the normalized count of events. \n\nArguments\n\ndata::AbstractVector: The time series to be analyzed. \nmaxdelta::Integer: The maximum delta-step to be considered. Defaults to  length(data) ÷ 10.\ntypes (optional): A function that returns true for the types of data  that should be considered. Defaults to all data, i. e. x -> true. For   example, to ignore 0 values, use types = x -> x != 0.  \nshow_progress::Bool: Show progress bar. Defaults to true.\n\nExamples\n\nHere we produce a time-series of 10,000 elements, as a sequence of  1's and 0's ([1, 0, 1, 0, ...]), and calculate the intermittent correlation function. The probability of finding the same number (0 or 1) after odd steps is 0, and the probability of finding the same number after even steps is 1.\n\njulia> using MolSimToolkit\n\njulia> data = [ mod(i,2) for i in 1:10^4 ];\n\njulia> intermittent_correlation(data; maxdelta=4, show_progress=false)\n5-element OffsetArray(::Vector{Float64}, 0:4) with eltype Float64 with indices 0:4:\n 1.0\n 0.0\n 1.0\n 0.0\n 1.0\n\njulia> intermittent_correlation(data; maxdelta=4, types = x -> x != 0, show_progress=false)\n5-element OffsetArray(::Vector{Float64}, 0:4) with eltype Float64 with indices 0:4:\n 1.0\n 0.0\n 1.0\n 0.0\n 1.0\n\nIn the second run, we have ignored the 0 values, and the result is the same,  because here the correlations of the 1 values are the same as the correlations of the 0 values.\n\ncompat: Compat\nThis function was added in version 1.9.0 of MolSimToolkit. The types argument was added in version 1.10.0 and the show_progress argument in version 1.28.0.\n\n\n\n\n\n","category":"method"},{"location":"mvalues/#mvalues","page":"m-value calculator","title":"m-values (protein transfer free energy) calculator","text":"","category":"section"},{"location":"mvalues/","page":"m-value calculator","title":"m-value calculator","text":"warning: Warning\nThis is an experimental feature. Breaking changes may occur without  a breaking package release.","category":"page"},{"location":"mvalues/#MolSimToolkit.mvalue","page":"m-value calculator","title":"MolSimToolkit.mvalue","text":"mvalue(; model=MoeserHorinek, cosolvent=\"urea\", pdbname, sasas, type=1)\n\nCalculates the m-value (transfer free energy of a protein in 1M solution) using the Tanford transfer model, as implemented by Moeser and Horinek [1] or by Auton and Bolen [2,3].\n\nArguments\n\nmodel: The model to be used. Must be MoeserHorinek or AutonBolen. MoeserHorinek is only implemented for cosolvent=\"urea\",  and should be more precise in that case. Other solvents are available for AutonBolen.\ncosolvent::String: One of \"Betaine\", \"Proline\", \"Sarcosine\", \"Sorbitol\", \"Sucrose\", \"Tmao\", \"tmao\", \"TMAO\", \"urea\", \"Urea\", \"UREA\", \"UreaApp\", \"UreaMH\"\npdbname::AbstractString: Path to the PDB file of the protein structure.\nsasas::Dict{String, Dict{Symbol, Float64}}: A dictionary containing the change in solvent accessible surface area (SASA) upon denaturation for each amino acid type. This data can be obtained from the m-value server or calculated using GROMACS:\nThe output of the server can be parsed using the parse_mvalue_server_sasa function defined in this module.\nAlternatively, the SASA values can be calculated using GROMACS with the gmx_delta_sasa_per_restype function defined in this module.\ntype::Int: Specifies which SASA value to use from the provided data, because the server provides minimum, average, and maximum values,   according to different denatured models for the protein. The recommended value is 2 for comparison with experimental data.   Normally, GROMACS calculations will provide a single value, so type=1 should be used in that case.\n\nReturns\n\nA named tuple with the following fields:\n\ntot: Total transfer free energy (kcal/mol).\nbb: Contribution from the backbone (kcal/mol).\nsc: Contribution from the side chains (kcal/mol).\nrestype: A dictionary with the transfer free energy contributions per residue type (kcal/mol).\n\nEach entry in the dictionary is a named tuple with bb and sc fields representing the backbone and side chain contributions, respectively.\n\nExample calls\n\n# Using SASA values from the m-value server\nsasas_from_server=parse_mvalue_server_sasa(server_output)\nmvalue(; model=MoeserHorinek, cosolvent=\"urea\", pdbname=\"protein.pdb\", sasas=sasas_from_server, type=2)\n\n# Using SASA values calculated with GROMACS\nsasas_gmx=gmx_delta_sasa_per_restype(native_pdb=\"native.pdb\", desnat_pdb=\"desnat.pdb\")\nmvalue(; model=AutonBolen, cosolvent=\"TMAO\", pdbname=\"protein.pdb\", sasas=sasas_gmx, type=1)\n\nReferences\n\nhttps://doi.org/10.1021/acs.jpcb.7b02138\nhttps://doi.org/10.1016/s0076-6879(07)28023-1\nhttps://www.pnas.org/doi/10.1073/pnas.0706251104\n\n\n\n\n\n","category":"function"},{"location":"mvalues/#MolSimToolkit.gmx_delta_sasa_per_restype","page":"m-value calculator","title":"MolSimToolkit.gmx_delta_sasa_per_restype","text":"gmx_delta_sasa_per_restype(; native_pdb::AbstractString, desnat_pdb::AbstractString, gmx=\"gmx\")\n\nCalculates the change in solvent accessible surface area (SASA) upon denaturation for each amino acid type using GROMACS. Returns a dictionary that can be directly used as input to the mvalue function.\n\nnote: Note\nThis function requires GROMACS (gmx sasa executable) to be installed and accessible from the command line. The path to the gmx executable can be provided with the gmx keyword.\n\nArguments\n\nnative_pdb::AbstractString: Path to the PDB file of the native protein structure.\ndesnat_pdb::AbstractString: Path to the PDB file of the denatured protein structure.\ngmx: the path to the gmx GROMACS exectuable (by default it expects gmx to be on the path).\n\nReturns\n\nA dictionary where each key is an amino acid three-letter code (e.g., \"ALA\", \"PHE\"), and the value is another dictionary with two keys: :sc for side chain SASA values and :bb for backbone SASA values. Each of these keys maps to a tuple containing a single Float64 value representing the change in SASA upon denaturation in Å².\n\n\n\n\n\n","category":"function"},{"location":"mvalues/#MolSimToolkit.parse_mvalue_server_sasa","page":"m-value calculator","title":"MolSimToolkit.parse_mvalue_server_sasa","text":"parse_mvalue_server_sasa(string::AbstractString)\n\nParses the SASA output from the m-value calculator server (http://best.bio.jhu.edu/mvalue/), into a dictionary that can be directly used as input to the mvalue function.\n\nThe input string should contain lines formatted as follows, and correspond to the SASA values for each amino acid type:\n\nsasa_from_server = \"\"\"\nALA \t8 \t (    11.1)     79.1 [   147.1] | (   -13.0)     51.4 [   115.8] \nPHE \t3 \t (   166.9)    197.1 [   230.2] | (    29.4)     56.4 [    83.4] \nLEU \t7 \t (   475.2)    532.2 [   589.3] | (    89.3)    145.3 [   201.3] \n...\nLYS \t6 \t (   171.5)    220.4 [   269.3] | (    -4.5)     42.0 [    88.5] \nARG \t1 \t (   110.2)    124.4 [   138.6] | (    17.1)     25.0 [    33.0] \nCYS \t0 \t (     0.0)      0.0 [     0.0] | (     0.0)      0.0 [     0.0] \n\"\"\"\n\nThis data can be found in the output of the server, under the title  \"Sidechain and Backbone changes in Accessible Surface Area\".\n\nThe function returns a dictionary where each key is an amino acid three-letter code (e.g., \"ALA\", \"PHE\"), and the value  is another dictionary with two keys: :sc for side chain SASA values and :bb for backbone SASA values.  Each of these keys maps to a tuple containing three Float64 values representing the minimum, average, and maximum SASA values in Å².\n\n\n\n\n\n","category":"function"},{"location":"Reweighting/#simulation_reweighting","page":"Simulation Reweighting","title":"Simulation Reweighting","text":"","category":"section"},{"location":"Reweighting/","page":"Simulation Reweighting","title":"Simulation Reweighting","text":"warning: Warning\nThis is an experimental feature. Breaking changes may occur without  a breaking package release.","category":"page"},{"location":"Reweighting/","page":"Simulation Reweighting","title":"Simulation Reweighting","text":"Computes the new weight for a frame of a simulation based on the energy difference between the perturbed and non-perturbed original sampling","category":"page"},{"location":"Reweighting/","page":"Simulation Reweighting","title":"Simulation Reweighting","text":"This resource is based on the Free Energy Perturbation Theory (FEP) in the Molecular Dynamics context. Most of the time, each frame will contribute equally for calculations of some thermodynamic property, however, we can apply a perturbation on one or multiple types of atomic interactions (e.g. making water oxygen and protein carbonyl oxygen interaction more repulsive), making these frames to have different normalized statistical contributions so that we can  possibly preview the outcome of a new simulation with these modifications.","category":"page"},{"location":"Reweighting/#How-to-use-it","page":"Simulation Reweighting","title":"How to use it","text":"","category":"section"},{"location":"Reweighting/","page":"Simulation Reweighting","title":"Simulation Reweighting","text":"julia> using MolSimToolkit","category":"page"},{"location":"Reweighting/#Setting-initial-parameters","page":"Simulation Reweighting","title":"Setting initial parameters","text":"","category":"section"},{"location":"Reweighting/","page":"Simulation Reweighting","title":"Simulation Reweighting","text":"Firstly, we define the simulation object and set the atoms that will determine which interactions will be perturbed:","category":"page"},{"location":"Reweighting/","page":"Simulation Reweighting","title":"Simulation Reweighting","text":"julia> using MolSimToolkit, PDBTools\n\njulia> testdir = \"$(@__DIR__)/test\"\n\"/home/lucasv/.julia/dev/MolSimToolkit/src/Reweighting/test\"\n\njulia> simulation = Simulation(\"$testdir/Testing_reweighting.pdb\", \"/$testdir/Testing_reweighting_10_frames_trajectory.xtc\")\nSimulation \n    Atom type: PDBTools.Atom\n    PDB file: /home/lucasv/.julia/dev/MolSimToolkit/src/Resampling/test/Testing_resampling.pdb\n    Trajectory file: /home/lucasv/.julia/dev/MolSimToolkit/src/Resampling/test/Testing_reweighting_10_frames_trajectory.xtc\n    Total number of frames: 10\n    Frame range: 1:1:10\n    Number of frames in range: 10\n    Current frame: nothing\n\njulia> i1 = PDBTools.selindex(atoms(simulation), \"resname TFE and name O\")\n\njulia> i2 = PDBTools.selindex(atoms(simulation), \"protein and name O\")","category":"page"},{"location":"Reweighting/#Setting-perturbation-function","page":"Simulation Reweighting","title":"Setting perturbation function","text":"","category":"section"},{"location":"Reweighting/","page":"Simulation Reweighting","title":"Simulation Reweighting","text":"In order to obtain these weights, we have to use two functions: the reweight function, which will calculate each weight and the perturbation function, responsible for taking each computed distance between atomic pairs in every frame and determine the resulting energy using these distances in that particular frame based on the applied perturbation.","category":"page"},{"location":"Reweighting/","page":"Simulation Reweighting","title":"Simulation Reweighting","text":"So, secondly, we define some \"perturbation\" function (here we call it gaussian decay) and set up its parameters. Please, take a look at the interface:","category":"page"},{"location":"Reweighting/","page":"Simulation Reweighting","title":"Simulation Reweighting","text":"julia> gaussian_decay(r, α, β) = α*exp(-abs(β)*r^2)\ngaussian_decay (generic function with 1 method)\n\njulia> α = 5.e-3\n0.005\n\njulia> β = 5.e-3\n0.005","category":"page"},{"location":"Reweighting/","page":"Simulation Reweighting","title":"Simulation Reweighting","text":"As it can be seen, the function has to receive two parameters: r which corresponds to the distance between two selected atoms and some parameter to account a modification and change its magnitude, here, we inserted two of them in the same function, α, to change the maximum value of the gaussian curve and β, to adjust its decay behaviour with a given value of r.","category":"page"},{"location":"Reweighting/#Computing-the-new-weights","page":"Simulation Reweighting","title":"Computing the new weights","text":"","category":"section"},{"location":"Reweighting/","page":"Simulation Reweighting","title":"Simulation Reweighting","text":"Finally, using the reweight function, we pass both the simulation and the last function anonymously in the input. Again, watch the interface:","category":"page"},{"location":"Reweighting/","page":"Simulation Reweighting","title":"Simulation Reweighting","text":"julia> cut_off = 12.0\n12.0\n\njulia> weights = reweight(simulation, (i,j,r) -> gaussian_decay(r, α, β), i1, i2; cutoff = cut_off)","category":"page"},{"location":"Reweighting/","page":"Simulation Reweighting","title":"Simulation Reweighting","text":"i and j: if you selected two atom types, i will be the index for either the first, the second, the third and so on up to the last atom of the first group and j will be same, but now for the second one. With these two parameters, it is possible to determine every combination of two atoms, each one coming from one group, and compute the associated dsitance r, so that we are taking into account all interactions between these two atom types to our perturbation. However, if we are dealing with just one group, both of them are indexes for all the atoms of the selected group. Bear in mind that repeated combinations (like i,j = 1,2 or 2,1) will no be computed, since the reweight function calls the map_pairwise! function, from CellListMap.jl that is able to avoid this problem.","category":"page"},{"location":"Reweighting/","page":"Simulation Reweighting","title":"Simulation Reweighting","text":"r: the distance between the twos atoms with indexes i and j in the selected groups.","category":"page"},{"location":"Reweighting/","page":"Simulation Reweighting","title":"Simulation Reweighting","text":"cutoff: the maximum distance that will be computed between two atoms. The default value is 12.0 Angstrom.","category":"page"},{"location":"Reweighting/","page":"Simulation Reweighting","title":"Simulation Reweighting","text":"Once the calculations are finished, the resulted interface is shown, like the example below:","category":"page"},{"location":"Reweighting/","page":"Simulation Reweighting","title":"Simulation Reweighting","text":"-------------\nFRAME WEIGHTS\n-------------\n\nAverage probability = 0.09999999999999999\nstandard deviation = 0.01734935311311546\n\n-------------------------------------------\nFRAME WEIGHTS RELATIVE TO THE ORIGINAL ONES\n-------------------------------------------\n\nAverage probability = 0.45655722352062866\nstandard deviation = 0.0792097248720297\n\n----------------------------------\nCOMPUTED ENERGY AFTER PERTURBATION\n----------------------------------\n\nAverage energy = 0.7973733879299723\nstandard deviation = 0.17177116838361012","category":"page"},{"location":"Reweighting/","page":"Simulation Reweighting","title":"Simulation Reweighting","text":"The data in weights structure is organized as it follows:","category":"page"},{"location":"Reweighting/","page":"Simulation Reweighting","title":"Simulation Reweighting","text":"struct ReweightResults{T<:Real}\n    probability::Vector{T}\n    relative_probability::Vector{T}\n    energy::Vector{T}\nend","category":"page"},{"location":"Reweighting/","page":"Simulation Reweighting","title":"Simulation Reweighting","text":"As an example, if we want the absolute weights computed for our simulation:","category":"page"},{"location":"Reweighting/","page":"Simulation Reweighting","title":"Simulation Reweighting","text":"julia> weights.probability\n10-element Vector{Float64}:\n 0.08987791339898044\n 0.07326337222373071\n 0.0973116226496827\n 0.10965810145525891\n 0.09829891590498603\n 0.0916792371461855\n 0.08548699059703141\n 0.12480704633057726\n 0.09973413264337352\n 0.12988266765019355","category":"page"},{"location":"Reweighting/#Reference-Functions","page":"Simulation Reweighting","title":"Reference Functions","text":"","category":"section"},{"location":"Reweighting/#MolSimToolkit.Reweighting.reweight-Tuple{Simulation, Function, AbstractVector{<:Integer}}","page":"Simulation Reweighting","title":"MolSimToolkit.Reweighting.reweight","text":"reweight(\n    simulation::Simulation, \n    f_perturbation::Function, \n    group_1::AbstractVector{<:Integer}; \n    cutoff::Real = 12.0, \n    k::Real = 1.0, \n    T::Real = 1.0\n)\nreweight(\n    simulation::Simulation, \n    f_perturbation::Function, \n    group_1::AbstractVector{<:Integer}, \n    group_2::AbstractVector{<:Integer};     \n    cutoff::Real = 12.0, \n    k::Real = 1.0, \n    T::Real = 1.0\n)\n\nFunction that calculates the energy difference when a perturbation is applied on the system.\n\nIt returns \"ReweightResults\" structure that contains three results: probability, relative_probability and energy vectors.\n\nThe function needs a MolSimToolkit's simulation object, another function to compute the perturbation and one or two types of atoms.\n\nAdditionally, you can also define a cutoff distance, the constant \"k\" (in some cases, it will be Boltzmann constant) and the temperature, T, of the system.\n\nGroup1 (and group2) is a vector of atoms indexes, extracted, for example, from a pdb file. \n\nExample\n\njulia> import PDBTools\n\njulia> using MolSimToolkit, MolSimToolkit.Resampling\n\njulia> simulation = Simulation(\"/home/runner/work/MolSimToolkit.jl/MolSimToolkit.jl/src/Reweighting/test/Testing_reweighting.pdb\", \"//home/runner/work/MolSimToolkit.jl/MolSimToolkit.jl/src/Reweighting/test/Testing_reweighting_10_frames_trajectory.xtc\")\nSimulation \n    Atom type: Atom\n    PDB file: /home/lucasv/.julia/dev/MolSimToolkit/src/Reweighting/test/Testing_reweighting.pdb\n    Trajectory file: /home/lucasv/.julia/dev/MolSimToolkit/src/Resampling/test/Testing_reweighting_10_frames_trajectory.xtc\n    Total number of frames: 10\n    Frame range: 1:1:10\n    Number of frames in range: 10\n    Current frame: nothing\n\njulia> i1 = PDBTools.selindex(atoms(simulation), \"index 97 or index 106\")\n2-element AbstractVector{<:Integer}:\n  97\n 106\n\njulia> i2 = PDBTools.selindex(atoms(simulation), \"residue 15 and name HB3\")\n1-element AbstractVector{<:Integer}:\n 171\n\njulia> sum_of_dist = reweight(simulation, (i,j,d2) -> d2, i1, i2; cutoff = 25.0)\n-------------\nFRAME WEIGHTS\n-------------\n\nAverage probability = 0.1\nstandard deviation = 0.011364584999859616\n\n-------------------------------------------\nFRAME WEIGHTS RELATIVE TO THE ORIGINAL ONES\n-------------------------------------------\n\nAverage probability = 0.6001821184861403\nstandard deviation = 0.06820820700931557\n\n----------------------------------\nCOMPUTED ENERGY AFTER PERTURBATION\n----------------------------------\n\nAverage energy = 0.5163045415662408\nstandard deviation = 0.11331912115883522\n\njulia> sum_of_dist.energy\n10-element Vector{Real}:\n 17.738965476707595\n 15.923698293115915\n 17.16614676290554\n 19.33003841107648\n 16.02329229247863\n 19.639005665480983\n 35.73986006775934\n 21.88798265022823\n 20.66180657974777\n 16.845109623700647\n\nThis result is the energy difference between the  perturbed frame and the original one. In this case, it is the sum of distances between the reffered atoms\n\n\n\n\n\n","category":"method"},{"location":"Reweighting/#MolSimToolkit.Reweighting.ReweightResults","page":"Simulation Reweighting","title":"MolSimToolkit.Reweighting.ReweightResults","text":"Structure that contains the result of the reweighting analysis of the sequence. \n\nprobability is a vector that contains the normalized weight of each frame in the simulation after applying some perturbation. \n\nrelative_probability is a vector that contains the weight of each frame in the simulation relative to the original one after applying some perturbation.\n\nenergy is a vector that contains the energy difference for each frame in the simulation after applying some perturbation.\n\n\n\n\n\n","category":"type"},{"location":"Solvation_and_interactions/#Solvation-and-interactions","page":"Coordination numbers","title":"Solvation and interactions","text":"","category":"section"},{"location":"Solvation_and_interactions/#MolSimToolkitShared.bulk_coordination-Tuple{Simulation}","page":"Coordination numbers","title":"MolSimToolkitShared.bulk_coordination","text":"bulk_coordination(\n    simulation::Simulation;\n    reference_solute::AbstractVector{<:PDBTools.Atom}, \n    solute::AbstractVector{<:PDBTools.Atom},\n    n_atoms_per_molecule_solute::Integer,\n    solvent::AbstractVector{<:PDBTools.Atom}, \n    n_atoms_per_molecule_solvent::Integer,\n    dmax::Real = 5.0,\n    cutoff::Real = 20.0,\n    bin_size::Real = 0.1,\n    show_progress = true,\n)\n\nComputes the coordination number of one type of solvent molecule relative to another  solvent molecule, as a function of the distance to a reference solute molecule. \n\nFor example, imagine a protein solvated in a mixture of water and TMAO. This function allows to compute the number of water molecules that are within a given distance to the TMAO molecules, as a function of the distance to the protein. That is, it computes the coordination number of water relative to TMAO, as a function of the distance to the protein.\n\nThe function returns the the distances and the histogram of the coordination number as a function of  the distance.\n\ncompat: Compat\nThis function was introduced in version 1.11.0 of MolSimToolkit.jl.\n\nArguments\n\nsimulation::Simulation: The simulation object\nreference_solute::AbstractVector{PDBTools.Atom}: The atoms of the reference solute molecule  (the protein in the example above).\nsolute::AbstractVector{PDBTools.Atom}: The atoms of the solute molecule (the TMAO in the example above).\nn_atoms_per_molecule_solute::Integer: The number of atoms per molecule of the solute.\nsolvent::AbstractVector{PDBTools.Atom}: The atoms of the solvent molecule (the water in the example above).\nn_atoms_per_molecule_solvent::Integer: The number of atoms per molecule of the solvent.\ndmax::Real = 5.0: The maximum distance to the solute to consider a solvent molecule as coordinated.\ncutoff::Real = 20.0: The maximum distance to the reference molecule for computing the histogram.\nbin_size::Real = 0.1: The size of the bins for the histogram.\nshow_progress = true: Whether to show a progress bar.\n\nExample\n\njulia> using MolSimToolkit, PDBTools\n\njulia> pdb = readPDB(MolSimToolkit.Testing.namd2_pdb); # protein-tmao-water system\n\njulia> trajectory = MolSimToolkit.Testing.namd2_traj;\n\njulia> simulation = Simulation(pdb, trajectory)\nSimulation \n    Atom type: Atom\n    PDB file: -\n    Trajectory file: /home/leandro/.julia/dev/MolSimToolkit/test/data/namd/protein_in_water_tmao/trajectory.dcd\n    Total number of frames: 20\n    Frame range: 1:1:20\n    Number of frames in range: 20\n    Current frame: nothing\n\njulia> r, h = bulk_coordination(\n           simulation;\n           reference_solute = select(pdb, \"protein\"),\n           solute = select(pdb, \"resname TMAO\"),\n           n_atoms_per_molecule_solute = 14,\n           solvent = select(pdb, \"water\"),\n           n_atoms_per_molecule_solvent = 3,\n       );\n\njulia> using Plots\n\njulia> plot(r, h, # plots `h` as a function of `r`\n           xlabel = \"Distance to protein (Å)\",\n           ylabel = \"TMAO-water Coordination number\",\n           linewidth=2,\n           label=:none, framestyle=:box, fontfamily=\"Computer Modern\",\n       )\n\n\n\n\n\n","category":"method"},{"location":"Solvation_and_interactions/#MolSimToolkitShared.coordination_number-Tuple{Simulation, AbstractVector{<:PDBTools.Atom}, AbstractVector{<:PDBTools.Atom}}","page":"Coordination numbers","title":"MolSimToolkitShared.coordination_number","text":"coordination_number(\n    sim::Simulation,\n    solute::AbstractVector{<:PDBTools.Atom},\n    solvent::AbstractVector{<:PDBTools.Atom};\n    solvent_natomspermol::Integer,\n    cutoff::Real,\n    show_progress::Bool = true\n)\n\nCalculate the coordination number of the solute atoms with the solvent atoms.\n\nnote: Note\nThe distance considered is the minimum distance between the solute atoms  and the atoms of each solvent molecule.\n\nPositional Arguments\n\nsim::Simulation: Simulation object.\nsolute::AbstractVector{<:PDBTools.Atom}: Vector of solute atoms.\nsolvent::AbstractVector{<:PDBTools.Atom}: Vector of solvent atoms.\n\nKeyword Arguments\n\nsolvent_natomspermol::Integer: Number of atoms per solvent molecule.\ncutoff::Real: Cutoff distance.\nshow_progress::Bool: Show progress bar. (optional, default: true)\n\nReturns\n\ncn::Vector{Int}: Vector with the coordination number of the solute atoms with the solvent atoms, at each frame.\n\nExample\n\njulia> using MolSimToolkit, PDBTools, MolSimToolkit.Testing\n\njulia> sim = Simulation(Testing.namd2_pdb, Testing.namd2_traj; frames=1:5);\n\njulia> protein = select(atoms(sim), \"protein\");\n\njulia> tmao = select(atoms(sim), \"resname TMAO\");\n\njulia> coordination_number(sim, protein, tmao; solvent_natomspermol=14, cutoff=3.0, show_progress=false)\n5-element Vector{Int64}:\n 7\n 3\n 4\n 5\n 6\n\n\n\n\n\n\n","category":"method"},{"location":"remd/#Replica-exchange-analysis","page":"Replica exchange","title":"Replica exchange analysis","text":"","category":"section"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"The remd_data function reads the output of a Gromacs-generated  replica-exchange simulation file, and provides some tools for visualization of the quality of the exchange process.","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"compat: Compat\nThis function was introduced in MolSimToolkit version 1.1.0. The function was tested to read log files produced by Gromacs versions: 2019.4\n5.0.4Compatibility with other versions is not guaranteed (issue reporting and contributions are welcome). The heatmap and the support for the stride argument in remd_replica_path where introduced in version 1.6.0","category":"page"},{"location":"remd/#Reading-REMD-data","page":"Replica exchange","title":"Reading REMD data","text":"","category":"section"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"First, read the data from the Gromacs simulation log file:","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"julia> using MolSimToolkit\n\njulia> data = remd_data(\"gromacs.log\")","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"where \"gromacs.log\" would be a log file produced by Gromacs.","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"This will result in a data structure with three fields:","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"steps: Vector of steps at which the exchange was performed.\nexchange_matrix: Matrix of exchanges performed.  Each row corresponds to a step and each column to a replica. \nprobability_matrix: Matrix of probabilities of finding each replica at level of  perturbation. Each column corresponds to a replica and each row to a level of perturbation.","category":"page"},{"location":"remd/#Probability-heatmap","page":"Replica exchange","title":"Probability heatmap","text":"","category":"section"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"One way to visualize the exchange it to produce a heatmap of expected probabilities. This can be done with the auxiliary heatmap function that is provided for the output of remd_data: ","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"using MolSimToolkit\nusing Plots\ndata = remd_data(MolSimToolkit.gmx5_0_4_log)\nheatmap(data)","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"The number of replicas here is 16 (0-15), thus the expected ideal probability of finding each replica in each level is 116. The probabilities are divided by 116, such that 10 implies  an optimal exchange at that replica and level. ","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"To produce a similar heatmap, but with the absolute (not normalized) probabilities of  observing each replica at each level, use heatmap(data; probability_type=:absolute). ","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"In the above example, replica 1 got trapped in the first 5 levels,  while a block is noticeable for replicas 10-12, which display high  probabilities to be found at levels 13 to 15. Thus, this is an example of a inadequate exchange between the levels.","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"compat: Compat\nThe probability_type option of heatmap was introduced in version 1.7.0.","category":"page"},{"location":"remd/#Replica-path","page":"Replica exchange","title":"Replica path","text":"","category":"section"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"A heatmap as the one above suggests checking the path of the replicas along the exchange.  This can be obtained with the remd_replica_path function. For example, to obtain the path of the replicas of number 0 and 1. Replica 0 appeares to have visited reasonably well  all levels from 0 to 12, and replica 1 appears to be trapped in leves 13 to 15.","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"using MolSimToolkit\nusing Plots\ndata = remd_data(MolSimToolkit.gmx5_0_4_log)\n\n# Obtain the paths\npath0 = remd_replica_path(data, 0; stride = 1)\npath10 = remd_replica_path(data, 10; stride = 1)\n\n# Plot the path\nplt = plot(MolSimStyle, xlabel=\"step\", ylabel=\"replica level\")\nplot!(plt, path0, label=\"replica 0\", linewidth=2)\nplot!(plt, path10, label=\"replica 10\", linewidth=2)","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"The plot confirms that the replica starting at position 0 sampled preferentially the  first 5 states, while replica 10 was trapped temporarily in the high level states, in this sample run.","category":"page"},{"location":"remd/#Probability-data","page":"Replica exchange","title":"Probability data","text":"","category":"section"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"An alternative visualization of the exchange process is given by the probability matrix:","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"using MolSimToolkit\nusing Plots\ndata = remd_data(MolSimToolkit.gmx5_0_4_log)\nscatter(MolSimStyle,\n    data.probability_matrix,\n    labels= Ref(\"Replica \") .* string.((0:15)'),\n    linewidth=2,\n    ylims=(0,0.12), xlims=(0.7, 16.3),\n    xlabel=\"Level\", xticks=(1:16, 0:15),\n    ylabel=\"Probability\",\n    alpha=0.5,\n    margin=0.5Plots.Measures.cm,\n    legend=:outertopright,\n)","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"Ideally, the probability of each replica populaing each level should be the inverse of the number of replicas (here 116 == 00625). In this case, the simulation does not provide a proper sampling of exchanges, as it is a short extract of a longer simulation. ","category":"page"},{"location":"remd/#Reference-functions","page":"Replica exchange","title":"Reference functions","text":"","category":"section"},{"location":"remd/#MolSimToolkit.remd_data-Tuple{String}","page":"Replica exchange","title":"MolSimToolkit.remd_data","text":"remd_data(log::String)\n\nFunction to read the log file from a (H)REMD simulation performed with Gromacs.\n\nReturns a GromacsREMDlog structure, containing the steps at which the exchange was tried, the exchange matrix and the probability matrix. The exchange matrix contains the replica number at each level of perturbation for each step. The probability matrix contains the probability of finding each replica at each level.\n\nTested with log files of Gromacs versions:      - 2019.4     - 5.0.4\n\nExample\n\nFirst obtaina the REMD data from the log file:\n\njulia> using MolSimToolkit\n\njulia> data = remd_data(MolSimToolkit.gmx2019_9_log)\n\nThen plot the exchange matrix, which will provide a visual inspection of the exchange process:\n\njulia> using Plots\n\njulia> heatmap(data) \n\n\n\n\n\n","category":"method"},{"location":"remd/#MolSimToolkit.remd_replica_path-Tuple{MolSimToolkit.GromacsREMDlog, Integer}","page":"Replica exchange","title":"MolSimToolkit.remd_replica_path","text":"remd_replica_path(data::GromacsREMDlog, replica::Integer; stride::Integer = 1)\n\nFunction to obtain the path of a replica in the exchange matrix.\n\n\n\n\n\n","category":"method"},{"location":"remd/#MolSimToolkit.GromacsREMDlog","page":"Replica exchange","title":"MolSimToolkit.GromacsREMDlog","text":"GromacsRMEDlog\n\nStructure to store the log from a REMD simulation performed with Gromacs.  This structure contains three fields:\n\nsteps: Vector of steps at which the exchange was performed.\nexchange_matrix: Matrix of exchanges performed.  Each row corresponds to a step and each column to a replica. \nprobability_matrix: Matrix of probabilities of finding each replica at level of  perturbation. Each column corresponds to a replica and each row to a level of perturbation.\n\n\n\n\n\n","category":"type"},{"location":"remd/#Plots.heatmap-Tuple{MolSimToolkit.GromacsREMDlog}","page":"Replica exchange","title":"Plots.heatmap","text":"heatmap(data::GromacsREMDlog;\n    xlabel=\"replica\",\n    ylabel=\"initial replica level\",\n    fontfamily=\"Computer Modern\",\n    probability_type::Symbol=:relative,\n    kargs...\n)\n\nFunction to plot the probability matrix of a (H)REMD simulation. The probability matrix contains the probability of finding each replica at each level of perturbation.\n\nUse probability_type=:relative to plot the probability matrix normalized by the number of replicas, or probability_type=:absolute to plot the probability matrix without normalization.\n\nExample\n\njulia> using MolSimToolkit, Plots\n\njulia> data = remd_data(MolSimToolkit.gmx2019_4_log)\n\njulia> heatmap(data)\n\n\n\n\n\n","category":"method"},{"location":"molecular_minimum_distances/#Molecular-Minimum-Distances","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Computes the minimum distance between molecules, which are represented as arrays of coordinates in two or three dimensions. ","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"To understand the utility and purpose of this package, consider the image below:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"(Image: nearest.png)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Here, there is one blue molecule, with 6 atoms, and several red molecules, with 2 atoms each. The package has identified which are the molecules of the red set that have at leat one atom within a cutoff from the atoms of the blue molecule, and annotated the corresponding atoms and the distances.","category":"page"},{"location":"molecular_minimum_distances/#Features","page":"Molecular Minimum Distances","title":"Features","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Fast cell-list approach, to compute minimum-distance for thousands, or millions of atoms. \nGeneral periodic boundary conditions supported. \nAdvanced mode for in-place calculations, for non-allocating iterative calls (for analysis of MD trajectories, for example).\nModes for the calculation of minimum-distances in sets of molecules.","category":"page"},{"location":"molecular_minimum_distances/#Most-typical-use:-Understanding-solvation","page":"Molecular Minimum Distances","title":"Most typical use: Understanding solvation","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The most typical scenario is that of a protein, or another macromolecule, in a box of solvent. For example, here we download a frame of a protein which was simulated in a mixture of water and TMAO: ","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> using MolSimToolkit, PDBTools\n\njulia> atoms = MolSimToolkit.MolecularMinimumDistances.download_example()\n   Array{Atoms,1} with 62026 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z  beta occup model segname index_pdb\n       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  0.00  1.00     1    PROT         1\n       2  HT1     ALA     A        1        1  -10.048  -15.427   -5.569  0.00  0.00     1    PROT         2\n       3  HT2     ALA     A        1        1   -9.488  -13.913   -5.295  0.00  0.00     1    PROT         3\n                                                       ⋮ \n   62024  OH2    TIP3     C     9339    19638   13.485   -4.534  -34.438  0.00  1.00     1    WAT2     62024\n   62025   H1    TIP3     C     9339    19638   13.218   -3.647  -34.453  0.00  1.00     1    WAT2     62025\n   62026   H2    TIP3     C     9339    19638   12.618   -4.977  -34.303  0.00  1.00     1    WAT2     62026","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Next, we extract the protein coordinates, and the TMAO coordinates:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> protein = coor(atoms,\"protein\")\n1463-element Vector{SVector{3, Float64}}:\n [-9.229, -14.861, -5.481]\n [-10.048, -15.427, -5.569]\n [-9.488, -13.913, -5.295]\n ⋮\n [6.408, -12.034, -8.343]\n [6.017, -10.967, -9.713]\n\njulia> tmao = coor(atoms,\"resname TMAO\")\n2534-element Vector{SVector{3, Float64}}:\n [-23.532, -9.347, 19.545]\n [-23.567, -7.907, 19.381]\n [-22.498, -9.702, 20.497]\n ⋮\n [13.564, -16.517, 12.419]\n [12.4, -17.811, 12.052]","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The system was simulated with periodic boundary conditions, with sides in this frame of [83.115, 83.044, 83.063], and this information will be provided to the minimum-distance computation.","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Finally, we find all the TMAO molecules having at least one atom closer than 12 Angstroms to the protein, using the current package (TMAO has 14 atoms):","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> list = minimum_distances(\n           xpositions=tmao, # solvent\n           ypositions=protein, # solute\n           xn_atoms_per_molecule=14,\n           cutoff=12.0,\n           unitcell=[83.115, 83.044, 83.063]\n       )\n181-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n ⋮\n MinimumDistance{Float64}(true, 2526, 97, 9.652277658666891)\n\njulia> count(x -> x.within_cutoff, list)\n33","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Thus, 33 TMAO molecules are within the cutoff distance from the protein, and the distances can be used to study the solvation of the protein.","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"tip: Tip\nThe coordination_number function of this package essentially performs the above calculation iteratively  along a trajectory. The source of of such function is simple and can be used to further understand the utility and usage of the minimum-distance calculations.","category":"page"},{"location":"molecular_minimum_distances/#Performance","page":"Molecular Minimum Distances","title":"Performance","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"This package exists because this computation is fast. For example, let us choose the water molecules instead, and benchmark the time required to compute this set of distances:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> water = coor(atoms,\"resname TIP3\")\n58014-element Vector{SVector{3, Float64}}:\n [-28.223, 19.92, -27.748]\n [-27.453, 20.358, -27.476]\n [-27.834, 19.111, -28.148]\n ⋮\n [13.218, -3.647, -34.453]\n [12.618, -4.977, -34.303]\n\njulia> using BenchmarkTools\n\njulia> @btime minimum_distances(\n           xpositions=$water, # solvent\n           ypositions=$protein, # solute\n           xn_atoms_per_molecule=3,\n           cutoff=12.0,\n           unitcell=[83.115, 83.044, 83.063]\n       );\n  6.288 ms (3856 allocations: 13.03 MiB)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"To compare, a naive algorithm to compute the same thing takes roughly 400x more for this system size:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> @btime MolSimToolkit.MolecularMinimumDistances.naive_md($water, $protein, 3, [83.115, 83.044, 83.063], 12.0);\n  2.488 s (97 allocations: 609.16 KiB)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"And the computation can be made faster and in-place using the more advanced interface that allows preallocation of main necessary arrays:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> sys = CrossPairs(\n           xpositions=water, # solvent\n           ypositions=protein, # solute\n           xn_atoms_per_molecule=3,\n           cutoff=12.0,\n           unitcell=[83.115, 83.044, 83.063]\n       )\nCrossPairs system with:\n\nNumber of atoms of set: 58014\nNumber of atoms of target structure: 1463\nCutoff: 12.0\nunitcell: [83.12, 0.0, 0.0, 0.0, 83.04, 0.0, 0.0, 0.0, 83.06]\nNumber of molecules in set: 4144\n\njulia> @btime minimum_distances!($sys);\n  2.969 ms (196 allocations: 22.80 KiB)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The remaining allocations occur only for the launching of multiple threads:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> sys = CrossPairs(\n           xpositions=water, # solvent\n           ypositions=protein, # solute\n           xn_atoms_per_molecule=14,\n           cutoff=12.0,\n           unitcell=[83.115, 83.044, 83.063],\n           parallel=false # default is true\n       );\n\njulia> @btime minimum_distances!($sys);\n  15.249 ms (0 allocations: 0 bytes)","category":"page"},{"location":"molecular_minimum_distances/#Example-input-files","page":"Molecular Minimum Distances","title":"Example input files","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The examples here use a molecular system, but the package actually only considers the coordinates of the atoms and the number of atoms of each molecule. Thus, more general distance problems can be tackled.","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The input atomic positions used in the following examples can be obtained with:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> using MolSimToolkit, PDBTools\n\njulia> system = MolSimToolkit.MolecularMinimumDistances.download_example() \n   Array{Atoms,1} with 62026 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z  beta occup model segname index_pdb\n       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  0.00  1.00     1    PROT         1\n       2  HT1     ALA     A        1        1  -10.048  -15.427   -5.569  0.00  0.00     1    PROT         2\n       3  HT2     ALA     A        1        1   -9.488  -13.913   -5.295  0.00  0.00     1    PROT         3\n                                                       ⋮ \n   62024  OH2    TIP3     C     9339    19638   13.485   -4.534  -34.438  0.00  1.00     1    WAT2     62024\n   62025   H1    TIP3     C     9339    19638   13.218   -3.647  -34.453  0.00  1.00     1    WAT2     62025\n   62026   H2    TIP3     C     9339    19638   12.618   -4.977  -34.303  0.00  1.00     1    WAT2     62026\n","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The system consists of a protein (with 1463 atoms), solvated by 181 TMAO molecules (with 14 atoms each), 19338 water molecules, and some ions. ","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"These coordinates belong to a snapshot of a simulation which was performed with cubic periodic boundary conditions, with a box side of 84.48 Angstrom. ","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The coordinates of each of the types of molecules can be extracted from the system array of atoms with (using PDBTools - v0.13 or greater):","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> protein = coor(system,\"protein\")\n1463-element Vector{StaticArrays.SVector{3, Float64}}:\n [-9.229, -14.861, -5.481]\n [-10.048, -15.427, -5.569]\n [-9.488, -13.913, -5.295]\n ⋮\n [6.408, -12.034, -8.343]\n [6.017, -10.967, -9.713]\n\njulia> tmao = coor(system,\"resname TMAO\")\n2534-element Vector{StaticArrays.SVector{3, Float64}}:\n [-23.532, -9.347, 19.545]\n [-23.567, -7.907, 19.381]\n [-22.498, -9.702, 20.497]\n ⋮\n [13.564, -16.517, 12.419]\n [12.4, -17.811, 12.052]\n\njulia> water = coor(system,\"water\")\n58014-element Vector{StaticArrays.SVector{3, Float64}}:\n [-28.223, 19.92, -27.748]\n [-27.453, 20.358, -27.476]\n [-27.834, 19.111, -28.148]\n ⋮\n [13.218, -3.647, -34.453]\n [12.618, -4.977, -34.303]","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Using these vectors of coordinates, we will illustrate the use of the current package.","category":"page"},{"location":"molecular_minimum_distances/#Shortest-distances-from-a-solute","page":"Molecular Minimum Distances","title":"Shortest distances from a solute","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The simplest usage consists of finding for each molecule of one set the atoms of the other set which are closer to them. For example, here we want the atoms of the proteins which are closer to each TMAO molecule (14 atoms), within a cutoff of 12.0 Angstroms.","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The simulations was performed with periodic boundary conditions, in a cubic box of sides [84.48, 84.48, 84.48]. We compute the minimum distances with:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> list = minimum_distances(\n           xpositions=tmao, # solvent\n           ypositions=protein, # solute\n           xn_atoms_per_molecule=14,\n           cutoff=12.0,\n           unitcell=[84.48, 84.48, 84.48]\n       )\n181-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n ⋮\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(true, 2526, 97, 9.652277658666891)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The list contains, for each molecule of TMAO, a MinimumDistance object, containing the following fields,  exemplified by printing the last entry of the list:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> list[end]\nMinimumDistance{Float64}(true, 2526, 97, 9.652277658666891)\n\nDistance within cutoff, within_cutoff = true\nx atom of pair, i = 2526\ny atom of pair, j = 97\nDistance found, d = 9.652277658666891","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The fields within_cutoff, i, j, and d show if a distance was found within the cutoff, the indices of the atoms involved in the contact, and their distance.","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Getter functions are available to extract eac hof these fields, to add some convenience: within_cutoff, iatom, jatom, and distance.","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"note: Note\nIf the solute has more than one molecule, this will not be taken into  consideration in this mode. All molecules will be considered as part of the same structure (the number of atoms per molecule of the protein is not a parameter here).","category":"page"},{"location":"molecular_minimum_distances/#All-shortest-distances","page":"Molecular Minimum Distances","title":"All shortest distances","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"A similar call of the previous section can be used to compute, for each molecule of a set of molecules, which is the closest atom of every other molecule of another set. ","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"In the example, we can compute for each TMAO molecule, which is the closest atom of water, and vice-versa. The difference from the previous call is that now wee need to provide the number of atoms of both TMAO and water:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> water_list, tmao_list = minimum_distances(\n           xpositions=water,\n           ypositions=tmao,\n           xn_atoms_per_molecule=3,\n           yn_atoms_per_molecule=14,\n           unitcell=[84.48, 84.48, 84.48],\n           cutoff=12.0\n       );\n\njulia> water_list\n19338-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 2, 1512, 4.779476331147592)\n MinimumDistance{Float64}(true, 6, 734, 2.9413928673334357)\n MinimumDistance{Float64}(true, 8, 859, 5.701548824661595)\n ⋮\n MinimumDistance{Float64}(true, 58010, 1728, 3.942870781549911)\n MinimumDistance{Float64}(true, 58014, 2058, 2.2003220218867936)\n\njulia> tmao_list\n181-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 12, 22520, 2.1985345118965056)\n MinimumDistance{Float64}(true, 20, 33586, 2.1942841657360606)\n MinimumDistance{Float64}(true, 37, 26415, 2.1992319113726926)\n ⋮\n MinimumDistance{Float64}(true, 2512, 37323, 2.198738501959709)\n MinimumDistance{Float64}(true, 2527, 33664, 2.1985044916943015)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Two lists were returned, the first containing, for each water molecule, MinimumDistance data associated to the closest TMAO molecule (meaning the atoms involved in the contact and their distance). Similarly, the second list contains, for each TMAO molecule, the MinimumDistance data associated to each TMAO molecule. ","category":"page"},{"location":"molecular_minimum_distances/#Shortest-distances-within-molecules","page":"Molecular Minimum Distances","title":"Shortest distances within molecules","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"There is an interface to compute the shortest distances of molecules within a set of molecules. That is, given one group of molecules, compute for each molecule which is the shortest distance among the other molecules of the same type. ","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"A typical call would be:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> water_list = minimum_distances(\n           xpositions=water,\n           xn_atoms_per_molecule=3,\n           unitcell=[84.48, 84.48, 84.48],\n           cutoff=12.0\n       )\n19338-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 2, 33977, 2.1997806708851724)\n MinimumDistance{Float64}(true, 4, 43684, 2.1994928961012814)\n MinimumDistance{Float64}(true, 9, 28030, 2.1997583958244142)\n ⋮\n MinimumDistance{Float64}(true, 58010, 22235, 2.1992096307537414)\n MinimumDistance{Float64}(true, 58012, 9318, 2.20003227249056)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Which contains for each water molecule the atoms involved in the closest contact to any other water molecule, and the distances (within the cutoff). A pictorial representation of a result of this type is, for a simpler system:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"(Image: self pairs)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"This can be used for the identification of connectivity networks, for example, or for some types of clustering.","category":"page"},{"location":"molecular_minimum_distances/#Advanced-usage","page":"Molecular Minimum Distances","title":"Advanced usage","text":"","category":"section"},{"location":"molecular_minimum_distances/#System-build-and-update","page":"Molecular Minimum Distances","title":"System build and update","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"If the molecular minimum distances will be computed many times for similar systems, it is possible to construct the system and update its properties. The use of the interface of CellListMap is required (requires CellListMap version 0.7.24 or greater). ","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"For example, let us build one system with a protein and water:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> using MolSimToolkit, PDBTools\n\njulia> system = MolecularMinimumDistances.download_example();\n\njulia> protein = coor(system, \"protein\");\n\njulia> water = coor(system, \"water\");","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"We now build the CrossPairs  type of system, instead of calling the minimum_distances function directly:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> sys = CrossPairs(\n           xpositions=water, # solvent\n           ypositions=protein, # solute\n           xn_atoms_per_molecule=3,\n           cutoff=12.0,\n           unitcell=[84.48, 84.48, 84.48]\n       )\nCrossPairs system with:\n\nNumber of atoms of set x: 58014\nNumber of molecules in set x: 19338\nNumber of atoms of target structure y: 1463\nCutoff: 12.0\nunitcell: [84.48, 0.0, 0.0, 0.0, 84.48, 0.0, 0.0, 0.0, 84.48]","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Now sys  contains the necessary arrays for computing the list of minimum distances. We use now the minimum_distances!  function (with the !), to update that list:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> minimum_distances!(sys)\n19338-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n ⋮\n MinimumDistance{Float64}(true, 58011, 383, 10.24673074692606)\n MinimumDistance{Float64}(false, 0, 0, Inf)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The system can be now updated: the positions, cutoff, or unitcell can be modified, with the  following interfaces:","category":"page"},{"location":"molecular_minimum_distances/#Updating-positions","page":"Molecular Minimum Distances","title":"Updating positions","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"To update the positions, modify the sys.xpositions (or ypositions)  array. We will boldy demonstrate this by making the first atom of the x set to be close to the first atom of the protein, and recomputing the distances:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> using StaticArrays\n\njulia> sys.xpositions[2] = sys.ypositions[1] + SVector(1.0,0.0,0.0);\n\njulia> minimum_distances!(sys)\n19338-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 2, 4, 0.9202923448556931)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n ⋮\n MinimumDistance{Float64}(true, 58011, 383, 10.24673074692606)\n MinimumDistance{Float64}(false, 0, 0, Inf)","category":"page"},{"location":"molecular_minimum_distances/#Updating-the-cutoff,-unitcell-and-parallel-flag","page":"Molecular Minimum Distances","title":"Updating the cutoff, unitcell and parallel flag","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The cutoff, unitcell and parallel data of the sys objects can be modified  directly. For example:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> sys\nCrossPairs system with:\n\nNumber of atoms of set x: 58014\nNumber of molecules in set x: 19338\nNumber of atoms of target structure y: 1463\nCutoff: 15.0\nunitcell: [100.0, 0.0, 0.0, 0.0, 100.0, 0.0, 0.0, 0.0, 100.0]\n\njulia> sys.cutoff = 10.0\n10.0\n\njulia> sys.unitcell = [84.4, 84.4, 84.4]\n3-element Vector{Float64}:\n 84.4\n 84.4\n 84.4\n\njulia> sys.parallel = false\nfalse\n\njulia> sys\nCrossPairs system with:\n\nNumber of atoms of set x: 58014\nNumber of molecules in set x: 19338\nNumber of atoms of target structure y: 1463\nCutoff: 10.0\nunitcell: [84.4, 0.0, 0.0, 0.0, 84.4, 0.0, 0.0, 0.0, 84.4]","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"note: Note\nIt is not possible to update the unitcell from a Orthorhombic to a general Triclinic cell. If the system will be Triclinic at any moment, the unitcell must be initialized with the full matrix instead of a  vector of sides.","category":"page"},{"location":"molecular_minimum_distances/#Index-of-molecules","page":"Molecular Minimum Distances","title":"Index of molecules","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Additionally, the low level interface allows the definition of more general groups of particles, in the sense that \"molecule\" can have different number of atoms in the same set. Therefore, one needs to provide a function that returns the index of the molecule of each atom, given the index of the atom. ","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Briefly, if a set of atoms belong to molecules of the same number of atoms, one can compute the index of each molecule using","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"mol_indices(i,n) = div((i - 1), n) + 1","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"where i is the atom index in the array of coordinates, and n is the number of atoms per molecule. This is the default assumed in the basic interface, and can be called with:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> using StaticArrays\n\njulia> x = rand(SVector{3,Float64},9); # 3 water molecules\n\njulia> mol_indices(2,3) # second atom belongs to first molecule\n1\n\njulia> mol_indices(4,3) # fourth atom belongs to second molecule\n2","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Typically, as we will show, this function will be used for setting up molecule indices.","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"However, more general indexing can be used. For instance, let us suppose that the 9 atoms of the x array of coordinates above belong to 2 molecules, with 4 and 5 atoms each. Then, we could define, for example:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> my_mol_indices(i) = i <= 4 ? 1 : 2\nmy_mol_indices (generic function with 1 method)\n\njulia> my_mol_indices(4)\n1\n\njulia> my_mol_indices(5)\n2","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Since the function can close-over an array of molecular indices, the definition can be completely general, that is:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> molecular_indices = [ 1, 3, 3, 2, 2, 1, 3, 1, 2 ];\n\njulia> my_mol_indices(i) = molecular_indices[i]\nmy_mol_indices (generic function with 1 method)\n\njulia> my_mol_indices(1)\n1\n\njulia> my_mol_indices(5)\n2","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"In summary, this function that given the index of the atom returns the index of the corresponding molecule must be provided in the advanced interface, and typically will be just a closure around the number of atoms per molecule, using the already available mol_indices function. ","category":"page"},{"location":"molecular_minimum_distances/#Example","page":"Molecular Minimum Distances","title":"Example","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Let us mix water and TMAO molecules in the same set, and use a general function to compute the indices of the molecules of each atom: ","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> system = MolecularMinimumDistances.download_example();\n\njulia> protein = coor(system, \"protein\");\n\njulia> tmao_and_water = select(system, \"resname TMAO or resname TIP3\")\n   Array{Atoms,1} with 60548 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z  beta occup model segname index_pdb\n    1479    N    TMAO     A        1      120  -23.532   -9.347   19.545  0.00  1.00     1    TMAO      1479\n    1480   C1    TMAO     A        1      120  -23.567   -7.907   19.381  0.00  1.00     1    TMAO      1480\n    1481   C2    TMAO     A        1      120  -22.498   -9.702   20.497  0.00  1.00     1    TMAO      1481\n                                                       ⋮ \n   62024  OH2    TIP3     C     9339    19638   13.485   -4.534  -34.438  0.00  1.00     1    WAT2     62024\n   62025   H1    TIP3     C     9339    19638   13.218   -3.647  -34.453  0.00  1.00     1    WAT2     62025\n   62026   H2    TIP3     C     9339    19638   12.618   -4.977  -34.303  0.00  1.00     1    WAT2     62026\n\njulia> findfirst(at -> at.resname == \"TIP3\", tmao_and_water)\n2535","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Thus, the tmao_and_water atom array has two different types of molecules, TMAO with 14 atoms, and water with 3 atoms.  The first atom of a water molecule is atom 2535 of the array. We extract the coordinates of the atoms with:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> solvent = coor(tmao_and_water)\n60548-element Vector{SVector{3, Float64}}:\n [-23.532, -9.347, 19.545]\n [-23.567, -7.907, 19.381]\n [-22.498, -9.702, 20.497]\n ⋮\n [13.218, -3.647, -34.453]\n [12.618, -4.977, -34.303]","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"And now we define a function that, given the index of the atom, returns the molecule to which it belongs:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> function mol_indices(i) \n           if i < 2535 # TMAO (14 atoms per molecule) \n               div(i-1,14) + 1 \n           else # water (3 atoms per molecule)\n               mol_indices(2534) + div(i-2534-1,3) + 1\n           end\n       end\nmol_indices (generic function with 3 method)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The function above computes the molecular indices for TMAO in the standard way, and computes the water  molecular indices by first summing the molecule index of the last TMAO molecule, and subtracting from the atomic index of water the last index of the last TMAO atom. We can test this: ","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> mol_indices(14) # last atom of first TMAO\n1\n\njulia> mol_indices(15) # first atom of second TMAO\n2\n\njulia> mol_indices(2534) # last atom of last TMAO\n181\n\njulia> mol_indices(2535) # first atom of first water\n182\n\njulia> mol_indices(2537) # last atom of first water\n182\n\njulia> mol_indices(2538) # first atom of second water\n183","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"With this function, we can construct the system using it instead of the xn_atoms_per_molecule integer variable, to obtain the solvation of the protein by both TMAO and water in a single run:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> sys = CrossPairs(\n           xpositions=solvent, # solvent = coor(tmao_and_water)\n           ypositions=protein, # solute\n           xmol_indices = mol_indices,\n           cutoff=12.0,\n           unitcell=[84.48, 84.48, 84.48]\n       )\nCrossPairs system with:\n\nNumber of atoms of set x: 60548\nNumber of molecules in set x: 19519\nNumber of atoms of target structure y: 1463\nCutoff: 12.0\nunitcell: [84.48, 0.0, 0.0, 0.0, 84.48, 0.0, 0.0, 0.0, 84.48]","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"As we can see, the number of molecules is correct (the sum of the number of water and tmao molecules). And the list of minimum distances will retrive the information of the closest protein atom to all solvent molecules of the set:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> minimum_distances!(sys)\n19519-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n ⋮\n MinimumDistance{Float64}(true, 60545, 383, 10.24673074692606)\n MinimumDistance{Float64}(false, 0, 0, Inf)","category":"page"},{"location":"molecular_minimum_distances/#Citation","page":"Molecular Minimum Distances","title":"Citation","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"If this package was useful, please cite the article describing the main algorithms on which it is based:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"L. Martínez, CellListMap.jl: Efficient and customizable cell list implementation for calculation of pairwise particle properties within a cutoff. Computer Physics Communications 279, 108452 (2022). ","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"DOI: 10.1016/j.cpc.2022.108452","category":"page"},{"location":"molecular_minimum_distances/#Help-entries","page":"Molecular Minimum Distances","title":"Help entries","text":"","category":"section"},{"location":"molecular_minimum_distances/#MolSimToolkit.MolecularMinimumDistances.iatom-Tuple{MinimumDistance}","page":"Molecular Minimum Distances","title":"MolSimToolkit.MolecularMinimumDistances.iatom","text":"iatom(md::MinimumDistance) = md.i\n\nReturns the index of the atom of the first set that is closer to the atom of the second set.\n\n\n\n\n\n","category":"method"},{"location":"molecular_minimum_distances/#MolSimToolkit.MolecularMinimumDistances.jatom-Tuple{MinimumDistance}","page":"Molecular Minimum Distances","title":"MolSimToolkit.MolecularMinimumDistances.jatom","text":"jatom(md::MinimumDistance) = md.j\n\nReturns the index of the atom of the second set that is closer to the atom of the first set.\n\n\n\n\n\n","category":"method"},{"location":"molecular_minimum_distances/#MolSimToolkit.MolecularMinimumDistances.minimum_distances!-Tuple{Any}","page":"Molecular Minimum Distances","title":"MolSimToolkit.MolecularMinimumDistances.minimum_distances!","text":"minimum_distances!(system)\n\nFunction that computes the minimum distances for an initialized system, of SelfPairs, CrossPairs, or AllPairs types. \n\nThe function returs a Vector{MinimumDistance} cor SelfPairs and CrossPairs inputs, and a Tuple of two of such vectors for the AllPairs input types.\n\nThis function is used as an advanced alternative from preallocated system inputs. Only a few allocations  remain on a call to minimum_distances!, mostly related to the launch of the multithreaded  calculations.\n\nExample\n\njulia> using MolSimToolkit, StaticArrays\n\njulia> sys = SelfPairs(\n           xpositions = rand(SVector{3,Float64},1000), \n           unitcell=[1,1,1], \n           cutoff = 0.1, \n           xn_atoms_per_molecule=10,\n       )\nSelfPairs system with:\n\nNumber of atoms: 1000\nCutoff: 0.1\nunitcell: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]\nNumber of molecules: 100\n\njulia> minimum_distances!(sys)\n100-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 8, 579, 0.03570387474690425)\n MinimumDistance{Float64}(true, 12, 534, 0.02850448652684309)\n ⋮\n MinimumDistance{Float64}(true, 996, 423, 0.03655145613454862)\n\njulia> using BenchmarkTools\n\njulia> @btime minimum_distances!($sys);\n  178.468 μs (209 allocations: 22.80 KiB)\n\n\n\n\n\n","category":"method"},{"location":"molecular_minimum_distances/#MolSimToolkit.MolecularMinimumDistances.minimum_distances-Tuple{}","page":"Molecular Minimum Distances","title":"MolSimToolkit.MolecularMinimumDistances.minimum_distances","text":"minimum_distances(\n   xpositions::AbstractVector{<:SVector},\n   # or xpositions *and* ypositions (CrossPairs or AllPairs)\n   cutoff=0.1,\n   unitcell=[1,1,1],\n   xn_atoms_per_molecule=5\n   # or xn_atoms_per_molecule (CrossPairs)\n   # or xn_atoms_per_molecule *and* yn_atoms_per_molecule (AllPairs)\n)\n\nThis function computes directly the minimum distances in a set of particles.  Depending on the number of input position arrays provided and on the number of molecular index information provided, a different type of calculation is performed:\n\nIf xpositions and xn_atoms_per_molecule are provided, the minimum distances within the set of molecules of the set provided are computed. \nIf xpositions and ypositions are provided, and only xn_atoms_per_molecule is provided, the minimum distance of molecule of set x will be computed relative to set y (or, in other words, ypositions are considered a single structure) \nIf xpositions and ypositions are provided, and xn_atoms_per_molecule and yn_atoms_per_molecule are given, the minimum distances of each molecule of x to any atom of y are computed, and vice-versa. A tuple of vectors of minimum distances is returned, with lengths corresponding to the number of molecules of sets x and y, respectively.\n\nAs for the other functions are constructors, the xn_atoms_per_molecule keyword parameters can be substituted by a general function which returns the molecular  index of the molecule of each atom (i. e. (i) -> (i-1)%n_atoms_per_molecule + 1 in the simplest and default case).\n\nExamples\n\nSingle set of molecules: all minimum distances within the set\n\nNote that the output contains a vector of MinimumDistance elements with a length equal to the number of molecules of the set.\n\njulia> using MolSimToolkit, StaticArrays\n\njulia> list = minimum_distances(\n           xpositions = rand(SVector{3,Float64},10^5), \n           unitcell=[1,1,1], \n           cutoff = 0.1, \n           xn_atoms_per_molecule=10)\n10000-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 5, 71282, 0.007669490894775502)\n MinimumDistance{Float64}(true, 19, 36374, 0.005280726329888545)\n ⋮\n MinimumDistance{Float64}(true, 99998, 44320, 0.006509632622462869)\n\nTwo sets: minimum distances of one set relative to the other\n\nNote that the output contains the number of molecules of the x set. For each molecule of this set, the minimum distance to the set y is  computed. This is the typical \"solute-solvent\" example, where x contains the solvent positions, and y contains the solute positions.\n\njulia> list = minimum_distances(\n           xpositions = rand(SVector{3,Float64},10^5), \n           ypositions = rand(SVector{3,Float64},10^3),\n           unitcell=[1,1,1], \n           cutoff = 0.1, \n           xn_atoms_per_molecule=10,\n       )\n10000-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 5, 596, 0.025526453519907292)\n MinimumDistance{Float64}(true, 18, 391, 0.014114699969628301)\n ⋮\n MinimumDistance{Float64}(true, 99993, 289, 0.016089848937890512)\n\nTwo-sets: computing all minimum distances among molecules\n\nIf the number of molecules of both sets are provided with the xn_atoms_per_molecule and yn_atoms_per_molecule keywords, both sets are split into molecules, and all minimum distances are computed. For each molecule of each set,  the minimimum distance to any other molecule of the other set is returned. The output is a tuple of lists.\n\njulia> lists = minimum_distances(\n           xpositions = rand(SVector{3,Float64},10^5), \n           ypositions = rand(SVector{3,Float64},10^3),\n           unitcell=[1,1,1], \n           cutoff = 0.1, \n           xn_atoms_per_molecule=10,\n           yn_atoms_per_molecule=100\n       );\n\njulia> lists[1]\n10000-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 10, 471, 0.03211876310646438)\n MinimumDistance{Float64}(true, 13, 113, 0.0364141004391549)\n ⋮\n MinimumDistance{Float64}(true, 99992, 673, 0.0345818388567913)\n\njulia> lists[2]\n10-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 81, 754, 0.002292544732548094)\n MinimumDistance{Float64}(true, 156, 17208, 0.0018147268509811352)\n ⋮\n MinimumDistance{Float64}(true, 944, 98048, 0.002902338025311851)\n\n\n\n\n\n","category":"method"},{"location":"molecular_minimum_distances/#MolSimToolkit.MolecularMinimumDistances.within_cutoff-Tuple{MinimumDistance}","page":"Molecular Minimum Distances","title":"MolSimToolkit.MolecularMinimumDistances.within_cutoff","text":"within_cutoff(md::MinimumDistance) = md.within_cutoff\n\nReturns true if the distance is within the cutoff, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"molecular_minimum_distances/#PDBTools.distance-Tuple{MinimumDistance}","page":"Molecular Minimum Distances","title":"PDBTools.distance","text":"distance(md::MinimumDistance) = md.d\n\nReturns the distance between the atoms of the pair.\n\n\n\n\n\n","category":"method"},{"location":"molecular_minimum_distances/#MolSimToolkit.MolecularMinimumDistances.AllPairs-Union{Tuple{}, Tuple{F2}, Tuple{F1}} where {F1<:Union{Nothing, Function}, F2<:Union{Nothing, Function}}","page":"Molecular Minimum Distances","title":"MolSimToolkit.MolecularMinimumDistances.AllPairs","text":"AllPairs(;\n    xpositions::AbstractVector{<:AbstractVector{<:Real}},\n    ypositions::AbstractVector{<:AbstractVector{<:Real}},\n    cutoff::Real,\n    unitcell::AbstractVecOrMat,\n    xn_atoms_per_molecule::Integer,\n    yn_atoms_per_molecule::Integer,\n    parallel::Bool=true\n)\n\nInitializes a particle system for the calculation of minimum distances between one molecule and a set of other molecules. Returns a list  minimum distances (MinimumDistance type), containing for each molecule of the set the information about the closest distance to the reference molecule.\n\nInstead of the number of atoms per molecule, the user can also provide a  more general xmol_indices and/or ymol_indices functions,  which, for each atomic index, returns the corresponding molecular index (which is mol_indices(i) = (i-1)%n + 1 where n is the number of atoms per molecule if all molecules have the same number of atoms and are continously stored in the array of positions). \n\nExamples\n\njulia> using MolSimToolkit, StaticArrays\n\njulia> sys = AllPairs(\n           xpositions=rand(SVector{3,Float64},10^5), # \"solvent\" (set of molecules)\n           ypositions=rand(SVector{3,Float64},1000), # \"solute\" (target structure)\n           cutoff=0.1,\n           unitcell=[1,1,1],\n           xn_atoms_per_molecule=5, # of the \"solvent\"\n           yn_atoms_per_molecule=10 # of the \"solvent\"\n       )\nAllPairs system with:\n\nNumber of atoms of first set: 100000\nNumber of molecules in first set: 20000\n\nNumber of atoms of second set: 1000\nNumber of molecules in second set: 100\n\nCutoff: 0.1\nunitcell: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]\n\njulia> minimum_distances!(sys)[1]\n20000-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 1, 859, 0.037219109441123784)\n MinimumDistance{Float64}(true, 10, 117, 0.042183794688796634)\n ⋮\n MinimumDistance{Float64}(true, 99996, 168, 0.014269620784984633)\n\n\n\n\n\n","category":"method"},{"location":"molecular_minimum_distances/#MolSimToolkit.MolecularMinimumDistances.CrossPairs-Union{Tuple{}, Tuple{F1}} where F1<:Union{Nothing, Function}","page":"Molecular Minimum Distances","title":"MolSimToolkit.MolecularMinimumDistances.CrossPairs","text":"CrossPairs(;\n    xpositions::AbstractVector{<:AbstractVector{<:Real}},\n    ypositions::AbstractVector{<:AbstractVector{<:Real}},\n    cutoff::Real,\n    unitcell::AbstractVecOrMat,\n    xn_atoms_per_molecule::Integer,\n    parallel::Bool=true\n)\n\nInitializes a particle system for the calculation of minimum distances between one molecule and a set of other molecules. Returns a list  minimum distances (MinimumDistance type), containing for each molecule of the set the information about the closest distance to the reference molecule.\n\nInstead of the number of atoms per molecule, the user can also provide a  more general mol_indices function, which, for each atomic index, returns the  corresponding molecular index (which is mol_indices(i) = (i-1)%n + 1 where n is the number of atoms per molecule if all molecules have the same number of atoms and are continously stored in the array of positions). \n\nExamples\n\njulia> using MolSimToolkit, StaticArrays\n\njulia> sys = CrossPairs(\n           xpositions=rand(SVector{3,Float64},10^5), # \"solvent\" (set of molecules)\n           ypositions=rand(SVector{3,Float64},1000), # \"solute\" (target structure)\n           cutoff=0.1,\n           unitcell=[1,1,1],\n           xn_atoms_per_molecule=5 # of the \"solvent\"\n       )\nCrossPairs system with:\n\nNumber of atoms of set: 100000\nNumber of atoms of target structure: 1000\nCutoff: 0.1\nunitcell: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]\nNumber of molecules in set: 20000\n\njulia> minimum_distances!(sys)\n20000-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 1, 859, 0.037219109441123784)\n MinimumDistance{Float64}(true, 10, 117, 0.042183794688796634)\n ⋮\n MinimumDistance{Float64}(true, 99996, 168, 0.014269620784984633)\n\n\n\n\n\n","category":"method"},{"location":"molecular_minimum_distances/#MolSimToolkit.MolecularMinimumDistances.MinimumDistance","page":"Molecular Minimum Distances","title":"MolSimToolkit.MolecularMinimumDistances.MinimumDistance","text":"MinimumDistance{T}\n\nThe lists of minimum-distances are stored in arrays of type Vector{MinimumDistance{T}}. The index of this vector corresponds to the index of the molecule in the original array.\n\nMinimumDistance{T} is a simple structure that contains four fields: a boolean marker indicating if the distance is within the cutoff, the indices i and j of the atoms of the  molecules that are closer to each other, and the distance d, with type T, which is the same as that of the coordinates of the input vectors of coordinates. The best way to access the information of a MinimumDistance element is through the getter functions within_cutoff, distance, iatom, and jatom.\n\nExample\n\njulia> md = MinimumDistance{Float32}(true, 2, 5, 1.f0)\nMinimumDistance{Float32}(true, 2, 5, 1.0f0)\n\njulia> iatom(md)\n2\n\njulia> jatom(md)\n5\n\njulia> distance(md)\n1.0f0\n\njulia> within_cutoff(md)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"molecular_minimum_distances/#MolSimToolkit.MolecularMinimumDistances.SelfPairs-Union{Tuple{}, Tuple{F1}, Tuple{T}} where {T<:Real, F1<:Union{Nothing, Function}}","page":"Molecular Minimum Distances","title":"MolSimToolkit.MolecularMinimumDistances.SelfPairs","text":"SelfPairs(;\n    xpositions::AbstractVector{<:AbstractVector{<:Real}},\n    cutoff::Real,\n    unitcell::AbstractVecOrMat,\n    xn_atoms_per_molecule::Integer,\n    parallel::Bool=true\n) where T<:Real\n\nInitializes a particle system for the calculation of minimum distances within a single set of molecules. The shortest distance of each molecule to any other molecule of the same set is computed.\n\nInstead of the number of atoms per molecule, the user can also provide a  more general mol_indices function, which, for each atomic index, returns the  corresponding molecular index (which is mol_indices(i) = (i-1)%n + 1 where n is the number of atoms per molecule if all molecules have the same number of atoms and are continously stored in the array of positions). \n\nExamples\n\njulia> using MolSimToolkit, StaticArrays\n\njulia> sys = SelfPairs(\n           xpositions=rand(SVector{3,Float64},10^5),\n           cutoff=0.1,\n           unitcell=[1,1,1],\n           xn_atoms_per_molecule=5\n       )\nSelfPairs system with:\n\nNumber of atoms: 100000\nCutoff: 0.1\nunitcell: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]\nNumber of molecules: 20000\n\njulia> minimum_distances!(sys)\n20000-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 4, 24930, 0.008039482961077074)\n MinimumDistance{Float64}(true, 6, 74055, 0.0049818659155905255)\n ⋮\n MinimumDistance{Float64}(true, 99999, 75403, 0.0025051670801269433)\n\n\n\n\n\n","category":"method"},{"location":"molecular_minimum_distances/#Details-of-the-illustration","page":"Molecular Minimum Distances","title":"Details of the illustration","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The initial illustration here consists of a toy solute-solvent example, where the solute is an approximately hexagonal molecule, and the solvent is composed by 40 diatomic molecules. The toy system is built as follows:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"using MolecularMinimumDistances, StaticArrays\n# x will contain the \"solvent\", composed by 40 diatomic molecules\nT = SVector{2,Float64}\nx = T[]\ncmin = T(-20,-20)\nfor i in 1:40\n    v = cmin .+ 40*rand(T)\n    push!(x, v)\n    theta = 2pi*rand()\n    push!(x, v .+ T(sin(theta),cos(theta)))\nend\n# y will contain the \"solute\", composed by an approximate hexagonal molecule\ny = [ T(1,1), T(1,-1), T(0,-1.5), T(-1,-1), T(-1,1), T(0,1.5) ]","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Next, we compute the minimum distances between each molecule of x (the solvent) and the solute. In the input we need to specify the number of atoms of each molecule in x, and the cutoff up to which we want the distances to be computed:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> list = minimum_distances(\n           xpositions=x,\n           ypositions=y,\n           xn_atoms_per_molecule=2,\n           unitcell=[40.0, 40.0],\n           cutoff=10.0\n       )\n40-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 2, 3, 1.0764931248364737)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n ⋮\n MinimumDistance{Float64}(true, 74, 5, 7.899981412729262)\n MinimumDistance{Float64}(false, 0, 0, Inf)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The output is a list of MinimumDistance data structures, one for each molecule in x. The true indicates that a distance smaller than the cutoff was found, and for these the indices of the atoms in x and y associated are reported, along with the distance between them.","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"In this example, from the 40 molecules of x, eleven had atoms closer than the cutoff to some atom of y:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> count(x -> x.within_cutoff, list)\n11","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"We have an auxiliary function to plot the result, in this case where the \"atoms\" are bi-dimensional:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"using Plots\nimport MolecularMinimumDistances: plot_md!\np = plot(lims=(-20,20),framestyle=:box,grid=false,aspect_ratio=1)\nplot_md!(p, x, 2, y, 6, list, y_cycle=true)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"will produce the illustration plot above, in which the nearest point between the two sets is identified.","category":"page"},{"location":"secondary_structures/#Secondary-structures","page":"Secondary structure","title":"Secondary structures","text":"","category":"section"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"This package provides convenience functions to analyze the protein secondary structure along molecular dynamics simulations. ","category":"page"},{"location":"secondary_structures/#Secondary-structure-map","page":"Secondary structure","title":"Secondary structure map","text":"","category":"section"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"The secondary structure map is the profile of the secondary structure computed for  each frame of the trajectory. This computation may be costly, particularly with the  DSSP algorithm, so it is recommended to save the result. See Saving and loading a map for further information. ","category":"page"},{"location":"secondary_structures/#MolSimToolkit.ss_map","page":"Secondary structure","title":"MolSimToolkit.ss_map","text":"ss_map(\n    simulation::Simulation; \n    selection::Union{AbstractString,Function}=PDBTools.isprotein,\n    ss_method=stride_run,\n    show_progress=true\n)\n\nCalculates the secondary structure map of the trajectory.  Returns a matrix of secondary structure codes, where each row is a residue and each column is a frame.\n\nBy default, all protein atoms are considered. The selection keyword argument can be used to choose a different selection. The PDBTools selection syntax can be used, for example selection=\"protein and chain A\",  or general Julia functions, like selection=at -> chain(at) in ('A', 'B').\n\nThe ss_method keyword argument can be used to choose the secondary structure prediction method, which can be either stride_run or dssp_run. The default is stride_run. STRIDE is a faster algorithm, while DSSP is the default one in PDB database.\n\nThe show_progress keyword argument controls whether a progress bar is shown.\n\nFor the classes, refer to the ProteinSecondaryStructures.jl package documentation.\n\nExample\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> ssmap = ss_map(simulation; selection=\"residue >= 30 and residue <= 35\", show_progress=false)\n6×5 Matrix{Int64}:\n 5  9  5  5  5\n 5  9  5  5  5\n 5  1  5  5  5\n 5  1  5  5  5\n 5  1  5  5  5\n 9  9  9  9  9\n\njulia> ss_name.(ssmap)\n6×5 Matrix{String}:\n \"turn\"  \"coil\"       \"turn\"  \"turn\"  \"turn\"\n \"turn\"  \"coil\"       \"turn\"  \"turn\"  \"turn\"\n \"turn\"  \"310 helix\"  \"turn\"  \"turn\"  \"turn\"\n \"turn\"  \"310 helix\"  \"turn\"  \"turn\"  \"turn\"\n \"turn\"  \"310 helix\"  \"turn\"  \"turn\"  \"turn\"\n \"coil\"  \"coil\"       \"coil\"  \"coil\"  \"coil\"\n\n\n\n\n\n\n","category":"function"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"A complete example for computing a secondary structure map is shown below:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"julia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> ssmap = ss_map(simulation; selection=\"residue >= 30 and residue <= 35\", show_progress=false)\n6×5 Matrix{Int64}:\n 5  9  5  5  5\n 5  9  5  5  5\n 5  1  5  5  5\n 5  1  5  5  5\n 5  1  5  5  5\n 9  9  9  9  9\n","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"Here we have computed the secondary structure map for 6 residues of the structure, along the 5 frames of the trajectory. The resulting map is a matrix, where each code represents  a different class of secondary structure. The conversion between representations of  the classes can be done with these three functions of the ProteinSecondaryStructures.jl package, which are reexported here:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"ss_code: convert the representation to one-letter codes like H, B, C, etc.\nss_name: convert the representation to secondary structure names like Alpha-helix, Beta-bridge, etc.\nss_number: convert the representation to code numbers, like the ones used the matrix above. ","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"The list of classes and code associations of is available  here, in the ProteinSecondaryStructures.jl documentation.","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"For example, considering the secondary structure map matrix above, we can do:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"julia> ss_name.(ssmap)\n6×5 Matrix{String}:\n \"turn\"  \"coil\"       \"turn\"  \"turn\"  \"turn\"\n \"turn\"  \"coil\"       \"turn\"  \"turn\"  \"turn\"\n \"turn\"  \"310 helix\"  \"turn\"  \"turn\"  \"turn\"\n \"turn\"  \"310 helix\"  \"turn\"  \"turn\"  \"turn\"\n \"turn\"  \"310 helix\"  \"turn\"  \"turn\"  \"turn\"\n \"coil\"  \"coil\"       \"coil\"  \"coil\"  \"coil\"\n","category":"page"},{"location":"secondary_structures/#Calculation-methods:-STRIDE-and-DSSP","page":"Secondary structure","title":"Calculation methods: STRIDE and DSSP","text":"","category":"section"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"The STRIDE or DSSP methods can be used to compute the secondary structure. STRIDE is faster, and DSSP is the default method used in the Protein Data Bank. The method is chosen with the method keyword of ss_map:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"ssmap = ss_map(atoms, trajectory; method=stride_run)\nssmap = ss_map(atoms, trajectory; method=dssp_run)","category":"page"},{"location":"secondary_structures/#Plotting-the-map","page":"Secondary structure","title":"Plotting the map","text":"","category":"section"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"The ss_heatmap function provides a convenient tool to plot the secondary structure along the trajectory:","category":"page"},{"location":"secondary_structures/#MolSimToolkit.ss_heatmap","page":"Secondary structure","title":"MolSimToolkit.ss_heatmap","text":"ss_heatmap(ssmap::Matrix{<:Real}; scalex=1.0, kargs...)\n\nPlots a heatmap of the secondary structure map. \n\nnote: Note\nThis function requires loading the Plots package. The residue_ticks function   is available in the PDBTools` package.\n\nThe scalex keyword argument can be used to scale the x-axis, which usually has the meaning of time in a simulation. By default, it is 1.0 and the x-axis is the frame number.\n\nThe kargs keyword arguments are passed to the heatmap function of the Plots package, to modify properties of the plot. In particular: \n\nthe residue ticks can be set with yticks, and can be set to residue specific labels with the residue_ticks function of PDBTools.\nthe x-axis label can be set with xlabel to appropriate units, such as \"time / ns\", in combination with scalex. \n\nExample\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> using Plots, PDBTools\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> ssmap = ss_map(simulation; ss_method=stride_run, show_progress=false);\n\njulia> protein = select(atoms(simulation), \"protein\");\n\njulia> ss_heatmap(ssmap; scalex=0.1, xlabel=\"time / ns\", yticks=residue_ticks(prot; stride=5))\n\nWill plot a heatmap of the secondary structure map, with the x-axis scaled to 0.1, and residue ticks every 5 residues. The plot can be saved with the savefig function of the Plots package.\n\n\n\n\n\n","category":"function"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"note: Note\nThis function requires loading the Plots package, and residue_ticks is provided by PDBTools. ","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"For example:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"julia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> using Plots, PDBTools\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> ssmap = ss_map(simulation; ss_method=stride_run, show_progress=false);\n\njulia> protein = select(atoms(simulation), \"protein\");\n\njulia> ss_heatmap(ssmap; scalex=0.1, xlabel=\"time / ns\", yticks=residue_ticks(prot; stride=5))","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"The above code will produce the following plot, which can be saved with savefig(\"plot.svg\"):","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"(Image: heatmap1)","category":"page"},{"location":"secondary_structures/#Saving-and-loading-a-map","page":"Secondary structure","title":"Saving and loading a map","text":"","category":"section"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"The secondary structure map computed is just a matrix of integer codes. Thus, it can be saved or read in any preferred format. As a suggestion, it is possible to use writedlm and readdlm function from the DelimitedFiles package: ","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"using DelimitedFiles\n# save data to ssmap.dat\nwritedlm(\"ssmap.dat\", ssmap)\n# load data\nssmat = readdlm(\"ssmap.dat\", Int)","category":"page"},{"location":"secondary_structures/#Average-structure-of-each-class","page":"Secondary structure","title":"Average structure of each class","text":"","category":"section"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"From a precomputed secondary structure map the ss_mean helper functions will provide the content of a specific call of secondary structure along the simulation:","category":"page"},{"location":"secondary_structures/#MolSimToolkit.ss_mean","page":"Secondary structure","title":"MolSimToolkit.ss_mean","text":"ss_mean(ssmap::AbstractMatrix{<:Integer}; class, dims=nothing)\n\nCalculates the mean secondary structure class content of the trajectory, given the secondary structure map.\n\nThe secondary structure class to be considered must be defined by the class keyword argument.\n\nclass can be either a string, a character, or an integer, or a set of values, setting the class(es)  of secondary structure to be consdiered. For example, for alpha helix, use \"H\". It can also be a vector of classes,  such as class=[\"H\", \"E\"].\n\nThe mean can be calculated along the residues (default) or along the frames, by setting the dims keyword argument.\n\ndims=nothing (default) calculates the mean occurence of ss_class of the whole matrix.\ndims=1 calculates the mean occurence of ss_class along the frames, for each residue.\ndims=2 calculates the mean occurence of ss_class along the residues, for each frame.\n\nThe classes can be found in the ProteinSecondaryStructures.jl package documentation.\n\nExample\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> ssmap = ss_map(simulation; # 5 frames \n                   selection=\"residue >= 30 and residue <= 35\", # 6 residues\n                   show_progress=false\n               );\n\njulia> ss_mean(ssmap; class=\"C\")\n0.23333333333333334\n\njulia> ss_mean(ssmap; class=\"C\", dims=1) # mean coil content per residue\n5-element Vector{Float64}:\n 0.16666666666666666\n 0.5\n 0.16666666666666666\n 0.16666666666666666\n 0.16666666666666666 \n\njulia> ss_mean(ssmap; class=\"C\", dims=2) # mean coil content per frame\n6-element Vector{Float64}:\n 0.2\n 0.2\n 0.0\n 0.0\n 0.0\n 1.0\n\njulia> ss_mean(ssmap; class=[\"C\", \"T\"]) # mean coil or turn\n0.9\n\n\n\n\n\n\n","category":"function"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"For example, given the ssmap matrix of the examples above, compute the average content of alpha-helices with:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"julia> ss_mean(ssmap; class=\"H\")\n0.6093023255813953","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"The average content per frame is computed by averaging over the first dimension of the matrix (the residues):","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"julia> h = ss_mean(ssmap; class=\"H\", dims=1)\n5-element Vector{Float64}:\n 0.627906976744186\n 0.627906976744186\n 0.5813953488372093\n 0.6046511627906976\n 0.6046511627906976","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"Which can be plotted with:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"julia> plot(MolSimStyle, h, \n           xlabel=\"frame\", \n           ylabel=\"helical content\"\n       )","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"producing the time-dependence plot of the helical content:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"(Image: helical0)","category":"page"},{"location":"secondary_structures/#Average-structure-per-residue","page":"Secondary structure","title":"Average structure per residue","text":"","category":"section"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"And the average content per residue is obtained by averaging over the frames,  that is, the columns of the matrix:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"julia> h = ss_mean(ssmap; class=\"H\", dims=2)\n43-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n ⋮\n 1.0\n 0.4\n 0.0","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"This can be plotted, for example, with:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"julia> using Plots, PDBTools\n\njulia> ticks = residue_ticks(select(atoms(simulation), \"protein\"); stride=5)\n(1:5:41, [\"I211\", \"G216\", \"I221\", \"S226\", \"F231\", \"L236\", \"C241\", \"K246\", \"I251\"])\n\njulia> plot(MolSimStyle, h, \n           xlabel=\"residue\", xticks=ticks, xrotation=60,\n           ylabel=\"helical content\"\n       )","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"Which will generate the following figure:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"(Image: helical1)","category":"page"},{"location":"Structural_properties/#Structural-properties","page":"Distances and misc.","title":"Structural properties","text":"","category":"section"},{"location":"Structural_properties/#MolSimToolkitShared.distances-Tuple{Simulation, AbstractVector{<:Integer}, AbstractVector{<:Integer}}","page":"Distances and misc.","title":"MolSimToolkitShared.distances","text":"distances(simulation, indices1::AbstractVector{<:Integer}, indices2::AbstractVector{<:Integer})\ndistances(simulation, selection1::AbstractVector{<:PDBTools.Atom}, selection2::AbstractVector{<:PDBTools.Atom})\n\nFunction that calculates the distance between the centers of mass of two selections in a simulation.\n\nThe selections are defined by the indices1 and indices2 vectors, which are the indices of the atoms, or by the selection1 and selection2 vectors, which are vectors of PDBTools.Atom objects.\n\nUse silent=true to suppress the progress bar.\n\nExample\n\njulia> using PDBTools\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> sim = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> ats = atoms(sim);\n\njulia> i1 = findall(sel\"protein and residue 1\", ats); # indices\n\njulia> i2 = findall(sel\"protein and residue 15\", ats); # indices\n\njulia> distances(sim, i1, i2; silent=true)\n5-element Vector{Float64}:\n 23.433267858947584\n 30.13791365033211\n 28.48617683945202\n 27.92740141686934\n 23.235012287435566\n\njulia> distances(sim, \n           filter(sel\"protein and residue 1\", ats), # selection (PDBTools.Atom)\n           filter(sel\"protein and residue 15\", ats); # selection (PDBTools.Atom) \n           silent=true\n       )\n5-element Vector{Float64}:\n 23.433267858947584\n 30.13791365033211\n 28.48617683945202\n 27.92740141686934\n 23.235012287435566\n\n\n\n\n\n","category":"method"},{"location":"Structural_properties/#MolSimToolkitShared.center_of_mass-Tuple{AbstractVector{<:Integer}, Simulation, FramePositions}","page":"Distances and misc.","title":"MolSimToolkitShared.center_of_mass","text":"center_of_mass(\n    indices::AbstractVector{Int};\n    simulation::Simulation,\n    positions::FramePositions,\n    iref::Union{Nothing,Int} = max(1, div(length(indices),2)),\n)\n\nCalculate the center of mass of a selection of atoms in a simulation given the positions. The selection is defined by the indices vector, which is the indices of the atoms.\n\nThe iref parameter is the index of the reference atom. The center of mass is calculated by first computing the minimum-image of all atoms relative to this atom. By default, it is the atom closest to the middle of the indices vector. If iref is nothing, the center of mass is calculated without wrapping the coordinates.\n\njulia> using PDBTools \n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> protein_indices = findall(sel\"protein\", atoms(simulation));\n\njulia> first_frame!(simulation); # move simulation to the first frame\n\njulia> coor = positions(current_frame(simulation));\n\njulia> cm = center_of_mass(protein_indices, simulation, coor)\n3-element Point3D{Float64} with indices SOneTo(3):\n -3.7290442807974906\n -1.5339226637687564\n  1.960640754560446\n\ncompat: Compat\nThe iref=nothing option was added in version 1.22.0.\n\n\n\n\n\n","category":"method"},{"location":"Structural_properties/#MolSimToolkit.most_representative_structure-Tuple{Simulation}","page":"Distances and misc.","title":"MolSimToolkit.most_representative_structure","text":"most_representative_structure(simulation::Simulation; atoms = nothing)\n\nFind the most representative structure in a simulation.  The most representative structure is the one that minimizes the RMSD with respect to the average structure of the simulation.  The average structure is defined iteratively, first by aligning all frames to the first frame, and then by averaging the aligned structures. The structure most similar to the average is then identified and used as the reference structure for the next iteration. The process is repeated until the structure most similar to the average is the same as the previous iteration.\n\nArguments\n\nsimulation::Simulation: Simulation object.\natoms: Atoms to consider in the calculation:\natoms is nothing: the function will consider all alpha-carbons in proteins (\"protein and name CA\").\natoms is an AbstractVector{<:PDBTools.Atom}: the function will consider the atoms in the vector.\natoms is an AbstractVector{<:Int}: the function will consider the atoms with the indices in the vector.\natoms is a String: the function will consider the atoms selected by the string.\n\nReturns\n\nTuple (Int, Float64), with:\nIndex of the most representative structure.\nRMSD of the most representative structure with respect to the average structure.\n\nExample\n\njulia> using MolSimToolkit, MolSimToolkit.Testing, PDBTools\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> most_representative_structure(simulation) # atoms == nothing (all alpha-carbons in proteins)\n(4, 1.1681526249035976)\n\njulia> most_representative_structure(simulation; atoms = \"protein and name CA\") # atoms is a String\n(4, 1.1681526249035976)\n\njulia> calphas = select(atoms(simulation), \"name CA\");\n\njulia> most_representative_structure(simulation; atoms = calphas) # atoms is an Vector{PDBTools.Atom}\n(4, 1.1681526249035976)\n\njulia> ica = PDBTools.index.(calphas)\n\njulia> most_representative_structure(simulation; atoms = ica) # atoms is an vector of indices\n(4, 1.1681526249035976)\n\n\n\n\n\n","category":"method"},{"location":"Coaraci/#Coaraci","page":"Cluster submission management","title":"Cluster submission management","text":"","category":"section"},{"location":"Coaraci/","page":"Cluster submission management","title":"Cluster submission management","text":"warning: Warning\nThis is an experimental feature. Breaking changes may occur without  a breaking package release.","category":"page"},{"location":"Coaraci/","page":"Cluster submission management","title":"Cluster submission management","text":"The Coaraci module of MolSimToolkit manages the submission of multiple independent tasks in a single job of a cluster, where the job requested multiple nodes. For example, a job requests 20 nodes from a SLURM computer cluster, and the goal is to run independent simulations on each of the nodes. This script will distribute the simulations in the nodes and, when more nodes than simulations are available, release the spare nodes to the cluster.","category":"page"},{"location":"Coaraci/","page":"Cluster submission management","title":"Cluster submission management","text":"Currently fully supports the SLURM cluster manager. Partial support for PBS is available.","category":"page"},{"location":"Coaraci/","page":"Cluster submission management","title":"Cluster submission management","text":"compat: Compat\nThe Coaraci module was introduced in MolSimToolkit v1.20.0","category":"page"},{"location":"Coaraci/#SLURM/Gromacs-example","page":"Cluster submission management","title":"SLURM/Gromacs example","text":"","category":"section"},{"location":"Coaraci/#The-submission-script","page":"Cluster submission management","title":"The submission script","text":"","category":"section"},{"location":"Coaraci/","page":"Cluster submission management","title":"Cluster submission management","text":"Consider the following script to submit a job in a SLURM cluster. Here, we aim to run many (more than 20) independent simulations, and we request 20 nodes from the cluster. Each simulation will run in 48 cores inside each node.","category":"page"},{"location":"Coaraci/","page":"Cluster submission management","title":"Cluster submission management","text":"#!/bin/bash\n#SBATCH -n 48\n#SBATCH --job-name test\n#SBATCH --nodes 20\n#SBATCH --partition=paralela\n#SBATCH -o /home/users/test/proteina/job_files/out_tmao_replica13.txt\n#SBATCH -e /home/users/test/proteina/job_files/err_tmao_replica13.txt\n\ncd $SLURM_SUBMIT_DIR\n\n#### Run the Julia script\njulia simulations.jl","category":"page"},{"location":"Coaraci/#The-Julia-script","page":"Cluster submission management","title":"The Julia script","text":"","category":"section"},{"location":"Coaraci/","page":"Cluster submission management","title":"Cluster submission management","text":"Let us call this script simulations.jl, which is invoked by the submission script, as shown above.","category":"page"},{"location":"Coaraci/","page":"Cluster submission management","title":"Cluster submission management","text":"using MolSimToolkit: Coaraci\n\n# Define a structure that contains all the data required to run your simulations.\n# none of the fields is mandatory, but here they will be used.\n@kwdef struct SimulationData\n    title::String\n    dir::String\n    cosolvent::String\n    finish_file::String\nend\n\n#\n# MANDATORY: Define these 3 functions:\n#\n# Define `task_run`: which is the command that runs a single simulation, possibly using as arguments\n# the simulation data\nCoaraci.task_run(s::SimulationData) = \"/home/ander/run_script/run_single_simulation.sh $(s.dir) $(s.cosolvent)\"\n\n# Define a function `task_finished` that recognizes if a simulation was already run.\nCoaraci.task_finished(s::SimulationData) = isfile(joinpath(s.dir,s.finish_file))\n\n# Define a function `title` that sets the title of the run:\nCoaraci.task_title(s::SimulationData) = s.title\n\n# Simulation list: the following will create a list of simulations\n# that have to be executed. Each simulation is defined by a directory.\n# Here, we construct the directory names with the specifiers of each\n# simulation. Important: the result is a list of **full** directories\n# paths for each simulation.\nbase_dir=\"/home/users/test/protein\"\nconcentrations = [ \"0.1\" \"0.2\" ]\nreplicas = [ \"replica1\", \"replica2\" ]\n# This is the crucial part: build a proper list of simulation objects:\nsimulation_list = SimulationData[]\nfor conc in concentrations, rep in replicas\n    sim = SimulationData(\n        title=\"$conc/$rep\",\n        dir=joinpath(base_dir,conc,rep),\n        cosolvent=\"tmao\",\n        finish_file=\"production.gro\",\n    )\n    push!(simulation_list, sim)\nend\n\n# Execute the script that runs the simulations in parallel, one per node.\n# The name of the log file of the script is set here.\nCoaraci.simulate(\n    simulation_list; \n    logfile=\"mysimulations.log\",\n    #ntasks_per_node=1\n)","category":"page"},{"location":"Coaraci/","page":"Cluster submission management","title":"Cluster submission management","text":"The optional ntasks_per_node parameter can be set to define how many tasks are run per node.  In this case, for example, if ntasks_per_node=2, the script that runs each task inside the  node should request only half of the CPUs of the node, for maximal efficiency. By default, ntasks_per_node=1.  ","category":"page"},{"location":"Coaraci/#The-script-that-runs-a-simulation-inside-a-node","page":"Cluster submission management","title":"The script that runs a simulation inside a node","text":"","category":"section"},{"location":"Coaraci/","page":"Cluster submission management","title":"Cluster submission management","text":"The following script receives 2 arguments, which are provided by the definition of task_run, in the script above. At the end of all simulations, the production.gro file is generated, which  is then identified as the marker of a finished run. A finished run will not be run again.","category":"page"},{"location":"Coaraci/","page":"Cluster submission management","title":"Cluster submission management","text":"And, finally, the script that submit the actual simulations, from within the node, and using, here 48 cores (in a single node), is, for example:","category":"page"},{"location":"Coaraci/","page":"Cluster submission management","title":"Cluster submission management","text":"#!/bin/bash\nsimulation_dir=$1 # first argument of script\n\n# second argument of script: in this case, the cosolvent: can be used\n# to label or run specific analyzes for the same simulation\ncosolvent=$2\n\nn=48 # processors in this node\n\n#### modules necessary to run Gromacs #########\nmodule load hwloc\nmodule load gnu12\nmodule load openmpi4\nmodule load gcc-runtime/12.2.0-gcc-12.2.0-lbbfl34\nmodule load gcc-runtime/12.2.0-gcc-12.2.0-sqqkkcb\nmodule load gromacs/2023-gcc-12.2.0-zktp5lx\n\n# Important: go into simulation dir\ncd $simulation_dir\n\n# Run simulations: gromacs here\n/home/users/apereira/softwares/packmol-20.15.1/packmol < box.inp > box.log\ngmx_mpi grompp -f mim.mdp -c solvated.pdb -r solvated.pdb -p processed.top -o em.tpr -maxwarn 3 > /dev/null\nmpirun -np $n gmx_mpi mdrun -v -deffnm em -ntomp 1  > /dev/null #  -npme 12 -dd 4 3 3\n\ngmx_mpi grompp -f nvt.mdp -c em.gro -r em.gro -p processed.top -o nvt.tpr -maxwarn 3 > /dev/null\nmpirun -np $n gmx_mpi mdrun -v -deffnm nvt -ntomp 1 > /dev/null\n\ngmx_mpi grompp -f npt.mdp -c nvt.gro -r nvt.gro -p processed.top -o npt.tpr -maxwarn 3 > /dev/null\nmpirun -np $n gmx_mpi mdrun -v -deffnm npt -ntomp 1 > /dev/null\n\ngmx_mpi grompp -f prod.mdp -c npt.gro -r npt.gro -p processed.top -o prod.tpr -maxwarn 3 > /dev/null\nmpirun -np $n gmx_mpi mdrun -v -deffnm prod -ntomp 1 > /dev/null","category":"page"},{"location":"Coaraci/#PBS-example","page":"Cluster submission management","title":"PBS example","text":"","category":"section"},{"location":"Coaraci/","page":"Cluster submission management","title":"Cluster submission management","text":"The following script submits a job the parexp queue of a PBS cluster:","category":"page"},{"location":"Coaraci/","page":"Cluster submission management","title":"Cluster submission management","text":"#PBS -N meuteste\n#PBS -q parexp\n#PBS -l nodes=2:ppn=48\n#PBS -m abe\n#PBS -e erros\n#PBS -o saida\n\ncd $PBS_O_WORKDIR\njulia submission.jl","category":"page"},{"location":"Coaraci/","page":"Cluster submission management","title":"Cluster submission management","text":"Where submission.jl is the following script, which sets up two very simple tasks that just wait some delay seconds to finish:","category":"page"},{"location":"Coaraci/","page":"Cluster submission management","title":"Cluster submission management","text":"using MolSimToolkit: Coaraci\n@kwdef struct TestTask \n    title::String\n    delay::Int\n    output_file::String\nend\ndir=\"/home/lovelace/proj/proj864/user/test/\"\nCoaraci.task_finished(t::TestTask) = isfile(t.output_file)\nCoaraci.task_title(t::TestTask) = t.title\nCoaraci.task_run(t::TestTask) = \"$dir/run.sh $dir $(t.title) $(t.delay) $(t.output_file)\"\ntask_list = [ \n    TestTask(title=\"A\", delay=30, output_file=\"end1.txt\"), \n    TestTask(title=\"B\", delay= 2, output_file=\"end2.txt\"),\n]\nCoaraci.simulate(task_list; ntasks_per_node=1)","category":"page"},{"location":"Coaraci/","page":"Cluster submission management","title":"Cluster submission management","text":"and the run.sh script being executed is:","category":"page"},{"location":"Coaraci/","page":"Cluster submission management","title":"Cluster submission management","text":"#!/bin/bash\ncd $1 # running dir\nsleep $3 # delay\nhname=`hostname`\necho \"running! $2 in $hname\" > $4 # title and output_file name","category":"page"},{"location":"Coaraci/","page":"Cluster submission management","title":"Cluster submission management","text":"Note that the delay is passed as the third argument of the execution. The script will run a 30s  long task on the first node, and a 2s task on the second node. When the second task finishes, the second node is released. Note: PBS does not allow releasing the primary node, thus it will be kept even if no task is running on it.","category":"page"},{"location":"Coaraci/#Example-log-file","page":"Cluster submission management","title":"Example log file","text":"","category":"section"},{"location":"Coaraci/","page":"Cluster submission management","title":"Cluster submission management","text":"A typical log file will look like:","category":"page"},{"location":"Coaraci/","page":"Cluster submission management","title":"Cluster submission management","text":"=============================================================\nStarting Coaraci managed submissions: 2024-10-11 10:48:54\n=============================================================\nCluster type: MolSimToolkit.Coaraci.PBS\nJOB ID: 144830.ada\nNodes: adano62, adano72\nNumber of tasks per node: 1\n-------------------------------------------------------------\nNumber of tasks to run: 2\n-------------------------------------------------------------\n1: running A in node adano62 (1 in this node)\n2: running B in node adano72 (1 in this node)\n2: B in node adano72 finished successfully after 2 seconds, 507 milliseconds.\n> 1 nodes released. Keeping nodes: adano62\n1: A in node adano62 finished successfully after 30 seconds, 480 milliseconds.\n-------------------------------------------------------------\nfinished all tasks:\n - tasks finished successfully: 2\n - tasks finished with errors: 0\n=============================================================\nEnd Coaraci managed submissions: 2024-10-11 10:49:24\nTotal running time: 30 seconds, 762 milliseconds\n=============================================================","category":"page"},{"location":"structural_alignment/#Structural-alignment","page":"Structural alignment","title":"Structural alignment","text":"","category":"section"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"MolSimToolkit.jl provides tools to perform rigid-body structural alignment throughout  trajectories.","category":"page"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"Two types of alignments are avaialble: the \"standard\" rigid-body alignment, frequently used to compute RMSDs and RMSFs in MD trajectories, and a robust structural alignment method, mdlovofit. The robust alignment method provides better alignments of the rigid (or core) fractions of the structures, while magnifying the variability of the flexibile regions.","category":"page"},{"location":"structural_alignment/#Conventional-rigid-body-alignment","page":"Structural alignment","title":"Conventional rigid-body alignment","text":"","category":"section"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"Conventional rigid-body aligments routines are:","category":"page"},{"location":"structural_alignment/#MolSimToolkitShared.rmsd","page":"Structural alignment","title":"MolSimToolkitShared.rmsd","text":"rmsd(simulation::Simulation, indices::AbstractVector{<:Integer}; mass = nothing, reference_frame = nothing, show_progress = true)\n\nComputes the root mean square deviation (RMSD) between two sets of points in along a trajectory.\n\nArguments\n\nindices vector contains the indices of the atoms to be considered. \nmass argument can be used to provide the mass of the atoms if they are not the same.\nreference_frame argument can be used to provide a reference frame to align the trajectory to:\nIf reference_frame == nothing, the first frame will be used (default behavior).\nIf reference_frame == :average, the average structure will be used.\nIf reference_frame is an integer, the frame at that index will be used as reference.\n\nExamples\n\nComputing the rmsd along a trajectory\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> using PDBTools\n\njulia> atoms = readPDB(Testing.namd_pdb);\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> cas = findall(sel\"name CA\", atoms); # CA indices\n\njulia> rmsd(simulation, cas; show_progress=false)\n5-element Vector{Float64}:\n 0.0\n 2.8388710154609034\n 2.9776998440690385\n 2.4621444212469483\n 3.8035683196100796\n\njulia> rmsd(simulation, cas; reference_frame=:average, show_progress=false)\n5-element Vector{Float64}:\n 1.8995986972454748\n 2.1512244220536973\n 1.5081703191869376\n 1.1651111324544219\n 2.757039151265317\n\n\n\n\n\nrmsd(x::AbstractVector,y::AbstractVector)\n\nCalculate the root mean square deviation between two vectors of coordinates.\n\nArguments\n\nx::AbstractVector: A vector of coordinates.\ny::AbstractVector: A vector of coordinates.\n\nReturns\n\nrmsd::Real: The root mean square deviation between the two vectors.\n\njulia> import MolSimToolkitShared: rmsd\n\njulia> x = [ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ];\n\njulia> y = [ [2.0, 3.0, 4.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ];\n\njulia> rmsd(x, y)\n1.0\n\n\n\n\n\n","category":"function"},{"location":"structural_alignment/#MolSimToolkit.rmsd_matrix","page":"Structural alignment","title":"MolSimToolkit.rmsd_matrix","text":"rmsd_matrix(\n    simulation::Simulation, \n    indices::AbstractVector{<:Integer}; \n    mass::Union{AbstractVector{<:Integer}, Nothing} = nothing,\n    align::Bool = true,\n    show_progress = true,\n)\n\nComputes the RMSD matrix for a set of atoms along a trajectory.\n\nThe indices vector contains the indices of the atoms to be considered.  The mass argument can be used to provide the mass of the atoms if they are not the same. The align argument can be used to align the frames before computing the RMSD.\n\nThe show_progress argument can be used to show a progress bar.\n\nReturns\n\nA symetric matrix with the RMSD values between each pair of frames. For example, in  a trajectory with 5 frames, the matrix will be a 5x5 matrix with the RMSD values between the structures of each pair of frames.\n\nExample\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> using PDBTools\n\njulia> atoms = readPDB(Testing.namd_pdb);\n\njulia> cas = findall(Select(\"name CA\"), atoms); # CA indices\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> rmsd_matrix(simulation, cas; show_progress=false)\n5×5 Matrix{Float64}:\n 0.0      2.83887  2.9777   2.46214  3.80357\n 2.83887  0.0      2.35492  2.64463  4.68028\n 2.9777   2.35492  0.0      2.08246  3.46149\n 2.46214  2.64463  2.08246  0.0      2.97835\n 3.80357  4.68028  3.46149  2.97835  0.0\n\n\n\n\n\n","category":"function"},{"location":"structural_alignment/#MolSimToolkitShared.center_of_mass","page":"Structural alignment","title":"MolSimToolkitShared.center_of_mass","text":"center_of_mass(\n    indices::AbstractVector{Int};\n    simulation::Simulation,\n    positions::FramePositions,\n    iref::Union{Nothing,Int} = max(1, div(length(indices),2)),\n)\n\nCalculate the center of mass of a selection of atoms in a simulation given the positions. The selection is defined by the indices vector, which is the indices of the atoms.\n\nThe iref parameter is the index of the reference atom. The center of mass is calculated by first computing the minimum-image of all atoms relative to this atom. By default, it is the atom closest to the middle of the indices vector. If iref is nothing, the center of mass is calculated without wrapping the coordinates.\n\njulia> using PDBTools \n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> protein_indices = findall(sel\"protein\", atoms(simulation));\n\njulia> first_frame!(simulation); # move simulation to the first frame\n\njulia> coor = positions(current_frame(simulation));\n\njulia> cm = center_of_mass(protein_indices, simulation, coor)\n3-element Point3D{Float64} with indices SOneTo(3):\n -3.7290442807974906\n -1.5339226637687564\n  1.960640754560446\n\ncompat: Compat\nThe iref=nothing option was added in version 1.22.0.\n\n\n\n\n\ncenter_of_mass(x::AbstractVector{<:AbstractVector}[, mass::AbstractVector=nothing])\n\nCalculate the center of mass of a set of points.\n\nArguments\n\nx::AbstractVector{<:AbstractVector}: A vector of coordinates.\nmass::AbstractVector: A vector of masses. If not provided, all masses are assumed to be equal.\n\nExample\n\njulia> import MolSimToolkitShared: center_of_mass\n\njulia> x = [ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ];\n\njulia> center_of_mass(x)\n3-element Vector{Float64}:\n 4.0\n 5.0\n 6.0\n\njulia> center_of_mass(x, [1.0, 2.0, 3.0]) # providing masses\n3-element Vector{Float64}:\n 5.0\n 6.0\n 7.0\n\n\n\n\n\n\n","category":"function"},{"location":"structural_alignment/#MolSimToolkitShared.align","page":"Structural alignment","title":"MolSimToolkitShared.align","text":"align(x, y; mass = nothing)\nalign!(x, y; mass = nothing)\n\nAligns two structures (sets of points in 3D space). Solves the \"Procrustes\" problem, which is to find the best translation, and rotation, that aligns the two structures, minimizing the RMSD between them.\n\nStructures are expected to be of the same size, and the  correspondence is assumed from the vector indices. \n\nalign returns a new vector containing the coordinates of x aligned to y.  align! modifies the input vector x in place.\n\n\n\n\n\n","category":"function"},{"location":"structural_alignment/#MolSimToolkitShared.align!","page":"Structural alignment","title":"MolSimToolkitShared.align!","text":"align(x, y; mass = nothing)\nalign!(x, y; mass = nothing)\n\nAligns two structures (sets of points in 3D space). Solves the \"Procrustes\" problem, which is to find the best translation, and rotation, that aligns the two structures, minimizing the RMSD between them.\n\nStructures are expected to be of the same size, and the  correspondence is assumed from the vector indices. \n\nalign returns a new vector containing the coordinates of x aligned to y.  align! modifies the input vector x in place.\n\n\n\n\n\n","category":"function"},{"location":"structural_alignment/#Robust-rigid-body-alignment","page":"Structural alignment","title":"Robust rigid-body alignment","text":"","category":"section"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"MDLovoFit is a package for the analysis of the mobility and structural fluctuation in Molecular Dynamics simulations. It allows the automatic identification of rigid and mobile regions of protein structures.","category":"page"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"For example, it is possible to automatically identifiy a stable region of a protein in simulation in which the protein displays high structural flexibility, as illustrated in the example. The regions of low mobility are automatically detected by the method.","category":"page"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"The software provides, as output, the Root-Mean-Square Deviations of the conserved structures, and of the divergent structures. A trajectory PDB file is output for the visualization of the results. ","category":"page"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"The execution of the MDLovoFit procedure typically has three steps:","category":"page"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"Step1: Identify the length of the structure that can be aligned with a precision lower than a threshold. This is done with the map_fractions function.\nStep 2: Align the trajectory for the fraction of atoms desired, with the mdlovofit function.\nStep 3: Visualize the aligned trajectory and aligned atoms.","category":"page"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"note: Note\nPlease cite the following references if these functions were useful:L. Martínez, Automatic identification of mobile and rigid substructures in molecular dynamics simulations and fractional structural fluctuation analysis. PLoS One 10(3): e0119264, 2015.   Full text.L. Martínez. R. Andreani, J. M. Martínez. Convergent Algorithms for Protein Structural Alignment. BMC Bioinformatics, 8, 306, 2007. Full text.It is possible to use mdlovofit as a standalone program by downloading it here.","category":"page"},{"location":"structural_alignment/#mdlovofit1","page":"Structural alignment","title":"Step 1: Map fractions of aligned atoms and overlap precision","text":"","category":"section"},{"location":"structural_alignment/#MolSimToolkit.map_fractions","page":"Structural alignment","title":"MolSimToolkit.map_fractions","text":"map_fractions(simulation::Simulation; maxframes=nothing)\n\nRun MDLovoFit on a trajectory, to obtain the RMSD of the fractions of the structure with the lowest RMSD, the fraction with the highest RMSD, and the whole structure.\n\nOnly CA atoms of protein residues are considered. \n\nArgument:\n\nsimulation is a Simulation object, with the trajectory of the system and the atom data.\n\nKeyword arguments:\n\nmaxframes=nothing is the number of frames to be considered. If nothing, 100 frames are considered.   Set to length(simulation) to consider all frames. \n\nExample\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> sim = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> mf = map_fractions(sim)\n-------------------------------------------------------------------\nMapFractionsResult: Simulation(structure.pdb, trajectory.dcd)\n\n-------------------------------------------------------------------\nFields: \n- fraction: fraction of atoms considered in the alignment.\n- frame_indices: the frame index of each frame considered.\n- rmsd_low: RMSD of the fraction of the structure with the lowest RMSD.\n- rmsd_high: RMSD of the fraction not considered for the alignment.\n- rmsd_all: RMSD of the whole structure.\n\nGreatest fraction for which the RMSD-low is smaller than 1.0: 0.79\n                                                         2.0: 0.9\n                                                         3.0: 0.99\n-------------------------------------------------------------------\n\n\n\n\n\n","category":"function"},{"location":"structural_alignment/#MolSimToolkit.MapFractionsResult","page":"Structural alignment","title":"MolSimToolkit.MapFractionsResult","text":"MapFractionsResult\n\nData structure to store the output of the map_fractions function.\n\nFields:\n\nsimulation is a Simulation object with the trajectory of the system and the atom data.\nframe_indices contains the frame index of each frame considered.\nfraction contains the fraction of atoms considered in the alignment.\nrmsd_low contains the RMSD of the fraction of the structure with the lowest RMSD.\nrmsd_high contains the RMSD of the fraction not considered for the alignment.\nrmsd_all contains the RMSD of the whole structure.\n\n\n\n\n\n","category":"type"},{"location":"structural_alignment/#RecipesBase.plot-Tuple{MapFractionsResult}","page":"Structural alignment","title":"RecipesBase.plot","text":"plot(mf::MapFractionsResult; xlabel=\"fraction of aligned residues\", ylabel=\"RMSD\", kargs...)\n\nPlot the results of a map fractions calculation.\n\n\n\n\n\n","category":"method"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"The map_fractions function scans the trajectory and tries to align the Calpha atoms of the protein structures, but considering only a fraction of the atoms for the alignment. The alignment is performed such that only the fraction of atoms of smaller displacements interfere with the overlap. Three RMSDs are then obtained: the RMSD of the best aligned atoms, the RMSD of the remaining (highly mobile) atoms, and the RMSD of all atoms. For example:","category":"page"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"using MolSimToolkit, MolSimToolkit.Testing\n\n# Create Simulation object from pdb and trajectory file names\nsim = Simulation(Testing.namd_pdb, Testing.namd_traj)\n\n# Run map_fractions\nmf = map_fractions(sim)","category":"page"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"In the above run, we can readily see that 79% of the atoms of the structure can be aligned with RMSD smaller than 1.0Å. The RMSDs of the low and high mobility, and  all-Calpha RMSDs are available as the fields of the mf object generated. ","category":"page"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"A convenience recipe can plot the results:","category":"page"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"using Plots\nplot(mf)","category":"page"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"Where we see that about 80% of atoms can be aligned to less than 1.0Å RMSD, while at the same time the 20% more flexible atoms will display an RMSD of about 7Å.","category":"page"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"We will now consider that, in this case, 1.0Å is a good threshold for defining the  conserved structural core of the protein, and proceed with the next analysis, where we will ask mdlovofit to obtain the best alignment of 80% of the atoms, of each frame relative to the first frame.","category":"page"},{"location":"structural_alignment/#mdlovofit2","page":"Structural alignment","title":"Step 2: Align the trajectory for a given fraction of atoms","text":"","category":"section"},{"location":"structural_alignment/#MolSimToolkit.mdlovofit","page":"Structural alignment","title":"MolSimToolkit.mdlovofit","text":"mdlovofit(\n    simulation::Simulation; \n    fraction::AbstractFloat, \n    output_name::Union{String,Nothing} = nothing, \n    reference_frame::Int = 1, \n    maxframes=nothing\n)\n\nRun MDLovoFit on a trajectory, aligning only the atoms which are in the fraction of the structure with the lowest RMSD. Only CA atoms of protein residues are considered.\n\nArguments:\n\nsimulation is a Simulation object, with the trajectory of the system and the atom data.\nfraction is the fraction of atoms to be considered in the alignment.\n\nOptional arguments:\n\noutput_name=nothing is the base name of the output files. If nothing, default names will be used.\nreference_frame=1 is the index of the frame to be used as reference for the alignment.\nmaxframes=nothing is the number of frames to be considered. If nothing, 100 frames are considered.   Set to length(simulation) to consider all frames.\n\nOutput: \n\nMDLovoFitResult data structure with the results of the alignment.\n\nand the output files:\n\noutput_name_rmsf.dat with the RMSF data.\noutput_name_rmsd.dat with the RMSD data.\noutput_name_aligned.pdb with the aligned structure.\n\nExample\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> sim = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> md = mdlovofit(sim, fraction=0.7, output_name=\"mdlovofit_50\")\n-------------------------------------------------------------------\nMDLovoFitResult: Simulation(structure.pdb, trajectory.dcd)\n\n-------------------------------------------------------------------\n\nAligned pdb file: mdlovofit_50_aligned.pdb\nRMSF data file: mdlovofit_50_rmsf.dat\nRMSD data file: mdlovofit_50_rmsd.dat\n\nNumber of frames considered: 5\nAverage RMSD of all atoms: 1.79\nAverage RMSD of the 70.0% atoms of lowest RMSD: 0.53\nAverage RMSD of the 30.0% atoms of highest RMSD: 4.71\n\nFrame indices availabe in field: frame_indices\nRMSD data availabe in fields: rmsd_low, rmsd_high, and rmsd_all\n\nRMSF data availabe in field: rmsf (Number of atoms: 43)\n-------------------------------------------------------------------\n\n\n\n\n\n","category":"function"},{"location":"structural_alignment/#MolSimToolkit.MDLovoFitResult","page":"Structural alignment","title":"MolSimToolkit.MDLovoFitResult","text":"MDLovoFitResult\n\nData structure to store the output of the mdlovofit function.\n\nFields: \n\nsimulation: Simulation object with the trajectory of the system and the atom data. \nframe_indices: vector with the frame index of each frame.\nrmsd_low: RMSD of the fraction of the structure with the lowest RMSD.\nrmsd_high: RMSD of the fraction of the structure with the highest RMSD.\nrmsd_all: RMSD of the whole structure.\nrmsf: RMSF as a function of the residue or atom index. \nrmsf_file: name of the file with the RMSF data.\nrmsd_file: name of the file with the RMSD data.\naligned_pdb: name of the PDB file with the aligned structure.\n\n\n\n\n\n","category":"type"},{"location":"structural_alignment/#RecipesBase.plot-Tuple{MDLovoFitResult}","page":"Structural alignment","title":"RecipesBase.plot","text":"plot(md::MDLovoFitResult; \n    xlabel=[\"frame\"  \"residue\"], \n    ylabel=[\"RMSD / Å\" \"RMSF / Å\"], \n    yticks=[(0:1:maximum(md.rmsd_high),0:1:maximum(md.rmsd_high)) (0:1:maximum(md.rmsf),0:1:maximum(md.rmsf))], \n    ylims=[(0, maximum(md.rmsd_high)) (0, maximum(md.rmsf))], \n    stride=nothing, \n    kargs...\n)\n\nPlot the results of a MDLovoFit calculation. The stride argument can be used to control the number of xtick residues plotted in the RMSF plot.\n\n\n\n\n\n","category":"method"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"Continuing with the above example, now we will call the mdlovofit function, to obtain the best aligment of 80% of the atoms in each frame relative to the first frame:","category":"page"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"md = mdlovofit(sim; fraction=0.8, output_name=\"mysim\")","category":"page"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"We now see that we can, in average, align 80% of the atoms in all frames to 1.13Å.  The output RMSD and RMSF data is available in the md data structure, and additionally three files were generated, containing:","category":"page"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"mysim_aligned.pdb: a sequence of PDB files of the aligned trajectory.\nmysim_rmsd.dat: the RMSD data for low, high, and all atoms.\nmysim_rmsf.dat: the RMSF data for the atoms, resulting from the robust alignment.","category":"page"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"We can plot an overview of the results with:","category":"page"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"plot(md)","category":"page"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"And we can see that, in this short (5-frame) trajectory, the N-terminal region of the  protein is the one responsible for the structural deviations, while there is a  rigid structural core between residues I221 and K249.","category":"page"},{"location":"structural_alignment/#mdlovofit3","page":"Structural alignment","title":"Step 3: Visualization of the aligned trajectory","text":"","category":"section"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"The PDB file created by mdlovofit contains the frames aligned to the reference frame, according to the robust alignment based on the least mobile substructure (determined by fraction). The file contains multiple models, separated by the END keyword.","category":"page"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"The occupancy field of the atoms determines if the atom was used in the aligment, thus if it was found among the least mobile atoms of the simulation. The beta field contains the RMSF of the atom, in each frame. ","category":"page"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"Using, for example, VMD, it is possible to display all frames at once, colored by occupancy, providing an overview of the mobility of the structure:","category":"page"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"(Image: mdlovofit.png)","category":"page"},{"location":"structural_alignment/","page":"Structural alignment","title":"Structural alignment","text":"This structural superposition and the associated colors are correlatd with the  RMSF plot above. Red atoms were not used for the aligment and display high mobility, and blue atoms represent the stable core of the structure and were aligned.","category":"page"},{"location":"#MolSimToolkit.jl","page":"Home","title":"MolSimToolkit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MolSimToolkit.jl provides a set of tools to  analyse molecular dynamics simulations, and a framework for the development of custom analysis tools.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(\"MolSimToolkit\")","category":"page"},{"location":"#Using","page":"Home","title":"Using","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using MolSimToolkit","category":"page"},{"location":"#Recommended","page":"Home","title":"Recommended","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Also install PDBTools:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(\"PDBTools\")\nimport PDBTools","category":"page"}]
}
