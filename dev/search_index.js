var documenterSearchIndex = {"docs":
[{"location":"block_averages/#Block-averages","page":"Block averages","title":"Block averages","text":"","category":"section"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"Performs an analysis of the convergence of some property (usually the mean) in a time-series. ","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"Computes the block average of time-dependent data, to compute the standard error of the mean and, to detect sampling problems. A didactical explanation of block averaging is available here.  ","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"The package also outputs the autocorrelation function of the property, and the characteristic time of the correlation decay. ","category":"page"},{"location":"block_averages/#Data-that-is-not-time-correlated","page":"Block averages","title":"Data that is not time-correlated","text":"","category":"section"},{"location":"block_averages/#Compute-the-average-of-a-random-variable-x:","page":"Block averages","title":"Compute the average of a random variable x:","text":"","category":"section"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"julia> using MolSimToolkit \n\njulia> x = rand(10_000);\n\njulia> b = block_average(x)\n-------------------------------------------------------------------\nBlockAverageData{Float64}\n-------------------------------------------------------------------\nEstimated value (mean by default) = 0.4977014924716461\nLength of data series: 10000\n\nBlock size ranges: (1, 10000)\n\nMaximum standard error (error, block size): (0.005790454921861948, 5000)\n\nDeviations in last 3 blocks:\n         percentual: [2.8893559885598195, -1.1634393325014705, 0.0]  \n           absolute: [0.014380367877881106, -0.005790454921861976, 0.0]  \n\nAutocorrelation is first zero with lag: 2\nCharacteristic time of autocorrelation decay: \n        as fraction of series length: 2.0182708552030272e-5\n                            absolute: 0.2018270855203027\n-------------------------------------------------------------------\n\njulia> using Plots\n\njulia> plot(b, title=\"Uncorrelated data\")","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"Results in:","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"(Image: random.png)","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"Thus, the worst block estimate converges very rapidly to the true mean, the standard error of the mean is very small, and the autocorrelation decays very quickly. Since the data is not correlated along the series, the characteristic time may not be meaningful. ","category":"page"},{"location":"block_averages/#Data-that-is-time-correlated","page":"Block averages","title":"Data that is time-correlated","text":"","category":"section"},{"location":"block_averages/#Poorly-sampled-data","page":"Block averages","title":"Poorly-sampled data","text":"","category":"section"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"The data above is not correlated in the input x vector. If the data is correlated, one can observe that in the dependence of the estimates of the average and error from the data. One can generate a test data (sort of a monte-carlo simulation of a particle in an harmonic well) using:","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"julia> x = BlockAverages.test_data(1_000);","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"Which in this run produced:","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"julia> plot(x; xlabel=\"time\", ylabel=\"value\", label=nothing)","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"(Image: bad_sampling.png)","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"The error of the estimate of the mean is, now, dependent on the block size, and we cannot see any convergence of the error, indicating that the sampling is not enough to obtain a reliable estimate of the mean value of x:  ","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"julia> b = block_average(x, lags=1:500)\n-------------------------------------------------------------------\nBlockAverageData{Float64}\n-------------------------------------------------------------------\nEstimated value (mean by default) = -0.5616539552467762\nLength of data series: 1000\n\nBlock size ranges: (1, 1000)\n\nMaximum standard error (error, block size): (0.24081057091463817, 500)\n\nDeviations in last 3 blocks:\n         percentual: [80.94415878065803, 42.87525595877488, -0.0]  \n           absolute: [-0.4546260693327965, -0.2408105709146382, 0.0]  \n\nAutocorrelation is first zero with lag: 194\nCharacteristic time of autocorrelation decay: \n        as fraction of series length: 0.06981859583876429\n                            absolute: 69.8185958387643\n-------------------------------------------------------------------","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"Note that we have adjusted the range of lags of the autocorrelation function in this case.","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"Several characteristics of the output indicate the poor convergence of the series: 1) The mean should be 0. for this property; 2) the maximum standard error occurs with a block size which is half the length of the series (there is no plateau); 3) the standard error of the mean is of the order of the mean value; 4) The autocorrelation is first zero at ~20% of the length of the data set. ","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"The corresponding plot is obtained with:","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"julia> using Plots\n\njulia> plot(b, title=\"Bad sampling\")","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"(Image: bad_sampling_result.png)","category":"page"},{"location":"block_averages/#Properly-sampled-data","page":"Block averages","title":"Properly sampled data","text":"","category":"section"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"If we increase the sampling by generating longer simulation:","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"julia> x = BlockAverages.test_data(10^6);","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"The obtained set is now much better sampled,","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"(Image: good_sampling.png)","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"The convergence analysis of the series produces:","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"julia> b = block_average(x, lags=1:100:10^5, max_block_size=10^5)\n-------------------------------------------------------------------\nBlockAverageData{Float64}\n-------------------------------------------------------------------\nEstimated value (mean by default) = -0.05498853009368246\nLength of data series: 1000000\n\nBlock sizes: [1, 2, ..., 62500, 100000]\n\nMaximum standard error (error, block size): (0.18706372724807982, 31250)\n\nDeviations in last 3 blocks:\n         percentual: [-2805.4693758538297, -2600.14341058853, -1393.4253407524507]  \n           absolute: [1.5426863720104287, 1.4297806418103753, 0.7662241128326587]  \n\nAutocorrelation is first zero with lag: 14701\nCharacteristic time of autocorrelation decay: \n        as fraction of series length: 0.0036203287638847167\n                            absolute: 3620.328763884717\n-------------------------------------------------------------------","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"Note that the average value of x here is closer to zero, and that the maximum standard error of the mean is consistent the true value being around zero. The correlation decays fast relative to the length of the data series.","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"The corresponding plots are:","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"julia> using Plots\n\njulia> plot(b, title=\"Good sampling\")","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"(Image: good_sampling_result.png)","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"The plateau of standard errors (second plot) in intermediate values of block sizes is typical of a properly sampled data set, and can be used as an the uncertainty in the property estimate. ","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"For example, for an ever better sampled data, there is a very clear plateau of standard errors, which are smaller than those of the above example:","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"julia> x = BlockAverages.test_data(10^7)\n\njulia> b = block_average(x, max_block_size=10^5, lags=1:100:10^5);\n\njulia> plot(b)","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"(Image: best_sampling.png)","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"(here we have computed the statistics only up to blocks of size 10^5)","category":"page"},{"location":"block_averages/#Visualizing-the-distribution-of-the-mean","page":"Block averages","title":"Visualizing the distribution of the mean","text":"","category":"section"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"Once the overall correlation is understood from the time-series block analysis, one can  visualize the distribution of the computed value (the mean in general) for a given block size. A relatively good fit to a gaussian distribution is expected. For instance, let us choose a block size of 25_000, from a set similar to the one above:","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"julia> using MolSimToolkit, Plots\n\njulia> x = BlockAverages.test_data(10^7) \n\njulia> d = block_distribution(x; block_size = 25_000)\n-------------------------------------------------------------------\nMeanDistribution{400}\n-------------------------------------------------------------------\nNumber of blocks: 400\nEstimated value: = 0.06462623778329132\nStandard error of the mean: 0.05641314321229929\nStandard deviation of the mean: 1.1282628642459858\n> block_mean contains the mean computed for each block.\n-------------------------------------------------------------------\n\njulia> histogram(d)","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"The last command will produce a plot similar to the following, in which the histogram of values is shown side by side with the gaussian function that corresponds to the  observed standard deviation and mean.","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"(Image: best_sampling.png)","category":"page"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"The optimal block size should be that for which the distribution is closer to a gaussian.","category":"page"},{"location":"block_averages/#Reference-functions","page":"Block averages","title":"Reference functions","text":"","category":"section"},{"location":"block_averages/","page":"Block averages","title":"Block averages","text":"Modules = [MolSimToolkit.BlockAverages]\nPages = [\"BlockAverages.jl\"]\nOrder = [:function, :type]","category":"page"},{"location":"block_averages/#MolSimToolkit.BlockAverages.block_average-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Real","page":"Block averages","title":"MolSimToolkit.BlockAverages.block_average","text":"block_average(\n    x::AbstractVector{T};\n    by = mean,\n    min_block_size::Int = 1,\n    max_block_size::Int = length(x),\n    lags::Union{Nothing,AbstractVector{Int}} = nothing,\n) where {T<:Real}\n\nThis function peforms some convergence analysis for a property computed from a series of data, typically a time-series.  The data is given in vector x, and by defines the property to be estimated, typically, and by default, the mean value.\n\nTwo analyses are performed: a block averaging, in which the data is split in to blocks, and the mean value (or by value) in each block is computed idependently. The output will contain the worst estimate obtained for all blocks, and the standard error of the estimates, as a function of the block size. \n\nFinally, the autocorrelation function of the data is computed, and a single exponential is fitted, to obtain the characteristic time of the decay of the correlation. \n\nThe output will be a structure of type BlockAverageData{T}. See the corresponding help entry for more information.\n\nAll results can be plot with a convenience function BlockAverage.plot\n\nThe lags keyword can be tuned to define the range of intervals and length of the autocorrelation calculation, with important implications to the exponential fit and correlation curve shape. See the StatsBase.autocor help for  further information.\n\nExample\n\njulia> using MolSimToolkit\n\njulia> x = BlockAverages.test_data(10^6); # example data generator\n\njulia> b = block_average(x, lags=0:100:10^5)\n-------------------------------------------------------------------\nBlockAverageData{Float64}\n-------------------------------------------------------------------\nEstimated value (mean by default) = -0.13673023261452855\nLength of data series: 1000000\n\nBlock sizes: [1, 2, ..., 500000, 1000000]\n\nMaximum standard error (error, block size): (0.23264202379194165, 500000)\n\nDeviations in last 3 blocks:\n         percentual: [-349.5348293165444, -170.1467329817311, -0.0]  \n           absolute: [0.47791978519330647, 0.23264202379194168, 0.0]  \n\nAutocorrelation is first zero with lag: 16400\nCharacteristic time of autocorrelation decay: \n        as fraction of series length: 0.0037856443348888848\n                            absolute: 3785.6443348888847\n-------------------------------------------------------------------\n\njulia> using Plots\n\njulia> plot(b) # creates a plot with the results\n\n\n\n\n\n\n","category":"method"},{"location":"block_averages/#MolSimToolkit.BlockAverages.block_distribution-Tuple{Function, AbstractVector, Int64}","page":"Block averages","title":"MolSimToolkit.BlockAverages.block_distribution","text":"block_distribution(x_input::AbstractVector; block_size::Int) = \n    block_distribution(mean, x_input, block_size::Int)\nblock_distribution(by::Function, x_input::AbstractVector, block_size::Int)\n\nGiven the data and the block size, computes the distribution of estimates of the  properties for each block. Returns a BlockDistribution{NBLOCKS} object. The block size must be an integer.\n\nExample\n\njulia> using MolSimToolkit\n\njulia> x = BlockAverages.test_data(10^7);\n\njulia> d = block_distribution(x; block_size = 25*10^3)\n-------------------------------------------------------------------\nBlockDistribution{400}\n-------------------------------------------------------------------\nNumber of blocks: 400\nEstimated value: = 0.025151622077551537\nStandard error of the mean: 0.05596145099711976\nStandard deviation of the mean: 1.119229019942395\n> block_mean contains the mean computed for each block.\n-------------------------------------------------------------------\n\nThe distribution is stored in the d.block_mean vector, and can be plotted with:\n\njulia> using Plots\n\njulia> histogram(d)\n\n\n\n\n\n","category":"method"},{"location":"block_averages/#MolSimToolkit.BlockAverages.BlockAverageData","page":"Block averages","title":"MolSimToolkit.BlockAverages.BlockAverageData","text":"struct BlockAverageData{T}\n\nStructure that contains the result of the block-average analysis of the sequence. \n\nx is the original data set. \n\nxmean is the property value computed for all data (usually the mean, but not necessarily)\n\nblocksize is an array of block sizes, in which the data was split.  By default it goes from 1 to length(x), with a number of points corresponding to the number of integer divisions of length(x).\n\nxmean_maxerr: The property is computed for each block, and the maximum error (difference between the property in the block and the average property) is stored in this array, for each blocks size. \n\nxmean_stderr: The standard error of the estimates of the property, meaning the standar  deviation of the estimates divided by the square root of the number of blocks. \n\nautocor: Is the autocorrelation function of the data, as a function of the lag. \n\nlags: Is the set of \"time\" lags for which the autocorrelation will be computed. Defined by the lags parameter of the block_average function, as a range. \n\ntau: The characteristic decay time of the autocorrelation function, as obtained by fitting of a single exponential, of the form exp(-t/tau) to the data. \n\n\n\n\n\n","category":"type"},{"location":"block_averages/#MolSimToolkit.BlockAverages.BlockDistribution","page":"Block averages","title":"MolSimToolkit.BlockAverages.BlockDistribution","text":"struct BlockDistribution{N}\n\nmean::Float64\nstd_of_the_mean::Float64\nblock_mean::Vector{Float64}\nstd_err_of_the_mean::Float64\n\n\n\n\n\n","category":"type"},{"location":"plotting_style/#Plotting-style","page":"Plotting style","title":"Plotting style","text":"","category":"section"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"This package provides a simple type to overload the default plotting styles of Plots, such figures that are prettier (in our oppinion) are produced. To use the style, add MolSimStyle as the first argument of the plotting functions. ","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"In brief, use the Plots plotting functions with, for example:","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"plot(MolSimStyle, x, y, xlabel = \"my x\")\n\nhistogram(MolSimStyle, x)\n\ncontourf(MolSimStyle, M, xlabel = \"my x\", ylabel = \"my z\")","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"by adding the first argument to the available plotting functions. ","category":"page"},{"location":"plotting_style/#Without-the-style","page":"Plotting style","title":"Without the style","text":"","category":"section"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"For example, without the style:","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"julia> using MolSimToolkit, Plots\n\njulia> x = sort(rand(10)); y = sort(rand(10));\n\njulia> plot(x,y)","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"produces:","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"(Image: )","category":"page"},{"location":"plotting_style/#With-the-style","page":"Plotting style","title":"With the style","text":"","category":"section"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"Now, with the style, we get:","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"julia> plot(MolSimStyle, x, y)","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"(Image: )","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"All other normal parameters of Plots function can be used to change the plot labels, titles, legends, font sizes, etc.","category":"page"},{"location":"plotting_style/#Available-plotting-functions","page":"Plotting style","title":"Available plotting functions","text":"","category":"section"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"The Plots functions that are overloaded are:","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"Plots.plot\nPlots.plot!\nPlots.scatter\nPlots.scatter!\nPlots.histogram\nPlots.histogram!\nPlots.contour\nPlots.contour!\nPlots.contourf\nPlots.contourf!\nPlots.annotate!","category":"page"},{"location":"plotting_style/#The-annotate!-function","page":"Plotting style","title":"The annotate! function","text":"","category":"section"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"The annotate! function is special, because the overload does not have the  same level of flexibilty of the standard Plots.annotate! function. Here, it is used with","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"julia> using MolSimToolkit, Plots\n\njulia> x = sort(rand(10)); y = sort(rand(10));\n\njulia> plot(MolSimStyle, x, y)\n\njulia> annotate!(MolSimStyle, 0.7, 0.3, \"My note!\"; fontsize = 12)","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"where 7.0 and 3.0 are the coordinates. This will produce:","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"(Image: )","category":"page"},{"location":"plotting_style/","page":"Plotting style","title":"Plotting style","text":"warning: Warning\nThese styles and methods can be changed without introducing breaking changes in the package version. ","category":"page"},{"location":"miscelaneous/#Miscelaneous-functions","page":"Miscelaneous functions","title":"Miscelaneous functions","text":"","category":"section"},{"location":"miscelaneous/","page":"Miscelaneous functions","title":"Miscelaneous functions","text":"CollapsedDocStrings = true","category":"page"},{"location":"miscelaneous/","page":"Miscelaneous functions","title":"Miscelaneous functions","text":"Modules = [ MolSimToolkit ]\nPages = [ \n    \"bulk_coordination.jl\",\n    \"intermittent_correlation.jl\",\n    \"distances.jl\", \n    \"center_of_mass.jl\",\n    \"most_representative_structure.jl\",\n]","category":"page"},{"location":"miscelaneous/#MolSimToolkit.bulk_coordination-Tuple{Simulation}","page":"Miscelaneous functions","title":"MolSimToolkit.bulk_coordination","text":"bulk_coordination(\n    simulation::Simulation;\n    reference_solute::AbstractVector{PDBTools.Atom}, \n    solute::AbstractVector{PDBTools.Atom},\n    n_atoms_per_molecule_solute::Int,\n    solvent::AbstractVector{PDBTools.Atom}, \n    n_atoms_per_molecule_solvent::Int,\n    dmax::Real = 5.0,\n    cutoff::Real = 20.0,\n    bin_size::Real = 0.1,\n    show_progress = true,\n)\n\nComputes the coordination number of one type of solvent molecule relative to another  solvent molecule, as a function of the distance to a reference solute molecule. \n\nFor example, imagine a protein solvated in a mixture of water and TMAO. This function allows to compute the number of water molecules that are within a given distance to the TMAO molecules, as a function of the distance to the protein. That is, it computes the coordination number of water relative to TMAO, as a function of the distance to the protein.\n\nThe function returns the the distances and the histogram of the coordination number as a function of  the distance.\n\ncompat: Compat\nThis function was introduced in version 1.11.0 of MolSimToolkit.jl.\n\nArguments\n\nsimulation::Simulation: The simulation object\nreference_solute::AbstractVector{PDBTools.Atom}: The atoms of the reference solute molecule  (the protein in the example above).\nsolute::AbstractVector{PDBTools.Atom}: The atoms of the solute molecule (the TMAO in the example above).\nn_atoms_per_molecule_solute::Int: The number of atoms per molecule of the solute.\nsolvent::AbstractVector{PDBTools.Atom}: The atoms of the solvent molecule (the water in the example above).\nn_atoms_per_molecule_solvent::Int: The number of atoms per molecule of the solvent.\ndmax::Real = 5.0: The maximum distance to the solute to consider a solvent molecule as coordinated.\ncutoff::Real = 20.0: The maximum distance to the reference molecule for computing the histogram.\nbin_size::Real = 0.1: The size of the bins for the histogram.\nshow_progress = true: Whether to show a progress bar.\n\nExample\n\njulia> using MolSimToolkit, PDBTools\n\njulia> pdb = readPDB(MolSimToolkit.Testing.namd2_pdb); # protein-tmao-water system\n\njulia> trajectory = MolSimToolkit.Testing.namd2_traj;\n\njulia> simulation = Simulation(pdb, trajectory)\nSimulation \n    Atom type: Atom\n    PDB file: -\n    Trajectory file: /home/leandro/.julia/dev/MolSimToolkit/test/data/namd/protein_in_water_tmao/trajectory.dcd\n    Total number of frames: 20\n    Frame range: 1:1:20\n    Number of frames in range: 20\n    Current frame: nothing\n\njulia> r, h = bulk_coordination(\n           simulation;\n           reference_solute = select(pdb, \"protein\"),\n           solute = select(pdb, \"resname TMAO\"),\n           n_atoms_per_molecule_solute = 14,\n           solvent = select(pdb, \"water\"),\n           n_atoms_per_molecule_solvent = 3,\n       );\n\njulia> using Plots\n\njulia> plot(r, h, # plots `h` as a function of `r`\n           xlabel = \"Distance to protein (Å)\",\n           ylabel = \"TMAO-water Coordination number\",\n           linewidth=2,\n           label=:none, framestyle=:box, fontfamily=\"Computer Modern\",\n       )\n\n\n\n\n\n","category":"method"},{"location":"miscelaneous/#MolSimToolkit.intermittent_correlation-Union{Tuple{AbstractVector}, Tuple{F}} where F<:Function","page":"Miscelaneous functions","title":"MolSimToolkit.intermittent_correlation","text":"intermittent_correlation(\n    data::AbstractVector; \n    maxdelta = length(data) ÷ 10, \n    types::Function = x -> true,\n)\n\nCalculate the intermittent correlation function of a time series. That is, computes the probability of finding a value of the same type at a step i + delta in the time series, given that it was present in step i.\n\nReturns an OffsetArray with indices 0:maxdelta, where the value at position 0 is 1.0, corresponding to the normalized count of events. \n\nArguments\n\ndata::AbstractVector: The time series to be analyzed. \nmaxdelta::Int: The maximum delta-step to be considered. Defaults to  length(data) ÷ 10.\ntypes (optional): A function that returns true for the types of data  that should be considered. Defaults to all data, i. e. x -> true. For   example, to ignore 0 values, use types = x -> x != 0.  \n\nExamples\n\nHere we produce a time-series of 10,000 elements, as a sequence of  1's and 0's ([1, 0, 1, 0, ...]), and calculate the intermittent correlation function. The probability of finding the same number (0 or 1) after odd steps is 0, and the probability of finding the same number after even steps is 1.\n\njulia> using MolSimToolkit\n\njulia> data = [ mod(i,2) for i in 1:10^4 ];\n\njulia> intermittent_correlation(data; maxdelta=4)\n5-element OffsetArray(::Vector{Float64}, 0:4) with eltype Float64 with indices 0:4:\n 1.0\n 0.0\n 1.0\n 0.0\n 1.0\n\njulia> intermittent_correlation(data; maxdelta=4, types = x -> x != 0)\n5-element OffsetArray(::Vector{Float64}, 0:4) with eltype Float64 with indices 0:4:\n 1.0\n 0.0\n 1.0\n 0.0\n 1.0\n\nIn the second run, we have ignored the 0 values, and the result is the same,  because here the correlations of the 1 values are the same as the correlations of the 0 values.\n\ncompat: Compat\nThis function was added in version 1.9.0 of MolSimToolkit. The types argument was added in version 1.10.0.\n\n\n\n\n\n","category":"method"},{"location":"miscelaneous/#MolSimToolkit.distances-Tuple{Simulation, AbstractVector{Int64}, AbstractVector{Int64}}","page":"Miscelaneous functions","title":"MolSimToolkit.distances","text":"distances(simulation, indices1::AbstractVector{Int}, indices2::AbstractVector{Int})\ndistances(simulation, selection1::AbstractVector{PDBTools.Atom}, selection2::AbstractVector{PDBTools.Atom})\n\nFunction that calculates the distance between the centers of mass of two selections in a simulation.\n\nThe selections are defined by the indices1 and indices2 vectors, which are the indices of the atoms, or by the selection1 and selection2 vectors, which are vectors of PDBTools.Atom objects.\n\nUse silent=true to suppress the progress bar.\n\nExample\n\njulia> using PDBTools\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> sim = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> ats = atoms(sim);\n\njulia> i1 = findall(sel\"protein and residue 1\", ats); # indices\n\njulia> i2 = findall(sel\"protein and residue 15\", ats); # indices\n\njulia> distances(sim, i1, i2; silent=true)\n5-element Vector{Float64}:\n 23.433267858947584\n 30.13791365033211\n 28.48617683945202\n 27.92740141686934\n 23.235012287435566\n\njulia> distances(sim, \n           filter(sel\"protein and residue 1\", ats), # selection (PDBTools.Atom)\n           filter(sel\"protein and residue 15\", ats); # selection (PDBTools.Atom) \n           silent=true\n       )\n5-element Vector{Float64}:\n 23.433267858947584\n 30.13791365033211\n 28.48617683945202\n 27.92740141686934\n 23.235012287435566\n\n\n\n\n\n","category":"method"},{"location":"miscelaneous/#PDBTools.center_of_mass-Tuple{AbstractVector{Int64}, Simulation, FramePositions}","page":"Miscelaneous functions","title":"PDBTools.center_of_mass","text":"center_of_mass(\n    indices::AbstractVector{Int};\n    simulation::Simulation,\n    positions::FramePositions,\n    iref::Int = max(1, div(length(indices),2)),\n)\n\nCalculate the center of mass of a selection of atoms in a simulation given the positions. The selection is defined by the indices vector, which is the indices of the atoms.\n\nThe iref parameter is the index of the reference atom. The center of mass is calculated by first computing the minimum-image of all atoms relative to this atom. By default, it is the atom closest to the middle of the indices vector.\n\njulia> using PDBTools \n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> protein_indices = findall(sel\"protein\", atoms(simulation));\n\njulia> first_frame!(simulation); # move simulation to the first frame\n\njulia> coor = positions(current_frame(simulation));\n\njulia> cm = center_of_mass(protein_indices, simulation, coor)\n3-element Point3D{Float64} with indices SOneTo(3):\n -3.7290442807974906\n -1.5339226637687564\n  1.960640754560446\n\n\n\n\n\n","category":"method"},{"location":"miscelaneous/#MolSimToolkit.most_representative_structure-Tuple{Simulation}","page":"Miscelaneous functions","title":"MolSimToolkit.most_representative_structure","text":"most_representative_structure(simulation::Simulation; atoms = nothing)\n\nFind the most representative structure in a simulation.  The most representative structure is the one that minimizes the RMSD with respect to the average structure of the simulation.  The average structure is defined iteratively, first by aligning all frames to the first frame, and then by averaging the aligned structures. The structure most similar to the average is then identified and used as the reference structure for the next iteration. The process is repeated until the structure most similar to the average is the same as the previous iteration.\n\nArguments\n\nsimulation::Simulation: Simulation object.\natoms: Atoms to consider in the calculation:\natoms is nothing: the function will consider all alpha-carbons in proteins (\"protein and name CA\").\natoms is an AbstractVector{<:PDBTools.Atom}: the function will consider the atoms in the vector.\natoms is an AbstractVector{<:Int}: the function will consider the atoms with the indices in the vector.\natoms is a String: the function will consider the atoms selected by the string.\n\nReturns\n\nTuple (Int, Float64), with:\nIndex of the most representative structure.\nRMSD of the most representative structure with respect to the average structure.\n\nExample\n\njulia> using MolSimToolkit, MolSimToolkit.Testing, PDBTools\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> most_representative_structure(simulation) # atoms == nothing (all alpha-carbons in proteins)\n(4, 1.1681526249035976)\n\njulia> most_representative_structure(simulation; atoms = \"protein and name CA\") # atoms is a String\n(4, 1.1681526249035976)\n\njulia> calphas = select(atoms(simulation), \"name CA\");\n\njulia> most_representative_structure(simulation; atoms = calphas) # atoms is an AbstractVector{PDBTools.Atom}\n(4, 1.1681526249035976)\n\njulia> ica = PDBTools.index.(calphas)\n\njulia> most_representative_structure(simulation; atoms = ica) # atoms is an vector of indices\n(4, 1.1681526249035976)\n\n\n\n\n\n","category":"method"},{"location":"procrustes/#Structural-alignment","page":"Structural alignment","title":"Structural alignment","text":"","category":"section"},{"location":"procrustes/","page":"Structural alignment","title":"Structural alignment","text":"Some functions to compute the RMSD and perform rigid-body structural alignments:","category":"page"},{"location":"procrustes/","page":"Structural alignment","title":"Structural alignment","text":"CollapsedDocStrings = true","category":"page"},{"location":"procrustes/","page":"Structural alignment","title":"Structural alignment","text":"Modules = [ MolSimToolkit ]\nPages = [ \"procrustes.jl\" ]","category":"page"},{"location":"procrustes/#MolSimToolkit.align","page":"Structural alignment","title":"MolSimToolkit.align","text":"align(x, y; mass = nothing)\nalign!(x, y; mass = nothing)\n\nAligns two structures (sets of points in 3D space). Solves the \"Procrustes\" problem, which is to find the best translation, and rotation, that aligns the two structures, minimizing the RMSD between them.\n\nStructures are expected to be of the same size, and the  correspondence is assumed from the vector indices. \n\nalign returns a new vector containing the coordinates of x aligned to y.  align! modifies the input vector x in place.\n\n\n\n\n\n","category":"function"},{"location":"procrustes/#MolSimToolkit.align!","page":"Structural alignment","title":"MolSimToolkit.align!","text":"align(x, y; mass = nothing)\nalign!(x, y; mass = nothing)\n\nAligns two structures (sets of points in 3D space). Solves the \"Procrustes\" problem, which is to find the best translation, and rotation, that aligns the two structures, minimizing the RMSD between them.\n\nStructures are expected to be of the same size, and the  correspondence is assumed from the vector indices. \n\nalign returns a new vector containing the coordinates of x aligned to y.  align! modifies the input vector x in place.\n\n\n\n\n\n","category":"function"},{"location":"procrustes/#MolSimToolkit.rmsd-Tuple{AbstractVector, AbstractVector}","page":"Structural alignment","title":"MolSimToolkit.rmsd","text":"rmsd(x::AbstractVector,y::AbstractVector)\nrmsd(simulation::Simulation, indices::AbstractVector{Int}; mass = nothing, reference_frame = nothing, show_progress = true)\n\nComputes the root mean square deviation (RMSD) between two sets of points in  space, or along a trajectory.\n\nThe rmsd(x,y) method computes the RMSD between two sets of points x and y.  The sets are expected to be of the same size, and the correspondence is assumed from the vector indices.\n\nThe rmsd(simulation::Simulation, indices) method computes the RMSD along a trajectory. With the  following options: \n\nThe indices vector contains the indices of the atoms to be considered. \nThe mass argument can be used to provide the mass of the atoms if they are not the same.\nThe reference_frame argument can be used to provide a reference frame to align the trajectory to:\nIf reference_frame == nothing, the first frame will be used (default behavior).\nIf reference_frame == :average, the average structure will be used.\nIf reference_frame is an integer, the frame at that index will be used as reference.\n\nExamples\n\nIf the set is compared toi tself, the RMSD should be zero:\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> using PDBTools\n\njulia> ca = coor(readPDB(Testing.namd_pdb), \"name CA\");\n\njulia> rmsd(ca, ca)\n0.0\n\nComputing the rmsd along a trajectory\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> using PDBTools\n\njulia> atoms = readPDB(Testing.namd_pdb);\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> cas = findall(sel\"name CA\", atoms); # CA indices\n\njulia> rmsd(simulation, cas; show_progress=false)\n5-element Vector{Float64}:\n 0.0\n 2.8388710154609034\n 2.9776998440690385\n 2.4621444212469483\n 3.8035683196100796\n\njulia> rmsd(simulation, cas; reference_frame=:average, show_progress=false)\n5-element Vector{Float64}:\n 1.8995986972454748\n 2.1512244220536973\n 1.5081703191869376\n 1.1651111324544219\n 2.757039151265317\n\n\n\n\n\n","category":"method"},{"location":"procrustes/#MolSimToolkit.rmsd_matrix-Tuple{Simulation, AbstractVector{Int64}}","page":"Structural alignment","title":"MolSimToolkit.rmsd_matrix","text":"rmsd_matrix(\n    simulation::Simulation, \n    indices::AbstractVector{Int}; \n    mass::Union{AbstractVector{Int}, Nothing} = nothing,\n    align::Bool = true,\n    show_progress = true,\n)\n\nComputes the RMSD matrix for a set of atoms along a trajectory.\n\nThe indices vector contains the indices of the atoms to be considered.  The mass argument can be used to provide the mass of the atoms if they are not the same. The align argument can be used to align the frames before computing the RMSD.\n\nThe show_progress argument can be used to show a progress bar.\n\nExample\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> using PDBTools\n\njulia> atoms = readPDB(Testing.namd_pdb);\n\njulia> cas = findall(Select(\"name CA\"), atoms); # CA indices\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> rmsd_matrix(simulation, cas; show_progress=false)\n5×5 Matrix{Float64}:\n 0.0      2.83887  2.9777   2.46214  3.80357\n 2.83887  0.0      2.35492  2.64463  4.68028\n 2.9777   2.35492  0.0      2.08246  3.46149\n 2.46214  2.64463  2.08246  0.0      2.97835\n 3.80357  4.68028  3.46149  2.97835  0.0\n\n\n\n\n\n","category":"method"},{"location":"Experimental/#Experimental-features","page":"Experimental","title":"Experimental features","text":"","category":"section"},{"location":"Experimental/","page":"Experimental","title":"Experimental","text":"The features in this section are experimental, meaning that they are under active development, with possible early bugs and unstable interfaces. The semantic version of the package is not compromised to the changes of these features. ","category":"page"},{"location":"Experimental/","page":"Experimental","title":"Experimental","text":"Simulation reweighting","category":"page"},{"location":"system_setup/#System-setup","page":"System setup","title":"System setup","text":"","category":"section"},{"location":"system_setup/#Packmol-Input-Creator","page":"System setup","title":"Packmol Input Creator","text":"","category":"section"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"This module helps the setup of a Packmol input file, by computing the number of molecules and sizes necessary to build different systems. Currently (as of version 1.3.3) the module supports the construction of systems of a solute solvated by a mixture of two solvents. ","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"compat: Compat\nThe functionality described here is available in MolSimToolkit version 1.3.3 or greater.","category":"page"},{"location":"system_setup/#How-to-use-it","page":"System setup","title":"How to use it","text":"","category":"section"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"julia> using MolSimToolkit.PackmolInputCreator","category":"page"},{"location":"system_setup/#Setting-up-the-system-properties","page":"System setup","title":"Setting up the system properties","text":"","category":"section"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"Here, we setup a system of a polymer solvated by water and ethanol. The densities as  a function of the molar fraction of ethanol are available in a data table:","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"density_table = [\n# x cossolvent (ethanol)     density (g/mL)\n         0.0000                 0.9981\n         0.0416                 0.9820\n         0.0890                 0.9685\n         0.1434                 0.9537\n         0.2066                 0.9369\n         0.2809                 0.9151\n         0.3695                 0.8923\n         0.4769                 0.8685\n         0.6098                 0.8450\n         0.7786                 0.8195\n         1.0000                 0.7906\n]","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"Next, we initialize the system data structure, given the PDB files of one molecule of the polymer (poly_h.pdb), and one molecule of water and ethanol:","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"# Directory of test files\ntest_dir = MolSimToolkit.PackmolInputCreator.PackmolInputCreatorDirectory*\"/test\"\n# Construction of system data structure\nsystem = SolutionBoxUSC(\n    solute_pdbfile = \"$test_dir/data/poly_h.pdb\",\n    solvent_pdbfile = \"$test_dir/data/water.pdb\",\n    cossolvent_pdbfile = \"$test_dir/data/ethanol.pdb\",\n    density_table = density_table,\n    concentration_units = \"x\", # molar fraction\n    solute_molar_mass = nothing, # optional\n    solvent_molar_mass = nothing, # optional\n    cossolvent_molar_mass = nothing, # optional\n)","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"Here, SolutionBoxUSC stands for Solute (U), Solvent (S), and Cossolvent (C).   The concentration units can be one of \"mol/L\" (molarity), \"x\" (molar fraction), \"vv\" (volume fraction), and \"mm\" (mass fraction). The density is assumed to be in g/mL. ","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"The molar masses of the components can be provided explicitly by the user. If not, they will be computed from the atom types in the PDB files, but this may fail if the mass of some atom type is unknown.","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"compat: Compat\nManual setting of molar masses was introduced in version 1.13.0","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"tip: Tip\nThe density table can be converted among different units with the function convert_density_table!, which acts on the SystemBox object. For example:julia> convert_density_table!(system, \"mol/L\")","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"Finally, we can generate an input file for Packmol with:","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"write_packmol_input(\n    system; \n    concentration = 0.5,\n    margin = 20.0, \n    input = \"box.inp\",\n    output = \"system.pdb\"\n)","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"The concentration can be given in molar fraction (x), molarity (mol/L), or volume fraction (vv). ","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"The input parameter provides the name of the input file for Packmol that will be generated. ","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"The margin parameter sets the size of the box, which will take into consideration the maximum and minimum dimensions of the solute. Alternatively, the size of the box can be provided explicitly with the box_sides = [ a, b, c ] parameters, where a, b, and c are the lengths of the box in each dimension. ","category":"page"},{"location":"system_setup/#Running-Packmol","page":"System setup","title":"Running Packmol","text":"","category":"section"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"Packmol can be run directly from within Julia using the Packmol Julia package:","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"using Packmol\nrun_packmol(\"./box.inp\")","category":"page"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"If everything runs correctly, the output file system.pdb will be generated.","category":"page"},{"location":"system_setup/#Help-entries","page":"System setup","title":"Help entries","text":"","category":"section"},{"location":"system_setup/","page":"System setup","title":"System setup","text":"Modules = [MolSimToolkit.PackmolInputCreator]\nOrder = [:function, :type]","category":"page"},{"location":"system_setup/#MolSimToolkit.PackmolInputCreator.convert_concentration-Tuple{MolSimToolkit.PackmolInputCreator.SolutionBoxUSC, Real, Pair{String, String}}","page":"System setup","title":"MolSimToolkit.PackmolInputCreator.convert_concentration","text":"convert_concentration(\n    system::SolutionBoxUSC,\n    input_concentration, \n    units\n)\n\nConvert concentration from one unit to another. The input concentration is given in input_concentration, and the unit conversion  is given by units keyword, that can be one of the following pairs:\n\nThe supported concentration units are:\n\n\"mol/L\": molarity\n\"x\": molar fraction\n\"vv\": volume fraction\n\"mm\": mass fraction\n\nConversion among types consists in passing the units keyword argument, which is a pair of the form \"from\" => \"to\", where \"from\" and \"to\" are one of the supported units.\n\nExample\n\nFor example, to convert from molarity to molar fraction, use:\n\nconvert_concentration(system, 55.5, \"mol/L\" => \"x\")\n\nwhere system is a SolutionBoxUSC object, and 55.5 is the molarity.\n\n\n\n\n\n","category":"method"},{"location":"system_setup/#MolSimToolkit.PackmolInputCreator.convert_density_table!-Tuple{MolSimToolkit.PackmolInputCreator.SolutionBoxUSC, String}","page":"System setup","title":"MolSimToolkit.PackmolInputCreator.convert_density_table!","text":"convert_density_table!(system::SolutionBoxUSC, target_units)\n\nConverts the density table of the system from one unit to another. Returns the  input system with the density table converted to the new units.\n\nThe target units may be one of: \"mol/L\", \"x\", \"vv\", \"mm\".\n\nExample\n\nconvert_density_table!(system, \"mol/L\")\n\n\n\n\n\n","category":"method"},{"location":"system_setup/#MolSimToolkit.PackmolInputCreator.write_packmol_input-Tuple{MolSimToolkit.PackmolInputCreator.SolutionBoxUSC}","page":"System setup","title":"MolSimToolkit.PackmolInputCreator.write_packmol_input","text":"write_packmol_input(\n    system::SolutionBoxUSC;\n    concentration::Real, \n    input=\"box.inp\",\n    output=\"system.pdb\",\n    # box size\n    box_sides::AbstractVector{<:Real}, # or\n    margin::Real\n)\n\nFunction that generates an input file for Packmol. \n\nThe box sides are given in Ångströms, and can be provided as a vector of 3 elements. Alternativelly, the margin can be provided, and the box sides will be calculated as the maximum and minimum coordinates of the solute plus the margin in all 3 dimensions.\n\n\n\n\n\n","category":"method"},{"location":"system_setup/#MolSimToolkit.PackmolInputCreator.SolutionBoxUSC-Tuple{}","page":"System setup","title":"MolSimToolkit.PackmolInputCreator.SolutionBoxUSC","text":"SolutionBoxUSC(; \n    solute_pdbfile::String, \n    solvent_pdbfile::String,\n    cossolvent_pdbfile::String,\n    density_table::Matrix{Float64},\n    concentration_units = \"x\",\n    solute_molar_mass = nothing, # optional\n    solvent_molar_mass = nothing, # optional\n    cossolvent_molar_mass = nothing, # optional\n)\n\nSetup a system composed of a solute (U) a solvent (S) and a cossolvent (C). \n\nThe concentration units of the density table can be provided explicitly and are assumed by default to be the molar fraction, x, of the cossolvent.\n\nThe molar massses of the solute, solvent, and cossolvent can be provided manually. If not, they will be computed from the atom types in the PDB file.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#Developer-zone","page":"Developer zone","title":"Developer zone","text":"","category":"section"},{"location":"Developer/","page":"Developer zone","title":"Developer zone","text":"CollapsedDocStrings = true","category":"page"},{"location":"Developer/#Simulation","page":"Developer zone","title":"Simulation","text":"","category":"section"},{"location":"Developer/","page":"Developer zone","title":"Developer zone","text":"Modules = [ MolSimToolkit ]\nPages = [ \"datastructures/Simulation.jl\" ]\nFilter = (f) -> !(nameof(f) === :unitcell)","category":"page"},{"location":"Developer/#MolSimToolkit.Simulation","page":"Developer zone","title":"MolSimToolkit.Simulation","text":"Simulation(pdb_file::String, trajectory_file::String; first=1, last=nothing, step=1)\nSimulation(atoms::AbstractVector{<:AtomType}, trajectory_file::String; first=1, last=nothing, step=1)\n\nCreates a new Simulation object. \n\nThe first constructor creates a Simulation object from a PDB file and a trajectory file. It will use the PDBTools.Atom for the atom type, which will populate the atoms vector of the Simulation object.\n\nWith the second constructor, the atoms vector is passed as an argument. This is useful when the atoms are provided by a different source than the PDB file. If the AtomType of the atoms vector conforms the AtomsBase interface, most functions in the MolSimToolkit will work with the Simulation object.\n\nIf first, last, and step are not specified, the Simulation will iterate over all frames in the file. \n\nA Simulation object contains a trajectory file and a PDB data of the atoms. It can be iterated over to obtain the frames in the trajectory. The Simulation object is a mutable struct that contains the following data, that can be retrived by the corresponding functions:\n\nframe_range(::Simulation): the range of frames to be iterated over\nframe_index(::Simulation): the index of the current frame in the trajectory\nlength(::Simulation): the number of frames to be iterated over in the trajectory file, considering the current range\nraw_length(::Simulation): the number of frames in the trajectory file\natoms(::Simulation): the atoms in the simulation\n\nThe Simulation object can also be manipulated by the following functions:\n\nclose(::Simulation): closes the trajectory file\nrestart!(::Simulation): restarts the iteration over the trajectory file\nfirst_frame!(::Simulation): restarts the iteration over the trajectory file and places the current frame at the first frame in the trajectory\ncurrent_frame(::Simulation): returns the current frame in the trajectory\nnext_frame!(::Simulation): reads the next frame in the trajectory file and returns it. Moves the current frame to the next one.\nset_frame_range!(::Simulation; first, last, step): resets the range of frames to be iterated over. \nget_frame(::Simulation, iframe): returns the frame at the given index in the trajectory.\n\nOne important feature of the Simulation object is that it can be iterated over, frame by frame. \n\nThe pairs iterator can also be used to iterate over the frames, returning a tuple with the frame index and the frame itself. \n\nThe enumerate iterator can also be used to iterate over the frames, returning a tuple with the frame counter and the frame itself.\n\nExamples\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> simulation = Simulation(\n           Testing.namd_pdb, Testing.namd_traj; \n           first = 2, step = 2, last = 4\n       );\n\njulia> for frame in simulation \n           @show frame_index(simulation)\n           # show x coordinate of first atom \n           @show positions(frame)[1].x\n       end\nframe_index(simulation) = 2\n((positions(frame))[1]).x = 5.912472724914551\nframe_index(simulation) = 4\n((positions(frame))[1]).x = 7.346549034118652\n\njulia> for (i, frame) in pairs(simulation)\n           @show i, frame_index(simulation)\n       end\n(i, frame_index(simulation)) = (2, 2)\n(i, frame_index(simulation)) = (4, 4)  \n\njulia> for (i, frame) in enumerate(simulation)\n           @show i, frame_index(simulation)\n       end\n(i, frame_index(simulation)) = (1, 2)\n(i, frame_index(simulation)) = (2, 4)\n\n\n\n\n\n\n","category":"type"},{"location":"Developer/#Base.close-Tuple{Simulation}","page":"Developer zone","title":"Base.close","text":"close(simulation::Simulation)\n\nCloses the trajectory file.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#Base.length-Tuple{Simulation}","page":"Developer zone","title":"Base.length","text":"length(simulation::Simulation)\n\nReturns the number of frames to be iterated over in the trajectory file, considering the current frame range.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.atoms-Tuple{Simulation}","page":"Developer zone","title":"MolSimToolkit.atoms","text":"atoms(simulation::Simulation)\n\nReturns the atoms in the simulation.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.current_frame-Tuple{Simulation}","page":"Developer zone","title":"MolSimToolkit.current_frame","text":"current_frame(simulation::Simulation)\n\nReturns the current frame in the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.first_frame!-Tuple{Simulation}","page":"Developer zone","title":"MolSimToolkit.first_frame!","text":"first_frame!(simulation::Simulation)\n\nRestarts the trajectory buffer, and places the current frame at the first frame in the trajectory.\n\nExample\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> first_frame!(simulation) \nSimulation \n    Atom type: Atom\n    PDB file: structure.pdb\n    Trajectory file: structure.dcd\n    Total number of frames: 5\n    Frame range: 1:1:5\n    Number of frames in range: 5\n    Current frame: 1\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.frame_index-Tuple{Simulation}","page":"Developer zone","title":"MolSimToolkit.frame_index","text":"frame_index(simulation::Simulation)\n\nReturns the index of the current frame in the trajectory. Returns nothing  if no frame frame from the trajectory range has been read yet.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.frame_range-Tuple{Simulation}","page":"Developer zone","title":"MolSimToolkit.frame_range","text":"frame_range(simulation::Simulation)\n\nReturns the range of frames to be iterated over.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.get_frame-Tuple{Simulation, Int64}","page":"Developer zone","title":"MolSimToolkit.get_frame","text":"get_frame(simulation::Simulation, iframe::Int)\n\nReturns the frame at the given index in the trajectory. \n\nExample\n\njulia> using MolSimToolkit, MolSimToolkit.Testing, PDBTools\n\njulia> sim = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> frame4 = get_frame(sim, 4)\n   Array{Atoms,1} with 20465 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     ILE     P      211        1   -0.397   12.048   37.441  1.00  0.00     1    PROT         1\n       2  HT1     ILE     P      211        1   -0.779   11.123   37.726  1.00  0.00     1    PROT         2\n       3  HT2     ILE     P      211        1   -0.393   12.662   38.280  1.00  0.00     1    PROT         3\n                                                       ⋮ \n   20463  SOD     SOD     S       13     4374  -11.686   23.749   19.935  1.00  0.00     1     SOD     20463\n   20464  SOD     SOD     S       14     4375  -34.214   38.148   55.179  1.00  0.00     1     SOD     20464\n   20465  SOD     SOD     S       15     4376    7.220  -52.702   66.223  1.00  0.00     1     SOD     20465\n\njulia> writePDB(frame4, \"frame4.pdb\")\n\nnote: Note\nThe get_frame function will read the frames in the trajectory until the desired frame is reached.  This can be slow for large trajectories. If the required frame is before the current frame of the  simulation, the simulation will be restarted. The simulation object is returned positioned in the required frame. \n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.next_frame!-Tuple{Simulation}","page":"Developer zone","title":"MolSimToolkit.next_frame!","text":"next_frame!(simulation::Simulation)\n\nReads the next frame in the trajectory file and returns it. Moves the current frame to the next one in the range to be considered (given by frame_range(simulation)).\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.path_pdb-Tuple{Simulation}","page":"Developer zone","title":"MolSimToolkit.path_pdb","text":"path_pdb(simulation::Simulation)\n\nReturns the path to the pdb file of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.path_trajectory-Tuple{Simulation}","page":"Developer zone","title":"MolSimToolkit.path_trajectory","text":"path_trajectory(simulation::Simulation)\n\nReturns the path to the trajectory file of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.raw_length-Tuple{Simulation}","page":"Developer zone","title":"MolSimToolkit.raw_length","text":"raw_length(simulation::Simulation)\n\nReturns the number of frames in the trajectory file.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.restart!-Tuple{Simulation}","page":"Developer zone","title":"MolSimToolkit.restart!","text":"restart!(simulation::Simulation)\n\nRestarts the iteration over the trajectory file.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.set_frame_range!-Tuple{Simulation}","page":"Developer zone","title":"MolSimToolkit.set_frame_range!","text":"set_frame_range!(simulation::Simulation; first=1, last=nothing, step=1)\n\nResets the frame range to be iterated over. This function will restart the iteration of the simulation trajectory.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#Positions","page":"Developer zone","title":"Positions","text":"","category":"section"},{"location":"Developer/","page":"Developer zone","title":"Developer zone","text":"Modules = [ MolSimToolkit ]\nPages = [ \"datastructures/Positions.jl\" ]\nOrder = [ :function, :type ]","category":"page"},{"location":"Developer/#MolSimToolkit.positions-Tuple{Chemfiles.Frame}","page":"Developer zone","title":"MolSimToolkit.positions","text":"positions(frame::Chemfiles.Frame)\n\nReturn the positions of the atoms in a Chemfiles.Frame as a FramePositions object.\n\nThis is the default way to access the positions of the atoms in a simulation.\n\nExample\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> frame = current_frame(simulation);\n\njulia> p = positions(frame);\n\njulia> p[1].x \n5.912472724914551\n\n\n\n\n\n\n","category":"method"},{"location":"Developer/#MolSimToolkit.FramePositions","page":"Developer zone","title":"MolSimToolkit.FramePositions","text":"FramePositions{T,P<:Point3D{T},M<:AbstractArray{T}} <: AbstractVector{P}\n\nContainer for the positions of a set of atoms. The positions are stored in a matrix, where each column corresponds to the coordinates of an atom. The container is used such that using the coodinates from a Chemfiles.Frame is transparent to the user, and the coordinates can be accessed as p[i] where i is the index of the atom. \n\nThe coordinates of the atom can be accessed as p[i].x, p[i].y, and p[i].z.\n\nA FramePositions object can be created with the positions function. The construction with FramePositions is not considered part of the public API.\n\nExample\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> frame = current_frame(simulation);\n\njulia> p = positions(frame)\n20465-element FramePositions{Float64, Point3D{Float64}, Chemfiles.ChemfilesArray}:\n [5.912472724914551, 10.768872261047363, 28.277008056640625]\n [5.040304183959961, 10.810898780822754, 27.71207046508789]\n ⋮\n [11.16289234161377, -37.30374526977539, 22.80788230895996]\n\njulia> p[1]\n3-element Point3D{Float64} with indices SOneTo(3):\n  5.912472724914551\n 10.768872261047363\n 28.277008056640625\n\njulia> p[1].x\n5.912472724914551\n\njulia> p[1].y\n10.768872261047363\n\njulia> p[1].z\n28.277008056640625\n\nIt is also possible to take slices and views of the positions:\n\njulia> p[1:2]\n2-element FramePositions{Float64, Point3D{Float64}, Matrix{Float64}}:\n [5.912472724914551, 10.768872261047363, 28.277008056640625]\n [5.040304183959961, 10.810898780822754, 27.71207046508789]\n\njulia> @view(coor[1:2])\n 2-element FramePositions{Float64, Point3D{Float64}, SubArray{Float64, 2, Chemfiles.ChemfilesArray, Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}, false}}:\n  [5.912472724914551, 10.768872261047363, 28.277008056640625]\n  [5.040304183959961, 10.810898780822754, 27.71207046508789]\n \n\n\n\n\n\n","category":"type"},{"location":"Developer/#MolSimToolkit.Point3D","page":"Developer zone","title":"MolSimToolkit.Point3D","text":"Point3D{T}\n\nA point in 3D space with coordinates x, y, and z of type T.\n\n\n\n\n\n","category":"type"},{"location":"Developer/#Unit-cell","page":"Developer zone","title":"Unit cell","text":"","category":"section"},{"location":"Developer/","page":"Developer zone","title":"Developer zone","text":"Modules = [ MolSimToolkit ]\nPages = [ \"datastructures/Simulation.jl\" ]\nFilter = (f) -> (nameof(f) === :unitcell)","category":"page"},{"location":"Developer/#MolSimToolkit.unitcell-Tuple{Chemfiles.Frame}","page":"Developer zone","title":"MolSimToolkit.unitcell","text":"unitcell(frame::Chemfiles.Frame)\n\nReturns the unit cell of the current frame in the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"Developer/#Wrap-coordinates","page":"Developer zone","title":"Wrap coordinates","text":"","category":"section"},{"location":"Developer/","page":"Developer zone","title":"Developer zone","text":"Modules = [ MolSimToolkit ]\nPages = [ \"wrap.jl\" ]","category":"page"},{"location":"Developer/#MolSimToolkit.wrap","page":"Developer zone","title":"MolSimToolkit.wrap","text":"wrap(x, xref, unit_cell_matrix::SMatrix{N,N,T}) where {N,T}\nwrap(x, xref, sides::AbstractVector)\n\nWraps the coordinates of point x such that it is the minimum image relative to xref. The unit cell  may be given a a static matrix of size (N,N) or as a vector of length N.\n\n\n\n\n\n","category":"function"},{"location":"Developer/#MolSimToolkit.wrap_to_first","page":"Developer zone","title":"MolSimToolkit.wrap_to_first","text":"wrap_to_first(x, unit_cell_matrix)\n\nWraps the coordinates of point x such that the returning coordinates are in the first unit cell with all-positive coordinates. The unit cell  has to be a matrix of size (N,N).\n\nExample\n\njulia> using MolSimToolkit\n\njulia> uc = [10 0 0; 0 10 0; 0 0 10]\nUnitCell{Int64}\n  10.000   0.000   0.000\n   0.000  10.000   0.000\n   0.000   0.000  10.000\n\njulia> wrap_to_first(Point3D(15.0, 13.0, 2.0), uc)\n3-element SVector{3, Float64} with indices SOneTo(3):\n 5.0\n 3.0000000000000004\n 2.0\n\n\n\n\n\n","category":"function"},{"location":"Reweighting/#simulation_reweighting","page":"∘ Simulation Reweighting","title":"Simulation Reweighting","text":"","category":"section"},{"location":"Reweighting/","page":"∘ Simulation Reweighting","title":"∘ Simulation Reweighting","text":"warning: Warning\nThis is an experimental feature. Breaking changes may occur without  a breaking package release.","category":"page"},{"location":"Reweighting/","page":"∘ Simulation Reweighting","title":"∘ Simulation Reweighting","text":"Computes the new weight for a frame of a simulation based on the energy difference between the perturbed and non-perturbed original sampling","category":"page"},{"location":"Reweighting/","page":"∘ Simulation Reweighting","title":"∘ Simulation Reweighting","text":"This resource is based on the Free Energy Perturbation Theory (FEP) in the Molecular Dynamics context. Most of the time, each frame will contribute equally for calculations of some thermodynamic property, however, we can apply a perturbation on one or multiple types of atomic interactions (e.g. making water oxygen and protein carbonyl oxygen interaction more repulsive), making these frames to have different normalized statistical contributions so that we can  possibly preview the outcome of a new simulation with these modifications.","category":"page"},{"location":"Reweighting/#How-to-use-it","page":"∘ Simulation Reweighting","title":"How to use it","text":"","category":"section"},{"location":"Reweighting/","page":"∘ Simulation Reweighting","title":"∘ Simulation Reweighting","text":"julia> using MolSimToolkit","category":"page"},{"location":"Reweighting/#Setting-initial-parameters","page":"∘ Simulation Reweighting","title":"Setting initial parameters","text":"","category":"section"},{"location":"Reweighting/","page":"∘ Simulation Reweighting","title":"∘ Simulation Reweighting","text":"Firstly, we define the simulation object and set the atoms that will determine which interactions will be perturbed:","category":"page"},{"location":"Reweighting/","page":"∘ Simulation Reweighting","title":"∘ Simulation Reweighting","text":"julia> using MolSimToolkit, PDBTools\n\njulia> testdir = \"$(@__DIR__)/test\"\n\"/home/lucasv/.julia/dev/MolSimToolkit/src/Reweighting/test\"\n\njulia> simulation = Simulation(\"$testdir/Testing_reweighting.pdb\", \"/$testdir/Testing_reweighting_10_frames_trajectory.xtc\")\nSimulation \n    Atom type: PDBTools.Atom\n    PDB file: /home/lucasv/.julia/dev/MolSimToolkit/src/Resampling/test/Testing_resampling.pdb\n    Trajectory file: /home/lucasv/.julia/dev/MolSimToolkit/src/Resampling/test/Testing_reweighting_10_frames_trajectory.xtc\n    Total number of frames: 10\n    Frame range: 1:1:10\n    Number of frames in range: 10\n    Current frame: nothing\n\njulia> i1 = PDBTools.selindex(atoms(simulation), \"resname TFE and name O\")\n\njulia> i2 = PDBTools.selindex(atoms(simulation), \"protein and name O\")","category":"page"},{"location":"Reweighting/#Setting-perturbation-function","page":"∘ Simulation Reweighting","title":"Setting perturbation function","text":"","category":"section"},{"location":"Reweighting/","page":"∘ Simulation Reweighting","title":"∘ Simulation Reweighting","text":"In order to obtain these weights, we have to use two functions: the reweight function, which will calculate each weight and the perturbation function, responsible for taking each computed distance between atomic pairs in every frame and determine the resulting energy using these distances in that particular frame based on the applied perturbation.","category":"page"},{"location":"Reweighting/","page":"∘ Simulation Reweighting","title":"∘ Simulation Reweighting","text":"So, secondly, we define some \"perturbation\" function (here we call it gaussian decay) and set up its parameters. Please, take a look at the interface:","category":"page"},{"location":"Reweighting/","page":"∘ Simulation Reweighting","title":"∘ Simulation Reweighting","text":"julia> gaussian_decay(r, α, β) = α*exp(-abs(β)*r^2)\ngaussian_decay (generic function with 1 method)\n\njulia> α = 5.e-3\n0.005\n\njulia> β = 5.e-3\n0.005","category":"page"},{"location":"Reweighting/","page":"∘ Simulation Reweighting","title":"∘ Simulation Reweighting","text":"As it can be seen, the function has to receive two parameters: r which corresponds to the distance between two selected atoms and some parameter to account a modification and change its magnitude, here, we inserted two of them in the same function, α, to change the maximum value of the gaussian curve and β, to adjust its decay behaviour with a given value of r.","category":"page"},{"location":"Reweighting/#Computing-the-new-weights","page":"∘ Simulation Reweighting","title":"Computing the new weights","text":"","category":"section"},{"location":"Reweighting/","page":"∘ Simulation Reweighting","title":"∘ Simulation Reweighting","text":"Finally, using the reweight function, we pass both the simulation and the last function anonymously in the input. Again, watch the interface:","category":"page"},{"location":"Reweighting/","page":"∘ Simulation Reweighting","title":"∘ Simulation Reweighting","text":"julia> cut_off = 12.0\n12.0\n\njulia> weights = reweight(simulation, (i,j,r) -> gaussian_decay(r, α, β), i1, i2; cutoff = cut_off)","category":"page"},{"location":"Reweighting/","page":"∘ Simulation Reweighting","title":"∘ Simulation Reweighting","text":"i and j: if you selected two atom types, i will be the index for either the first, the second, the third and so on up to the last atom of the first group and j will be same, but now for the second one. With these two parameters, it is possible to determine every combination of two atoms, each one coming from one group, and compute the associated dsitance r, so that we are taking into account all interactions between these two atom types to our perturbation. However, if we are dealing with just one group, both of them are indexes for all the atoms of the selected group. Bear in mind that repeated combinations (like i,j = 1,2 or 2,1) will no be computed, since the reweight function calls the map_pairwise! function, from CellListMap.jl that is able to avoid this problem.","category":"page"},{"location":"Reweighting/","page":"∘ Simulation Reweighting","title":"∘ Simulation Reweighting","text":"r: the distance between the twos atoms with indexes i and j in the selected groups.","category":"page"},{"location":"Reweighting/","page":"∘ Simulation Reweighting","title":"∘ Simulation Reweighting","text":"cutoff: the maximum distance that will be computed between two atoms. The default value is 12.0 Angstrom.","category":"page"},{"location":"Reweighting/","page":"∘ Simulation Reweighting","title":"∘ Simulation Reweighting","text":"Once the calculations are finished, the resulted interface is shown, like the example below:","category":"page"},{"location":"Reweighting/","page":"∘ Simulation Reweighting","title":"∘ Simulation Reweighting","text":"-------------\nFRAME WEIGHTS\n-------------\n\nAverage probability = 0.09999999999999999\nstandard deviation = 0.01734935311311546\n\n-------------------------------------------\nFRAME WEIGHTS RELATIVE TO THE ORIGINAL ONES\n-------------------------------------------\n\nAverage probability = 0.45655722352062866\nstandard deviation = 0.0792097248720297\n\n----------------------------------\nCOMPUTED ENERGY AFTER PERTURBATION\n----------------------------------\n\nAverage energy = 0.7973733879299723\nstandard deviation = 0.17177116838361012","category":"page"},{"location":"Reweighting/","page":"∘ Simulation Reweighting","title":"∘ Simulation Reweighting","text":"The data in weights structure is organized as it follows:","category":"page"},{"location":"Reweighting/","page":"∘ Simulation Reweighting","title":"∘ Simulation Reweighting","text":"struct ReweightResults{T<:Real}\n    probability::Vector{T}\n    relative_probability::Vector{T}\n    energy::Vector{T}\nend","category":"page"},{"location":"Reweighting/","page":"∘ Simulation Reweighting","title":"∘ Simulation Reweighting","text":"As an example, if we want the absolute weights computed for our simulation:","category":"page"},{"location":"Reweighting/","page":"∘ Simulation Reweighting","title":"∘ Simulation Reweighting","text":"julia> weights.probability\n10-element Vector{Float64}:\n 0.08987791339898044\n 0.07326337222373071\n 0.0973116226496827\n 0.10965810145525891\n 0.09829891590498603\n 0.0916792371461855\n 0.08548699059703141\n 0.12480704633057726\n 0.09973413264337352\n 0.12988266765019355","category":"page"},{"location":"Reweighting/#Reference-Functions","page":"∘ Simulation Reweighting","title":"Reference Functions","text":"","category":"section"},{"location":"Reweighting/","page":"∘ Simulation Reweighting","title":"∘ Simulation Reweighting","text":"Modules = [MolSimToolkit.Reweighting]\nOrder = [:function, :type]","category":"page"},{"location":"Reweighting/#MolSimToolkit.Reweighting.reweight-Tuple{Simulation, Function, AbstractVector{<:Integer}}","page":"∘ Simulation Reweighting","title":"MolSimToolkit.Reweighting.reweight","text":"reweight(\n    simulation::Simulation, \n    f_perturbation::Function, \n    group_1::AbstractVector{<:Integer}; \n    cutoff::Real = 12.0, \n    k::Real = 1.0, \n    T::Real = 1.0\n)\nreweight(\n    simulation::Simulation, \n    f_perturbation::Function, \n    group_1::AbstractVector{<:Integer}, \n    group_2::AbstractVector{<:Integer};     \n    cutoff::Real = 12.0, \n    k::Real = 1.0, \n    T::Real = 1.0\n)\n\nFunction that calculates the energy difference when a perturbation is applied on the system.\n\nIt returns \"ReweightResults\" structure that contains three results: probability, relative_probability and energy vectors.\n\nThe function needs a MolSimToolkit's simulation object, another function to compute the perturbation and one or two types of atoms.\n\nAdditionally, you can also define a cutoff distance, the constant \"k\" (in some cases, it will be Boltzmann constant) and the temperature, T, of the system.\n\nGroup1 (and group2) is a vector of atoms indexes, extracted, for example, from a pdb file. \n\nExample\n\njulia> import PDBTools\n\njulia> using MolSimToolkit, MolSimToolkit.Resampling\n\njulia> simulation = Simulation(\"/home/runner/work/MolSimToolkit.jl/MolSimToolkit.jl/src/Reweighting/test/Testing_reweighting.pdb\", \"//home/runner/work/MolSimToolkit.jl/MolSimToolkit.jl/src/Reweighting/test/Testing_reweighting_10_frames_trajectory.xtc\")\nSimulation \n    Atom type: Atom\n    PDB file: /home/lucasv/.julia/dev/MolSimToolkit/src/Reweighting/test/Testing_reweighting.pdb\n    Trajectory file: /home/lucasv/.julia/dev/MolSimToolkit/src/Resampling/test/Testing_reweighting_10_frames_trajectory.xtc\n    Total number of frames: 10\n    Frame range: 1:1:10\n    Number of frames in range: 10\n    Current frame: nothing\n\njulia> i1 = PDBTools.selindex(atoms(simulation), \"index 97 or index 106\")\n2-element AbstractVector{<:Integer}:\n  97\n 106\n\njulia> i2 = PDBTools.selindex(atoms(simulation), \"residue 15 and name HB3\")\n1-element AbstractVector{<:Integer}:\n 171\n\njulia> sum_of_dist = reweight(simulation, (i,j,d2) -> d2, i1, i2; cutoff = 25.0)\n-------------\nFRAME WEIGHTS\n-------------\n\nAverage probability = 0.1\nstandard deviation = 0.011364584999859616\n\n-------------------------------------------\nFRAME WEIGHTS RELATIVE TO THE ORIGINAL ONES\n-------------------------------------------\n\nAverage probability = 0.6001821184861403\nstandard deviation = 0.06820820700931557\n\n----------------------------------\nCOMPUTED ENERGY AFTER PERTURBATION\n----------------------------------\n\nAverage energy = 0.5163045415662408\nstandard deviation = 0.11331912115883522\n\njulia> sum_of_dist.energy\n10-element Vector{Real}:\n 17.738965476707595\n 15.923698293115915\n 17.16614676290554\n 19.33003841107648\n 16.02329229247863\n 19.639005665480983\n 35.73986006775934\n 21.88798265022823\n 20.66180657974777\n 16.845109623700647\n\nThis result is the energy difference between the  perturbed frame and the original one. In this case, it is the sum of distances between the reffered atoms\n\n\n\n\n\n","category":"method"},{"location":"Reweighting/#MolSimToolkit.Reweighting.ReweightResults","page":"∘ Simulation Reweighting","title":"MolSimToolkit.Reweighting.ReweightResults","text":"Structure that contains the result of the reweighting analysis of the sequence. \n\nprobability is a vector that contains the normalized weight of each frame in the simulation after applying some perturbation. \n\nrelative_probability is a vector that contains the weight of each frame in the simulation relative to the original one after applying some perturbation.\n\nenergy is a vector that contains the energy difference for each frame in the simulation after applying some perturbation.\n\n\n\n\n\n","category":"type"},{"location":"remd/#Replica-exchange-analysis","page":"Replica exchange","title":"Replica exchange analysis","text":"","category":"section"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"The remd_data function reads the output of a Gromacs-generated  replica-exchange simulation file, and provides some tools for visualization of the quality of the exchange process.","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"compat: Compat\nThis function was introduced in MolSimToolkit version 1.1.0. The function was tested to read log files produced by Gromacs versions: 2019.4\n5.0.4Compatibility with other versions is not guaranteed (issue reporting and contributions are welcome). The heatmap and the support for the stride argument in remd_replica_path where introduced in version 1.6.0","category":"page"},{"location":"remd/#Reading-REMD-data","page":"Replica exchange","title":"Reading REMD data","text":"","category":"section"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"First, read the data from the Gromacs simulation log file:","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"julia> using MolSimToolkit\n\njulia> data = remd_data(MolSimToolkit.remd_production_log)","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"where MolSimToolkit.hremd_production_log is an example log file produced by Gromacs.","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"This will result in a data structure with three fields:","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"steps: Vector of steps at which the exchange was performed.\nexchange_matrix: Matrix of exchanges performed.  Each row corresponds to a step and each column to a replica. \nprobability_matrix: Matrix of probabilities of finding each replica at level of  perturbation. Each column corresponds to a replica and each row to a level of perturbation.","category":"page"},{"location":"remd/#Probability-heatmap","page":"Replica exchange","title":"Probability heatmap","text":"","category":"section"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"One way to visualize the exchange it to produce a heatmap of expected probabilities. This can be done with the auxiliary heatmap function that is provided for the output of remd_data: ","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"using MolSimToolkit\nusing Plots\ndata = remd_data(\"./gromacs_log.dat\")\nheatmap(data)","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"Which will produce a plot of the following form:","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"(Image: )","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"The number of replicas here is 10 (0-9), thus the expected ideal probability of finding each replica in each level is 110. The probabilities are divided by 110, such that 10 implies  an optimal exchange at that replica and level. ","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"The example displays a reasonably good replica exchange pattern. However, replica 2 sampled level 0 about 30% more than expected, and replica 8 sampled  level 0 about 30% less than expected, as indicated by the 1.3 and 0.7 annotations. ","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"To produce a similar heatmap, but with the absolute (not normalized) probabilities of  observing each replica at each level, use heatmap(data; probability_type=:absolute). ","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"compat: Compat\nThe probability_type option of heatmap was introduced in version 1.7.0.","category":"page"},{"location":"remd/#Replica-path","page":"Replica exchange","title":"Replica path","text":"","category":"section"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"A heatmap as the one above suggests checking the path of the replicas along the exchange.  This can be obtained with the remd_replica_path function. For example, to obtain the path of the replicas of number 0 and 1. Replica 0 appeares to have visited reasonably well  all levels from 0 to 12, and replica 1 appears to be trapped in leves 13 to 15.","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"# Obtain the paths\npath0 = remd_replica_path(data, 0; stride = 500)\npath1 = remd_replica_path(data, 1; stride = 500)\n\n# Plot the path\ndefault(fontfamily=\"Computer Modern\")\nplot(\n  [path0  path1],\n  xlabel=\"step\",\n  ylabel=\"replica level\",\n  label=[ \"Replica 0\" \"Replica 1\" ],\n  framestyle=:box\n)","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"Producing the following plot:","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"(Image: )","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"The plot confirms that the replica starting at position 0 sampled properly all states from 0 to 12, while the replica starting at position 1 was trapped in the high energy states.","category":"page"},{"location":"remd/#Probability-data","page":"Replica exchange","title":"Probability data","text":"","category":"section"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"An alternative visualization of the exchange process is given by the probability matrix:","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"julia> scatter(\n           data.probability_matrix,\n           labels= Ref(\"Replica \") .* string.((0:9)'),\n           framestyle=:box,\n           linewidth=2,\n           ylims=(0,0.12), xlims=(0.7, 10.3),\n           xlabel=\"Level\", xticks=(1:10, 0:9),\n           ylabel=\"Probability\",\n           alpha=0.5,\n           margin=0.5Plots.Measures.cm,\n       )","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"Which produces:","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"(Image: hremd2.svg)","category":"page"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"Ideally, the probability of each replica populaing each level should be the inverse of the number of replicas (here 110). In this case, the simulation does not provide a proper sampling of exchanges, becuse it is a short extract of a longer simulation. ","category":"page"},{"location":"remd/#Reference-functions","page":"Replica exchange","title":"Reference functions","text":"","category":"section"},{"location":"remd/","page":"Replica exchange","title":"Replica exchange","text":"Modules = [MolSimToolkit]\nPages = [\"gromacs/remd.jl\"]\nOrder = [:function, :type]","category":"page"},{"location":"remd/#MolSimToolkit.remd_data-Tuple{String}","page":"Replica exchange","title":"MolSimToolkit.remd_data","text":"remd_data(log::String)\n\nFunction to read the log file from a (H)REMD simulation performed with Gromacs.\n\nReturns a GromacsREMDlog structure, containing the steps at which the exchange was tried, the exchange matrix and the probability matrix. The exchange matrix contains the replica number at each level of perturbation for each step. The probability matrix contains the probability of finding each replica at each level.\n\nTested with log files of Gromacs versions:      - 2019.4     - 5.0.4\n\nExample\n\nFirst obtaina the REMD data from the log file:\n\njulia> using MolSimToolkit\n\njulia> data = remd_data(MolSimToolkit.gmx2019_9_log)\n\nThen plot the exchange matrix, which will provide a visual inspection of the exchange process:\n\njulia> using Plots\n\njulia> heatmap(data) \n\n\n\n\n\n","category":"method"},{"location":"remd/#MolSimToolkit.remd_replica_path-Tuple{MolSimToolkit.GromacsREMDlog, Int64}","page":"Replica exchange","title":"MolSimToolkit.remd_replica_path","text":"remd_replica_path(data::GromacsREMDlog, replica::Int; stride::Int = 1)\n\nFunction to obtain the path of a replica in the exchange matrix.\n\n\n\n\n\n","category":"method"},{"location":"remd/#MolSimToolkit.GromacsREMDlog","page":"Replica exchange","title":"MolSimToolkit.GromacsREMDlog","text":"GromacsRMEDlog\n\nStructure to store the log from a REMD simulation performed with Gromacs.  This structure contains three fields:\n\nsteps: Vector of steps at which the exchange was performed.\nexchange_matrix: Matrix of exchanges performed.  Each row corresponds to a step and each column to a replica. \nprobability_matrix: Matrix of probabilities of finding each replica at level of  perturbation. Each column corresponds to a replica and each row to a level of perturbation.\n\n\n\n\n\n","category":"type"},{"location":"molecular_minimum_distances/#Molecular-Minimum-Distances","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Computes the minimum distance between molecules, which are represented as arrays of coordinates in two or three dimensions. ","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"To understand the utility and purpose of this package, consider the image below:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"(Image: nearest.png)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Here, there is one blue molecule, with 6 atoms, and several red molecules, with 2 atoms each. The package has identified which are the molecules of the red set that have at leat one atom within a cutoff from the atoms of the blue molecule, and annotated the corresponding atoms and the distances.","category":"page"},{"location":"molecular_minimum_distances/#Features","page":"Molecular Minimum Distances","title":"Features","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Fast cell-list approach, to compute minimum-distance for thousands, or millions of atoms. \nGeneral periodic boundary conditions supported. \nAdvanced mode for in-place calculations, for non-allocating iterative calls (for analysis of MD trajectories, for example).\nModes for the calculation of minimum-distances in sets of molecules.","category":"page"},{"location":"molecular_minimum_distances/#Most-typical-use:-Understanding-solvation","page":"Molecular Minimum Distances","title":"Most typical use: Understanding solvation","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The most typical scenario is that of a protein, or another macromolecule, in a box of solvent. For example, here we download a frame of a protein which was simulated in a mixture of water and TMAO: ","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> using MolSimToolkit, PDBTools\n\njulia> atoms = MolSimToolkit.MolecularMinimumDistances.download_example()\n   Array{Atoms,1} with 62026 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z  beta occup model segname index_pdb\n       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  0.00  1.00     1    PROT         1\n       2  HT1     ALA     A        1        1  -10.048  -15.427   -5.569  0.00  0.00     1    PROT         2\n       3  HT2     ALA     A        1        1   -9.488  -13.913   -5.295  0.00  0.00     1    PROT         3\n                                                       ⋮ \n   62024  OH2    TIP3     C     9339    19638   13.485   -4.534  -34.438  0.00  1.00     1    WAT2     62024\n   62025   H1    TIP3     C     9339    19638   13.218   -3.647  -34.453  0.00  1.00     1    WAT2     62025\n   62026   H2    TIP3     C     9339    19638   12.618   -4.977  -34.303  0.00  1.00     1    WAT2     62026","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Next, we extract the protein coordinates, and the TMAO coordinates:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> protein = coor(atoms,\"protein\")\n1463-element Vector{SVector{3, Float64}}:\n [-9.229, -14.861, -5.481]\n [-10.048, -15.427, -5.569]\n [-9.488, -13.913, -5.295]\n ⋮\n [6.408, -12.034, -8.343]\n [6.017, -10.967, -9.713]\n\njulia> tmao = coor(atoms,\"resname TMAO\")\n2534-element Vector{SVector{3, Float64}}:\n [-23.532, -9.347, 19.545]\n [-23.567, -7.907, 19.381]\n [-22.498, -9.702, 20.497]\n ⋮\n [13.564, -16.517, 12.419]\n [12.4, -17.811, 12.052]","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The system was simulated with periodic boundary conditions, with sides in this frame of [83.115, 83.044, 83.063], and this information will be provided to the minimum-distance computation.","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Finally, we find all the TMAO molecules having at least one atom closer than 12 Angstroms to the protein, using the current package (TMAO has 14 atoms):","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> list = minimum_distances(\n           xpositions=tmao, # solvent\n           ypositions=protein, # solute\n           xn_atoms_per_molecule=14,\n           cutoff=12.0,\n           unitcell=[83.115, 83.044, 83.063]\n       )\n181-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n ⋮\n MinimumDistance{Float64}(true, 2526, 97, 9.652277658666891)\n\njulia> count(x -> x.within_cutoff, list)\n33","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Thus, 33 TMAO molecules are within the cutoff distance from the protein, and the distances can be used to study the solvation of the protein.","category":"page"},{"location":"molecular_minimum_distances/#Performance","page":"Molecular Minimum Distances","title":"Performance","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"This package exists because this computation is fast. For example, let us choose the water molecules instead, and benchmark the time required to compute this set of distances:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> water = coor(atoms,\"resname TIP3\")\n58014-element Vector{SVector{3, Float64}}:\n [-28.223, 19.92, -27.748]\n [-27.453, 20.358, -27.476]\n [-27.834, 19.111, -28.148]\n ⋮\n [13.218, -3.647, -34.453]\n [12.618, -4.977, -34.303]\n\njulia> using BenchmarkTools\n\njulia> @btime minimum_distances(\n           xpositions=$water, # solvent\n           ypositions=$protein, # solute\n           xn_atoms_per_molecule=3,\n           cutoff=12.0,\n           unitcell=[83.115, 83.044, 83.063]\n       );\n  6.288 ms (3856 allocations: 13.03 MiB)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"To compare, a naive algorithm to compute the same thing takes roughly 400x more for this system size:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> @btime MolSimToolkit.MolecularMinimumDistances.naive_md($water, $protein, 3, [83.115, 83.044, 83.063], 12.0);\n  2.488 s (97 allocations: 609.16 KiB)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"And the computation can be made faster and in-place using the more advanced interface that allows preallocation of main necessary arrays:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> sys = CrossPairs(\n           xpositions=water, # solvent\n           ypositions=protein, # solute\n           xn_atoms_per_molecule=3,\n           cutoff=12.0,\n           unitcell=[83.115, 83.044, 83.063]\n       )\nCrossPairs system with:\n\nNumber of atoms of set: 58014\nNumber of atoms of target structure: 1463\nCutoff: 12.0\nunitcell: [83.12, 0.0, 0.0, 0.0, 83.04, 0.0, 0.0, 0.0, 83.06]\nNumber of molecules in set: 4144\n\njulia> @btime minimum_distances!($sys);\n  2.969 ms (196 allocations: 22.80 KiB)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The remaining allocations occur only for the launching of multiple threads:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> sys = CrossPairs(\n           xpositions=water, # solvent\n           ypositions=protein, # solute\n           xn_atoms_per_molecule=14,\n           cutoff=12.0,\n           unitcell=[83.115, 83.044, 83.063],\n           parallel=false # default is true\n       );\n\njulia> @btime minimum_distances!($sys);\n  15.249 ms (0 allocations: 0 bytes)","category":"page"},{"location":"molecular_minimum_distances/#Example-input-files","page":"Molecular Minimum Distances","title":"Example input files","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The examples here use a molecular system, but the package actually only considers the coordinates of the atoms and the number of atoms of each molecule. Thus, more general distance problems can be tackled.","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The input atomic positions used in the following examples can be obtained with:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> using MolSimToolkit, PDBTools\n\njulia> system = MolSimToolkit.MolecularMinimumDistances.download_example() \n   Array{Atoms,1} with 62026 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z  beta occup model segname index_pdb\n       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  0.00  1.00     1    PROT         1\n       2  HT1     ALA     A        1        1  -10.048  -15.427   -5.569  0.00  0.00     1    PROT         2\n       3  HT2     ALA     A        1        1   -9.488  -13.913   -5.295  0.00  0.00     1    PROT         3\n                                                       ⋮ \n   62024  OH2    TIP3     C     9339    19638   13.485   -4.534  -34.438  0.00  1.00     1    WAT2     62024\n   62025   H1    TIP3     C     9339    19638   13.218   -3.647  -34.453  0.00  1.00     1    WAT2     62025\n   62026   H2    TIP3     C     9339    19638   12.618   -4.977  -34.303  0.00  1.00     1    WAT2     62026\n","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The system consists of a protein (with 1463 atoms), solvated by 181 TMAO molecules (with 14 atoms each), 19338 water molecules, and some ions. ","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"These coordinates belong to a snapshot of a simulation which was performed with cubic periodic boundary conditions, with a box side of 84.48 Angstrom. ","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The coordinates of each of the types of molecules can be extracted from the system array of atoms with (using PDBTools - v0.13 or greater):","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> protein = coor(system,\"protein\")\n1463-element Vector{StaticArrays.SVector{3, Float64}}:\n [-9.229, -14.861, -5.481]\n [-10.048, -15.427, -5.569]\n [-9.488, -13.913, -5.295]\n ⋮\n [6.408, -12.034, -8.343]\n [6.017, -10.967, -9.713]\n\njulia> tmao = coor(system,\"resname TMAO\")\n2534-element Vector{StaticArrays.SVector{3, Float64}}:\n [-23.532, -9.347, 19.545]\n [-23.567, -7.907, 19.381]\n [-22.498, -9.702, 20.497]\n ⋮\n [13.564, -16.517, 12.419]\n [12.4, -17.811, 12.052]\n\njulia> water = coor(system,\"water\")\n58014-element Vector{StaticArrays.SVector{3, Float64}}:\n [-28.223, 19.92, -27.748]\n [-27.453, 20.358, -27.476]\n [-27.834, 19.111, -28.148]\n ⋮\n [13.218, -3.647, -34.453]\n [12.618, -4.977, -34.303]","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Using these vectors of coordinates, we will illustrate the use of the current package.","category":"page"},{"location":"molecular_minimum_distances/#Shortest-distances-from-a-solute","page":"Molecular Minimum Distances","title":"Shortest distances from a solute","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The simplest usage consists of finding for each molecule of one set the atoms of the other set which are closer to them. For example, here we want the atoms of the proteins which are closer to each TMAO molecule (14 atoms), within a cutoff of 12.0 Angstroms.","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The simulations was performed with periodic boundary conditions, in a cubic box of sides [84.48, 84.48, 84.48]. We compute the minimum distances with:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> list = minimum_distances(\n           xpositions=tmao, # solvent\n           ypositions=protein, # solute\n           xn_atoms_per_molecule=14,\n           cutoff=12.0,\n           unitcell=[84.48, 84.48, 84.48]\n       )\n181-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n ⋮\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(true, 2526, 97, 9.652277658666891)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The list contains, for each molecule of TMAO, a MinimumDistance object, containing the following fields,  exemplified by printing the last entry of the list:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> list[end]\nMinimumDistance{Float64}(true, 2526, 97, 9.652277658666891)\n\nDistance within cutoff, within_cutoff = true\nx atom of pair, i = 2526\ny atom of pair, j = 97\nDistance found, d = 9.652277658666891","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The fields within_cutoff, i, j, and d show if a distance was found within the cutoff, the indices of the atoms involved in the contact, and their distance.","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Getter functions are available to extract eac hof these fields, to add some convenience: within_cutoff, iatom, jatom, and distance.","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"note: Note\nIf the solute has more than one molecule, this will not be taken into  consideration in this mode. All molecules will be considered as part of the same structure (the number of atoms per molecule of the protein is not a parameter here).","category":"page"},{"location":"molecular_minimum_distances/#All-shortest-distances","page":"Molecular Minimum Distances","title":"All shortest distances","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"A similar call of the previous section can be used to compute, for each molecule of a set of molecules, which is the closest atom of every other molecule of another set. ","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"In the example, we can compute for each TMAO molecule, which is the closest atom of water, and vice-versa. The difference from the previous call is that now wee need to provide the number of atoms of both TMAO and water:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> water_list, tmao_list = minimum_distances(\n           xpositions=water,\n           ypositions=tmao,\n           xn_atoms_per_molecule=3,\n           yn_atoms_per_molecule=14,\n           unitcell=[84.48, 84.48, 84.48],\n           cutoff=12.0\n       );\n\njulia> water_list\n19338-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 2, 1512, 4.779476331147592)\n MinimumDistance{Float64}(true, 6, 734, 2.9413928673334357)\n MinimumDistance{Float64}(true, 8, 859, 5.701548824661595)\n ⋮\n MinimumDistance{Float64}(true, 58010, 1728, 3.942870781549911)\n MinimumDistance{Float64}(true, 58014, 2058, 2.2003220218867936)\n\njulia> tmao_list\n181-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 12, 22520, 2.1985345118965056)\n MinimumDistance{Float64}(true, 20, 33586, 2.1942841657360606)\n MinimumDistance{Float64}(true, 37, 26415, 2.1992319113726926)\n ⋮\n MinimumDistance{Float64}(true, 2512, 37323, 2.198738501959709)\n MinimumDistance{Float64}(true, 2527, 33664, 2.1985044916943015)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Two lists were returned, the first containing, for each water molecule, MinimumDistance data associated to the closest TMAO molecule (meaning the atoms involved in the contact and their distance). Similarly, the second list contains, for each TMAO molecule, the MinimumDistance data associated to each TMAO molecule. ","category":"page"},{"location":"molecular_minimum_distances/#Shortest-distances-within-molecules","page":"Molecular Minimum Distances","title":"Shortest distances within molecules","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"There is an interface to compute the shortest distances of molecules within a set of molecules. That is, given one group of molecules, compute for each molecule which is the shortest distance among the other molecules of the same type. ","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"A typical call would be:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> water_list = minimum_distances(\n           xpositions=water,\n           xn_atoms_per_molecule=3,\n           unitcell=[84.48, 84.48, 84.48],\n           cutoff=12.0\n       )\n19338-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 2, 33977, 2.1997806708851724)\n MinimumDistance{Float64}(true, 4, 43684, 2.1994928961012814)\n MinimumDistance{Float64}(true, 9, 28030, 2.1997583958244142)\n ⋮\n MinimumDistance{Float64}(true, 58010, 22235, 2.1992096307537414)\n MinimumDistance{Float64}(true, 58012, 9318, 2.20003227249056)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Which contains for each water molecule the atoms involved in the closest contact to any other water molecule, and the distances (within the cutoff). A pictorial representation of a result of this type is, for a simpler system:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"(Image: self pairs)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"This can be used for the identification of connectivity networks, for example, or for some types of clustering.","category":"page"},{"location":"molecular_minimum_distances/#Advanced-usage","page":"Molecular Minimum Distances","title":"Advanced usage","text":"","category":"section"},{"location":"molecular_minimum_distances/#System-build-and-update","page":"Molecular Minimum Distances","title":"System build and update","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"If the molecular minimum distances will be computed many times for similar systems, it is possible to construct the system and update its properties. The use of the interface of CellListMap is required (requires CellListMap version 0.7.24 or greater). ","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"For example, let us build one system with a protein and water:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> using MolSimToolkit, PDBTools\n\njulia> system = MolecularMinimumDistances.download_example();\n\njulia> protein = coor(system, \"protein\");\n\njulia> water = coor(system, \"water\");","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"We now build the CrossPairs  type of system, instead of calling the minimum_distances function directly:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> sys = CrossPairs(\n           xpositions=water, # solvent\n           ypositions=protein, # solute\n           xn_atoms_per_molecule=3,\n           cutoff=12.0,\n           unitcell=[84.48, 84.48, 84.48]\n       )\nCrossPairs system with:\n\nNumber of atoms of set x: 58014\nNumber of molecules in set x: 19338\nNumber of atoms of target structure y: 1463\nCutoff: 12.0\nunitcell: [84.48, 0.0, 0.0, 0.0, 84.48, 0.0, 0.0, 0.0, 84.48]","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Now sys  contains the necessary arrays for computing the list of minimum distances. We use now the minimum_distances!  function (with the !), to update that list:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> minimum_distances!(sys)\n19338-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n ⋮\n MinimumDistance{Float64}(true, 58011, 383, 10.24673074692606)\n MinimumDistance{Float64}(false, 0, 0, Inf)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The system can be now updated: the positions, cutoff, or unitcell can be modified, with the  following interfaces:","category":"page"},{"location":"molecular_minimum_distances/#Updating-positions","page":"Molecular Minimum Distances","title":"Updating positions","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"To update the positions, modify the sys.xpositions (or ypositions)  array. We will boldy demonstrate this by making the first atom of the x set to be close to the first atom of the protein, and recomputing the distances:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> using StaticArrays\n\njulia> sys.xpositions[2] = sys.ypositions[1] + SVector(1.0,0.0,0.0);\n\njulia> minimum_distances!(sys)\n19338-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 2, 4, 0.9202923448556931)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n ⋮\n MinimumDistance{Float64}(true, 58011, 383, 10.24673074692606)\n MinimumDistance{Float64}(false, 0, 0, Inf)","category":"page"},{"location":"molecular_minimum_distances/#Updating-the-cutoff,-unitcell-and-parallel-flag","page":"Molecular Minimum Distances","title":"Updating the cutoff, unitcell and parallel flag","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The cutoff, unitcell and parallel data of the sys objects can be modified  directly. For example:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> sys\nCrossPairs system with:\n\nNumber of atoms of set x: 58014\nNumber of molecules in set x: 19338\nNumber of atoms of target structure y: 1463\nCutoff: 15.0\nunitcell: [100.0, 0.0, 0.0, 0.0, 100.0, 0.0, 0.0, 0.0, 100.0]\n\njulia> sys.cutoff = 10.0\n10.0\n\njulia> sys.unitcell = [84.4, 84.4, 84.4]\n3-element Vector{Float64}:\n 84.4\n 84.4\n 84.4\n\njulia> sys.parallel = false\nfalse\n\njulia> sys\nCrossPairs system with:\n\nNumber of atoms of set x: 58014\nNumber of molecules in set x: 19338\nNumber of atoms of target structure y: 1463\nCutoff: 10.0\nunitcell: [84.4, 0.0, 0.0, 0.0, 84.4, 0.0, 0.0, 0.0, 84.4]","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"note: Note\nIt is not possible to update the unitcell from a Orthorhombic to a general Triclinic cell. If the system will be Triclinic at any moment, the unitcell must be initialized with the full matrix instead of a  vector of sides.","category":"page"},{"location":"molecular_minimum_distances/#Index-of-molecules","page":"Molecular Minimum Distances","title":"Index of molecules","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Additionally, the low level interface allows the definition of more general groups of particles, in the sense that \"molecule\" can have different number of atoms in the same set. Therefore, one needs to provide a function that returns the index of the molecule of each atom, given the index of the atom. ","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Briefly, if a set of atoms belong to molecules of the same number of atoms, one can compute the index of each molecule using","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"mol_indices(i,n) = div((i - 1), n) + 1","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"where i is the atom index in the array of coordinates, and n is the number of atoms per molecule. This is the default assumed in the basic interface, and can be called with:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> using StaticArrays\n\njulia> x = rand(SVector{3,Float64},9); # 3 water molecules\n\njulia> mol_indices(2,3) # second atom belongs to first molecule\n1\n\njulia> mol_indices(4,3) # fourth atom belongs to second molecule\n2","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Typically, as we will show, this function will be used for setting up molecule indices.","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"However, more general indexing can be used. For instance, let us suppose that the 9 atoms of the x array of coordinates above belong to 2 molecules, with 4 and 5 atoms each. Then, we could define, for example:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> my_mol_indices(i) = i <= 4 ? 1 : 2\nmy_mol_indices (generic function with 1 method)\n\njulia> my_mol_indices(4)\n1\n\njulia> my_mol_indices(5)\n2","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Since the function can close-over an array of molecular indices, the definition can be completely general, that is:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> molecular_indices = [ 1, 3, 3, 2, 2, 1, 3, 1, 2 ];\n\njulia> my_mol_indices(i) = molecular_indices[i]\nmy_mol_indices (generic function with 1 method)\n\njulia> my_mol_indices(1)\n1\n\njulia> my_mol_indices(5)\n2","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"In summary, this function that given the index of the atom returns the index of the corresponding molecule must be provided in the advanced interface, and typically will be just a closure around the number of atoms per molecule, using the already available mol_indices function. ","category":"page"},{"location":"molecular_minimum_distances/#Example","page":"Molecular Minimum Distances","title":"Example","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Let us mix water and TMAO molecules in the same set, and use a general function to compute the indices of the molecules of each atom: ","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> system = MolecularMinimumDistances.download_example();\n\njulia> protein = coor(system, \"protein\");\n\njulia> tmao_and_water = select(system, \"resname TMAO or resname TIP3\")\n   Array{Atoms,1} with 60548 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z  beta occup model segname index_pdb\n    1479    N    TMAO     A        1      120  -23.532   -9.347   19.545  0.00  1.00     1    TMAO      1479\n    1480   C1    TMAO     A        1      120  -23.567   -7.907   19.381  0.00  1.00     1    TMAO      1480\n    1481   C2    TMAO     A        1      120  -22.498   -9.702   20.497  0.00  1.00     1    TMAO      1481\n                                                       ⋮ \n   62024  OH2    TIP3     C     9339    19638   13.485   -4.534  -34.438  0.00  1.00     1    WAT2     62024\n   62025   H1    TIP3     C     9339    19638   13.218   -3.647  -34.453  0.00  1.00     1    WAT2     62025\n   62026   H2    TIP3     C     9339    19638   12.618   -4.977  -34.303  0.00  1.00     1    WAT2     62026\n\njulia> findfirst(at -> at.resname == \"TIP3\", tmao_and_water)\n2535","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Thus, the tmao_and_water atom array has two different types of molecules, TMAO with 14 atoms, and water with 3 atoms.  The first atom of a water molecule is atom 2535 of the array. We extract the coordinates of the atoms with:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> solvent = coor(tmao_and_water)\n60548-element Vector{SVector{3, Float64}}:\n [-23.532, -9.347, 19.545]\n [-23.567, -7.907, 19.381]\n [-22.498, -9.702, 20.497]\n ⋮\n [13.218, -3.647, -34.453]\n [12.618, -4.977, -34.303]","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"And now we define a function that, given the index of the atom, returns the molecule to which it belongs:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> function mol_indices(i) \n           if i < 2535 # TMAO (14 atoms per molecule) \n               div(i-1,14) + 1 \n           else # water (3 atoms per molecule)\n               mol_indices(2534) + div(i-2534-1,3) + 1\n           end\n       end\nmol_indices (generic function with 3 method)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The function above computes the molecular indices for TMAO in the standard way, and computes the water  molecular indices by first summing the molecule index of the last TMAO molecule, and subtracting from the atomic index of water the last index of the last TMAO atom. We can test this: ","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> mol_indices(14) # last atom of first TMAO\n1\n\njulia> mol_indices(15) # first atom of second TMAO\n2\n\njulia> mol_indices(2534) # last atom of last TMAO\n181\n\njulia> mol_indices(2535) # first atom of first water\n182\n\njulia> mol_indices(2537) # last atom of first water\n182\n\njulia> mol_indices(2538) # first atom of second water\n183","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"With this function, we can construct the system using it instead of the xn_atoms_per_molecule integer variable, to obtain the solvation of the protein by both TMAO and water in a single run:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> sys = CrossPairs(\n           xpositions=solvent, # solvent = coor(tmao_and_water)\n           ypositions=protein, # solute\n           xmol_indices = mol_indices,\n           cutoff=12.0,\n           unitcell=[84.48, 84.48, 84.48]\n       )\nCrossPairs system with:\n\nNumber of atoms of set x: 60548\nNumber of molecules in set x: 19519\nNumber of atoms of target structure y: 1463\nCutoff: 12.0\nunitcell: [84.48, 0.0, 0.0, 0.0, 84.48, 0.0, 0.0, 0.0, 84.48]","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"As we can see, the number of molecules is correct (the sum of the number of water and tmao molecules). And the list of minimum distances will retrive the information of the closest protein atom to all solvent molecules of the set:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> minimum_distances!(sys)\n19519-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n ⋮\n MinimumDistance{Float64}(true, 60545, 383, 10.24673074692606)\n MinimumDistance{Float64}(false, 0, 0, Inf)","category":"page"},{"location":"molecular_minimum_distances/#Citation","page":"Molecular Minimum Distances","title":"Citation","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"If this package was useful, please cite the article describing the main algorithms on which it is based:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"L. Martínez, CellListMap.jl: Efficient and customizable cell list implementation for calculation of pairwise particle properties within a cutoff. Computer Physics Communications 279, 108452 (2022). ","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"DOI: 10.1016/j.cpc.2022.108452","category":"page"},{"location":"molecular_minimum_distances/#Help-entries","page":"Molecular Minimum Distances","title":"Help entries","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Modules = [MolSimToolkit.MolecularMinimumDistances]\nOrder = [:function, :type]","category":"page"},{"location":"molecular_minimum_distances/#MolSimToolkit.MolecularMinimumDistances.iatom-Tuple{MinimumDistance}","page":"Molecular Minimum Distances","title":"MolSimToolkit.MolecularMinimumDistances.iatom","text":"iatom(md::MinimumDistance) = md.i\n\nReturns the index of the atom of the first set that is closer to the atom of the second set.\n\n\n\n\n\n","category":"method"},{"location":"molecular_minimum_distances/#MolSimToolkit.MolecularMinimumDistances.jatom-Tuple{MinimumDistance}","page":"Molecular Minimum Distances","title":"MolSimToolkit.MolecularMinimumDistances.jatom","text":"jatom(md::MinimumDistance) = md.j\n\nReturns the index of the atom of the second set that is closer to the atom of the first set.\n\n\n\n\n\n","category":"method"},{"location":"molecular_minimum_distances/#MolSimToolkit.MolecularMinimumDistances.minimum_distances!-Tuple{Any}","page":"Molecular Minimum Distances","title":"MolSimToolkit.MolecularMinimumDistances.minimum_distances!","text":"minimum_distances!(system)\n\nFunction that computes the minimum distances for an initialized system, of SelfPairs, CrossPairs, or AllPairs types. \n\nThe function returs a Vector{MinimumDistance} cor SelfPairs and CrossPairs inputs, and a Tuple of two of such vectors for the AllPairs input types.\n\nThis function is used as an advanced alternative from preallocated system inputs. Only a few allocations  remain on a call to minimum_distances!, mostly related to the launch of the multithreaded  calculations.\n\nExample\n\njulia> using MolSimToolkit, StaticArrays\n\njulia> sys = SelfPairs(\n           xpositions = rand(SVector{3,Float64},1000), \n           unitcell=[1,1,1], \n           cutoff = 0.1, \n           xn_atoms_per_molecule=10,\n       )\nSelfPairs system with:\n\nNumber of atoms: 1000\nCutoff: 0.1\nunitcell: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]\nNumber of molecules: 100\n\njulia> minimum_distances!(sys)\n100-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 8, 579, 0.03570387474690425)\n MinimumDistance{Float64}(true, 12, 534, 0.02850448652684309)\n ⋮\n MinimumDistance{Float64}(true, 996, 423, 0.03655145613454862)\n\njulia> using BenchmarkTools\n\njulia> @btime minimum_distances!($sys);\n  178.468 μs (209 allocations: 22.80 KiB)\n\n\n\n\n\n","category":"method"},{"location":"molecular_minimum_distances/#MolSimToolkit.MolecularMinimumDistances.minimum_distances-Tuple{}","page":"Molecular Minimum Distances","title":"MolSimToolkit.MolecularMinimumDistances.minimum_distances","text":"minimum_distances(\n   xpositions::AbstractVector{<:SVector},\n   # or xpositions *and* ypositions (CrossPairs or AllPairs)\n   cutoff=0.1,\n   unitcell=[1,1,1],\n   xn_atoms_per_molecule=5\n   # or xn_atoms_per_molecule (CrossPairs)\n   # or xn_atoms_per_molecule *and* yn_atoms_per_molecule (AllPairs)\n)\n\nThis function computes directly the minimum distances in a set of particles.  Depending on the number of input position arrays provided and on the number of molecular index information provided, a different type of calculation is performed:\n\nIf xpositions and xn_atoms_per_molecule are provided, the minimum distances within the set of molecules of the set provided are computed. \nIf xpositions and ypositions are provided, and only xn_atoms_per_molecule is provided, the minimum distance of molecule of set x will be computed relative to set y (or, in other words, ypositions are considered a single structure) \nIf xpositions and ypositions are provided, and xn_atoms_per_molecule and yn_atoms_per_molecule are given, the minimum distances of each molecule of x to any atom of y are computed, and vice-versa. A tuple of vectors of minimum distances is returned, with lengths corresponding to the number of molecules of sets x and y, respectively.\n\nAs for the other functions are constructors, the xn_atoms_per_molecule keyword parameters can be substituted by a general function which returns the molecular  index of the molecule of each atom (i. e. (i) -> (i-1)%n_atoms_per_molecule + 1 in the simplest and default case).\n\nExamples\n\nSingle set of molecules: all minimum distances within the set\n\nNote that the output contains a vector of MinimumDistance elements with a length equal to the number of molecules of the set.\n\njulia> using MolSimToolkit, StaticArrays\n\njulia> list = minimum_distances(\n           xpositions = rand(SVector{3,Float64},10^5), \n           unitcell=[1,1,1], \n           cutoff = 0.1, \n           xn_atoms_per_molecule=10)\n10000-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 5, 71282, 0.007669490894775502)\n MinimumDistance{Float64}(true, 19, 36374, 0.005280726329888545)\n ⋮\n MinimumDistance{Float64}(true, 99998, 44320, 0.006509632622462869)\n\nTwo sets: minimum distances of one set relative to the other\n\nNote that the output contains the number of molecules of the x set. For each molecule of this set, the minimum distance to the set y is  computed. This is the typical \"solute-solvent\" example, where x contains the solvent positions, and y contains the solute positions.\n\njulia> list = minimum_distances(\n           xpositions = rand(SVector{3,Float64},10^5), \n           ypositions = rand(SVector{3,Float64},10^3),\n           unitcell=[1,1,1], \n           cutoff = 0.1, \n           xn_atoms_per_molecule=10,\n       )\n10000-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 5, 596, 0.025526453519907292)\n MinimumDistance{Float64}(true, 18, 391, 0.014114699969628301)\n ⋮\n MinimumDistance{Float64}(true, 99993, 289, 0.016089848937890512)\n\nTwo-sets: computing all minimum distances among molecules\n\nIf the number of molecules of both sets are provided with the xn_atoms_per_molecule and yn_atoms_per_molecule keywords, both sets are split into molecules, and all minimum distances are computed. For each molecule of each set,  the minimimum distance to any other molecule of the other set is returned. The output is a tuple of lists.\n\njulia> lists = minimum_distances(\n           xpositions = rand(SVector{3,Float64},10^5), \n           ypositions = rand(SVector{3,Float64},10^3),\n           unitcell=[1,1,1], \n           cutoff = 0.1, \n           xn_atoms_per_molecule=10,\n           yn_atoms_per_molecule=100\n       );\n\njulia> lists[1]\n10000-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 10, 471, 0.03211876310646438)\n MinimumDistance{Float64}(true, 13, 113, 0.0364141004391549)\n ⋮\n MinimumDistance{Float64}(true, 99992, 673, 0.0345818388567913)\n\njulia> lists[2]\n10-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 81, 754, 0.002292544732548094)\n MinimumDistance{Float64}(true, 156, 17208, 0.0018147268509811352)\n ⋮\n MinimumDistance{Float64}(true, 944, 98048, 0.002902338025311851)\n\n\n\n\n\n","category":"method"},{"location":"molecular_minimum_distances/#MolSimToolkit.MolecularMinimumDistances.within_cutoff-Tuple{MinimumDistance}","page":"Molecular Minimum Distances","title":"MolSimToolkit.MolecularMinimumDistances.within_cutoff","text":"within_cutoff(md::MinimumDistance) = md.within_cutoff\n\nReturns true if the distance is within the cutoff, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"molecular_minimum_distances/#PDBTools.distance-Tuple{MinimumDistance}","page":"Molecular Minimum Distances","title":"PDBTools.distance","text":"distance(md::MinimumDistance) = md.d\n\nReturns the distance between the atoms of the pair.\n\n\n\n\n\n","category":"method"},{"location":"molecular_minimum_distances/#MolSimToolkit.MolecularMinimumDistances.AllPairs-Union{Tuple{}, Tuple{F2}, Tuple{F1}, Tuple{T}} where {T<:Real, F1<:Union{Nothing, Function}, F2<:Union{Nothing, Function}}","page":"Molecular Minimum Distances","title":"MolSimToolkit.MolecularMinimumDistances.AllPairs","text":"AllPairs(;\n    xpositions::AbstractVector{<:AbstractVector{T}},\n    ypositions::AbstractVector{<:AbstractVector{T}},\n    cutoff::T,\n    unitcell::AbstractVecOrMat,\n    xn_atoms_per_molecule::Int,\n    yn_atoms_per_molecule::Int,\n    parallel::Bool=true\n) where T<:Real\n\nInitializes a particle system for the calculation of minimum distances between one molecule and a set of other molecules. Returns a list  minimum distances (MinimumDistance type), containing for each molecule of the set the information about the closest distance to the reference molecule.\n\nInstead of the number of atoms per molecule, the user can also provide a  more general xmol_indices and/or ymol_indices functions,  which, for each atomic index, returns the corresponding molecular index (which is mol_indices(i) = (i-1)%n + 1 where n is the number of atoms per molecule if all molecules have the same number of atoms and are continously stored in the array of positions). \n\nExamples\n\njulia> using MolSimToolkit, StaticArrays\n\njulia> sys = AllPairs(\n           xpositions=rand(SVector{3,Float64},10^5), # \"solvent\" (set of molecules)\n           ypositions=rand(SVector{3,Float64},1000), # \"solute\" (target structure)\n           cutoff=0.1,\n           unitcell=[1,1,1],\n           xn_atoms_per_molecule=5, # of the \"solvent\"\n           yn_atoms_per_molecule=10 # of the \"solvent\"\n       )\nAllPairs system with:\n\nNumber of atoms of first set: 100000\nNumber of molecules in first set: 20000\n\nNumber of atoms of second set: 1000\nNumber of molecules in second set: 100\n\nCutoff: 0.1\nunitcell: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]\n\njulia> minimum_distances!(sys)[1]\n20000-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 1, 859, 0.037219109441123784)\n MinimumDistance{Float64}(true, 10, 117, 0.042183794688796634)\n ⋮\n MinimumDistance{Float64}(true, 99996, 168, 0.014269620784984633)\n\n\n\n\n\n","category":"method"},{"location":"molecular_minimum_distances/#MolSimToolkit.MolecularMinimumDistances.CrossPairs-Union{Tuple{}, Tuple{F1}, Tuple{T}} where {T<:Real, F1<:Union{Nothing, Function}}","page":"Molecular Minimum Distances","title":"MolSimToolkit.MolecularMinimumDistances.CrossPairs","text":"CrossPairs(;\n    xpositions::AbstractVector{<:AbstractVector{T}},\n    ypositions::AbstractVector{<:AbstractVector{T}},\n    cutoff::T,\n    unitcell::AbstractVecOrMat,\n    xn_atoms_per_molecule::Int,\n    parallel::Bool=true\n) where T<:Real\n\nInitializes a particle system for the calculation of minimum distances between one molecule and a set of other molecules. Returns a list  minimum distances (MinimumDistance type), containing for each molecule of the set the information about the closest distance to the reference molecule.\n\nInstead of the number of atoms per molecule, the user can also provide a  more general mol_indices function, which, for each atomic index, returns the  corresponding molecular index (which is mol_indices(i) = (i-1)%n + 1 where n is the number of atoms per molecule if all molecules have the same number of atoms and are continously stored in the array of positions). \n\nExamples\n\njulia> using MolSimToolkit, StaticArrays\n\njulia> sys = CrossPairs(\n           xpositions=rand(SVector{3,Float64},10^5), # \"solvent\" (set of molecules)\n           ypositions=rand(SVector{3,Float64},1000), # \"solute\" (target structure)\n           cutoff=0.1,\n           unitcell=[1,1,1],\n           xn_atoms_per_molecule=5 # of the \"solvent\"\n       )\nCrossPairs system with:\n\nNumber of atoms of set: 100000\nNumber of atoms of target structure: 1000\nCutoff: 0.1\nunitcell: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]\nNumber of molecules in set: 20000\n\njulia> minimum_distances!(sys)\n20000-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 1, 859, 0.037219109441123784)\n MinimumDistance{Float64}(true, 10, 117, 0.042183794688796634)\n ⋮\n MinimumDistance{Float64}(true, 99996, 168, 0.014269620784984633)\n\n\n\n\n\n","category":"method"},{"location":"molecular_minimum_distances/#MolSimToolkit.MolecularMinimumDistances.MinimumDistance","page":"Molecular Minimum Distances","title":"MolSimToolkit.MolecularMinimumDistances.MinimumDistance","text":"MinimumDistance{T}\n\nThe lists of minimum-distances are stored in arrays of type Vector{MinimumDistance{T}}. The index of this vector corresponds to the index of the molecule in the original array.\n\nMinimumDistance{T} is a simple structure that contains four fields: a boolean marker indicating if the distance is within the cutoff, the indices i and j of the atoms of the  molecules that are closer to each other, and the distance d, with type T, which is the same as that of the coordinates of the input vectors of coordinates. The best way to access the information of a MinimumDistance element is through the getter functions within_cutoff, distance, iatom, and jatom.\n\nExample\n\njulia> md = MinimumDistance{Float32}(true, 2, 5, 1.f0)\nMinimumDistance{Float32}(true, 2, 5, 1.0f0)\n\njulia> iatom(md)\n2\n\njulia> jatom(md)\n5\n\njulia> distance(md)\n1.0f0\n\njulia> within_cutoff(md)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"molecular_minimum_distances/#MolSimToolkit.MolecularMinimumDistances.SelfPairs-Union{Tuple{}, Tuple{F1}, Tuple{T}} where {T<:Real, F1<:Union{Nothing, Function}}","page":"Molecular Minimum Distances","title":"MolSimToolkit.MolecularMinimumDistances.SelfPairs","text":"SelfPairs(;\n    xpositions::AbstractVector{<:AbstractVector{T}},\n    cutoff::T,\n    unitcell::AbstractVecOrMat,\n    xn_atoms_per_molecule::Int,\n    parallel::Bool=true\n) where T<:Real\n\nInitializes a particle system for the calculation of minimum distances within a single set of molecules. The shortest distance of each molecule to any other molecule of the same set is computed.\n\nInstead of the number of atoms per molecule, the user can also provide a  more general mol_indices function, which, for each atomic index, returns the  corresponding molecular index (which is mol_indices(i) = (i-1)%n + 1 where n is the number of atoms per molecule if all molecules have the same number of atoms and are continously stored in the array of positions). \n\nExamples\n\njulia> using MolSimToolkit, StaticArrays\n\njulia> sys = SelfPairs(\n           xpositions=rand(SVector{3,Float64},10^5),\n           cutoff=0.1,\n           unitcell=[1,1,1],\n           xn_atoms_per_molecule=5\n       )\nSelfPairs system with:\n\nNumber of atoms: 100000\nCutoff: 0.1\nunitcell: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]\nNumber of molecules: 20000\n\njulia> minimum_distances!(sys)\n20000-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 4, 24930, 0.008039482961077074)\n MinimumDistance{Float64}(true, 6, 74055, 0.0049818659155905255)\n ⋮\n MinimumDistance{Float64}(true, 99999, 75403, 0.0025051670801269433)\n\n\n\n\n\n","category":"method"},{"location":"molecular_minimum_distances/#Details-of-the-illustration","page":"Molecular Minimum Distances","title":"Details of the illustration","text":"","category":"section"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The initial illustration here consists of a toy solute-solvent example, where the solute is an approximately hexagonal molecule, and the solvent is composed by 40 diatomic molecules. The toy system is built as follows:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"using MolecularMinimumDistances, StaticArrays\n# x will contain the \"solvent\", composed by 40 diatomic molecules\nT = SVector{2,Float64}\nx = T[]\ncmin = T(-20,-20)\nfor i in 1:40\n    v = cmin .+ 40*rand(T)\n    push!(x, v)\n    theta = 2pi*rand()\n    push!(x, v .+ T(sin(theta),cos(theta)))\nend\n# y will contain the \"solute\", composed by an approximate hexagonal molecule\ny = [ T(1,1), T(1,-1), T(0,-1.5), T(-1,-1), T(-1,1), T(0,1.5) ]","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"Next, we compute the minimum distances between each molecule of x (the solvent) and the solute. In the input we need to specify the number of atoms of each molecule in x, and the cutoff up to which we want the distances to be computed:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> list = minimum_distances(\n           xpositions=x,\n           ypositions=y,\n           xn_atoms_per_molecule=2,\n           unitcell=[40.0, 40.0],\n           cutoff=10.0\n       )\n40-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 2, 3, 1.0764931248364737)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n ⋮\n MinimumDistance{Float64}(true, 74, 5, 7.899981412729262)\n MinimumDistance{Float64}(false, 0, 0, Inf)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"The output is a list of MinimumDistance data structures, one for each molecule in x. The true indicates that a distance smaller than the cutoff was found, and for these the indices of the atoms in x and y associated are reported, along with the distance between them.","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"In this example, from the 40 molecules of x, eleven had atoms closer than the cutoff to some atom of y:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"julia> count(x -> x.within_cutoff, list)\n11","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"We have an auxiliary function to plot the result, in this case where the \"atoms\" are bi-dimensional:","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"using Plots\nimport MolecularMinimumDistances: plot_md!\np = plot(lims=(-20,20),framestyle=:box,grid=false,aspect_ratio=1)\nplot_md!(p, x, 2, y, 6, list, y_cycle=true)","category":"page"},{"location":"molecular_minimum_distances/","page":"Molecular Minimum Distances","title":"Molecular Minimum Distances","text":"will produce the illustration plot above, in which the nearest point between the two sets is identified.","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"CollapsedDocStrings = true","category":"page"},{"location":"secondary_structures/#Secondary-structures","page":"Secondary structure","title":"Secondary structures","text":"","category":"section"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"This package provides convenience functions to analyze the protein secondary structure along molecular dynamics simulations. ","category":"page"},{"location":"secondary_structures/#Secondary-structure-map","page":"Secondary structure","title":"Secondary structure map","text":"","category":"section"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"The secondary structure map is the profile of the secondary structure computed for  each frame of the trajectory. This computation may be costly, particularly with the  DSSP algorithm, so it is recommended to save the result. See Saving and loading a map for further information. ","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"ss_map","category":"page"},{"location":"secondary_structures/#MolSimToolkit.ss_map","page":"Secondary structure","title":"MolSimToolkit.ss_map","text":"ss_map(\n    simulation::Simulation; \n    selection::Union{AbstractString,Function}=PDBTools.isprotein,\n    ss_method=stride_run,\n    show_progress=true\n)\n\nCalculates the secondary structure map of the trajectory.  Returns a matrix of secondary structure codes, where each row is a residue and each column is a frame.\n\nBy default, all protein atoms are considered. The selection keyword argument can be used to choose a different selection. The PDBTools selection syntax can be used, for example selection=\"protein and chain A\",  or general Julia functions, like selection=at -> chain(at) in ('A', 'B').\n\nThe ss_method keyword argument can be used to choose the secondary structure prediction method, which can be either stride_run or dssp_run. The default is stride_run. STRIDE is a faster algorithm, while DSSP is the default one in PDB database.\n\nThe show_progress keyword argument controls whether a progress bar is shown.\n\nFor the classes, refer to the ProteinSecondaryStructures.jl package documentation.\n\nExample\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> ssmap = ss_map(simulation; selection=\"residue >= 30 and residue <= 35\", show_progress=false)\n6×5 Matrix{Int64}:\n 5  9  5  5  5\n 5  9  5  5  5\n 5  1  5  5  5\n 5  1  5  5  5\n 5  1  5  5  5\n 9  9  9  9  9\n\njulia> ss_name.(ssmap)\n6×5 Matrix{String}:\n \"turn\"  \"coil\"       \"turn\"  \"turn\"  \"turn\"\n \"turn\"  \"coil\"       \"turn\"  \"turn\"  \"turn\"\n \"turn\"  \"310 helix\"  \"turn\"  \"turn\"  \"turn\"\n \"turn\"  \"310 helix\"  \"turn\"  \"turn\"  \"turn\"\n \"turn\"  \"310 helix\"  \"turn\"  \"turn\"  \"turn\"\n \"coil\"  \"coil\"       \"coil\"  \"coil\"  \"coil\"\n\n\n\n\n\n\n","category":"function"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"A complete example for computing a secondary structure map is shown below:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"julia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> ssmap = ss_map(simulation; selection=\"residue >= 30 and residue <= 35\", show_progress=false)\n6×5 Matrix{Int64}:\n 5  9  5  5  5\n 5  9  5  5  5\n 5  1  5  5  5\n 5  1  5  5  5\n 5  1  5  5  5\n 9  9  9  9  9\n","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"Here we have computed the secondary structure map for 6 residues of the structure, along the 5 frames of the trajectory. The resulting map is a matrix, where each code represents  a different class of secondary structure. The conversion between representations of  the classes can be done with these three functions of the ProteinSecondaryStructures.jl package, which are reexported here:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"ss_code: convert the representation to one-letter codes like H, B, C, etc.\nss_name: convert the representation to secondary structure names like Alpha-helix, Beta-bridge, etc.\nss_number: convert the representation to code numbers, like the ones used the matrix above. ","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"The list of classes and code associations of is available  here, in the ProteinSecondaryStructures.jl documentation.","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"For example, considering the secondary structure map matrix above, we can do:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"julia> ss_name.(ssmap)\n6×5 Matrix{String}:\n \"turn\"  \"coil\"       \"turn\"  \"turn\"  \"turn\"\n \"turn\"  \"coil\"       \"turn\"  \"turn\"  \"turn\"\n \"turn\"  \"310 helix\"  \"turn\"  \"turn\"  \"turn\"\n \"turn\"  \"310 helix\"  \"turn\"  \"turn\"  \"turn\"\n \"turn\"  \"310 helix\"  \"turn\"  \"turn\"  \"turn\"\n \"coil\"  \"coil\"       \"coil\"  \"coil\"  \"coil\"\n","category":"page"},{"location":"secondary_structures/#Calculation-methods:-STRIDE-and-DSSP","page":"Secondary structure","title":"Calculation methods: STRIDE and DSSP","text":"","category":"section"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"The STRIDE or DSSP methods can be used to compute the secondary structure. STRIDE is faster, and DSSP is the default method used in the Protein Data Bank. The method is chosen with the method keyword of ss_map:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"ssmap = ss_map(atoms, trajectory; method=stride_run)\nssmap = ss_map(atoms, trajectory; method=dssp_run)","category":"page"},{"location":"secondary_structures/#Plotting-the-map","page":"Secondary structure","title":"Plotting the map","text":"","category":"section"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"The ss_heatmap function provides a convenient tool to plot the secondary structure along the trajectory:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"ss_heatmap","category":"page"},{"location":"secondary_structures/#MolSimToolkit.ss_heatmap","page":"Secondary structure","title":"MolSimToolkit.ss_heatmap","text":"ss_heatmap(ssmap::Matrix{<:Real}; scalex=1.0, kargs...)\n\nPlots a heatmap of the secondary structure map. \n\nnote: Note\nThis function requires loading the Plots package. The residue_ticks function   is available in the PDBTools` package.\n\nThe scalex keyword argument can be used to scale the x-axis, which usually has the meaning of time in a simulation. By default, it is 1.0 and the x-axis is the frame number.\n\nThe kargs keyword arguments are passed to the heatmap function of the Plots package, to modify properties of the plot. In particular: \n\nthe residue ticks can be set with yticks, and can be set to residue specific labels with the residue_ticks function of PDBTools.\nthe x-axis label can be set with xlabel to appropriate units, such as \"time / ns\", in combination with scalex. \n\nExample\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> using Plots, PDBTools\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> ssmap = ss_map(simulation; ss_method=stride_run, show_progress=false);\n\njulia> protein = select(atoms(simulation), \"protein\");\n\njulia> ss_heatmap(ssmap; scalex=0.1, xlabel=\"time / ns\", yticks=residue_ticks(prot; stride=5))\n\nWill plot a heatmap of the secondary structure map, with the x-axis scaled to 0.1, and residue ticks every 5 residues. The plot can be saved with the savefig function of the Plots package.\n\n\n\n\n\n","category":"function"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"note: Note\nThis function requires loading the Plots package, and residue_ticks is provided by PDBTools. ","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"For example:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"julia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> using Plots, PDBTools\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> ssmap = ss_map(simulation; ss_method=stride_run, show_progress=false);\n\njulia> protein = select(atoms(simulation), \"protein\");\n\njulia> ss_heatmap(ssmap; scalex=0.1, xlabel=\"time / ns\", yticks=residue_ticks(prot; stride=5))","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"The above code will produce the following plot, which can be saved with savefig(\"plot.svg\"):","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"(Image: heatmap1)","category":"page"},{"location":"secondary_structures/#Saving-and-loading-a-map","page":"Secondary structure","title":"Saving and loading a map","text":"","category":"section"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"The secondary structure map computed is just a matrix of integer codes. Thus, it can be saved or read in any preferred format. As a suggestion, it is possible to use writedlm and readdlm function from the DelimitedFiles package: ","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"using DelimitedFiles\n# save data to ssmap.dat\nwritedlm(\"ssmap.dat\", ssmap)\n# load data\nssmat = readdlm(\"ssmap.dat\", Int)","category":"page"},{"location":"secondary_structures/#Average-structure-of-each-class","page":"Secondary structure","title":"Average structure of each class","text":"","category":"section"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"From a precomputed secondary structure map the ss_mean helper functions will provide the content of a specific call of secondary structure along the simulation:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"ss_mean","category":"page"},{"location":"secondary_structures/#MolSimToolkit.ss_mean","page":"Secondary structure","title":"MolSimToolkit.ss_mean","text":"ss_mean(ssmap::AbstractMatrix{<:Integer}; class, dims=nothing)\n\nCalculates the mean secondary structure class content of the trajectory, given the secondary structure map.\n\nThe secondary structure class to be considered must be defined by the class keyword argument.\n\nclass can be either a string, a character, or an integer, or a set of values, setting the class(es)  of secondary structure to be consdiered. For example, for alpha helix, use \"H\". It can also be a vector of classes,  such as class=[\"H\", \"E\"].\n\nThe mean can be calculated along the residues (default) or along the frames, by setting the dims keyword argument.\n\ndims=nothing (default) calculates the mean occurence of ss_class of the whole matrix.\ndims=1 calculates the mean occurence of ss_class along the frames, for each residue.\ndims=2 calculates the mean occurence of ss_class along the residues, for each frame.\n\nThe classes can be found in the ProteinSecondaryStructures.jl package documentation.\n\nExample\n\njulia> using MolSimToolkit, MolSimToolkit.Testing\n\njulia> simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);\n\njulia> ssmap = ss_map(simulation; # 5 frames \n                   selection=\"residue >= 30 and residue <= 35\", # 6 residues\n                   show_progress=false\n               );\n\njulia> ss_mean(ssmap; class=\"C\")\n0.23333333333333334\n\njulia> ss_mean(ssmap; class=\"C\", dims=1) # mean coil content per residue\n5-element Vector{Float64}:\n 0.16666666666666666\n 0.5\n 0.16666666666666666\n 0.16666666666666666\n 0.16666666666666666 \n\njulia> ss_mean(ssmap; class=\"C\", dims=2) # mean coil content per frame\n6-element Vector{Float64}:\n 0.2\n 0.2\n 0.0\n 0.0\n 0.0\n 1.0\n\njulia> ss_mean(ssmap; class=[\"C\", \"T\"]) # mean coil or turn\n0.9\n\n\n\n\n\n\n","category":"function"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"For example, given the ssmap matrix of the examples above, compute the average content of alpha-helices with:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"julia> ss_mean(ssmap; class=\"H\")\n0.6093023255813953","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"The average content per frame is computed by averaging over the first dimension of the matrix (the residues):","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"julia> h = ss_mean(ssmap; class=\"H\", dims=1)\n5-element Vector{Float64}:\n 0.627906976744186\n 0.627906976744186\n 0.5813953488372093\n 0.6046511627906976\n 0.6046511627906976","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"Which can be plotted with:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"julia> plot(MolSimStyle, h, \n           xlabel=\"frame\", \n           ylabel=\"helical content\"\n       )","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"producing the time-dependence plot of the helical content:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"(Image: helical0)","category":"page"},{"location":"secondary_structures/#Average-structure-per-residue","page":"Secondary structure","title":"Average structure per residue","text":"","category":"section"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"And the average content per residue is obtained by averaging over the frames,  that is, the columns of the matrix:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"julia> h = ss_mean(ssmap; class=\"H\", dims=2)\n43-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n ⋮\n 1.0\n 0.4\n 0.0","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"This can be plotted, for example, with:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"julia> using Plots, PDBTools\n\njulia> ticks = residue_ticks(select(atoms(simulation), \"protein\"); stride=5)\n(1:5:41, [\"I211\", \"G216\", \"I221\", \"S226\", \"F231\", \"L236\", \"C241\", \"K246\", \"I251\"])\n\njulia> plot(MolSimStyle, h, \n           xlabel=\"residue\", xticks=ticks, xrotation=60,\n           ylabel=\"helical content\"\n       )","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"Which will generate the following figure:","category":"page"},{"location":"secondary_structures/","page":"Secondary structure","title":"Secondary structure","text":"(Image: helical1)","category":"page"},{"location":"#MolSimToolkit.jl","page":"Home","title":"MolSimToolkit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MolSimToolkit.jl provides a set of tools to  analyse molecular dynamics simulations, and a framework for the development of custom analysis tools.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(\"MolSimToolkit\")","category":"page"},{"location":"#Using","page":"Home","title":"Using","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using MolSimToolkit","category":"page"},{"location":"#Recommended","page":"Home","title":"Recommended","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Also install PDBTools:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(\"PDBTools\")\nimport PDBTools","category":"page"}]
}
