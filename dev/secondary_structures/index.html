<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Secondary structure · MolSimToolkit.jl</title><meta name="title" content="Secondary structure · MolSimToolkit.jl"/><meta property="og:title" content="Secondary structure · MolSimToolkit.jl"/><meta property="twitter:title" content="Secondary structure · MolSimToolkit.jl"/><meta name="description" content="Documentation for MolSimToolkit.jl."/><meta property="og:description" content="Documentation for MolSimToolkit.jl."/><meta property="twitter:description" content="Documentation for MolSimToolkit.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="MolSimToolkit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MolSimToolkit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Structural analyses</span><ul><li><a class="tocitem" href="../Structural_properties/">Distances and misc.</a></li><li><a class="tocitem" href="../Dihedrals/">Dihedral angle analysis</a></li><li class="is-active"><a class="tocitem" href>Secondary structure</a><ul class="internal"><li><a class="tocitem" href="#Secondary-structure-map"><span>Secondary structure map</span></a></li><li><a class="tocitem" href="#Calculation-methods:-STRIDE-and-DSSP"><span>Calculation methods: STRIDE and DSSP</span></a></li><li><a class="tocitem" href="#Plotting-the-map"><span>Plotting the map</span></a></li><li><a class="tocitem" href="#Saving-and-loading-a-map"><span>Saving and loading a map</span></a></li><li><a class="tocitem" href="#Average-structure-of-each-class"><span>Average structure of each class</span></a></li><li><a class="tocitem" href="#Average-structure-per-residue"><span>Average structure per residue</span></a></li></ul></li><li><a class="tocitem" href="../structural_alignment/">Structural alignment</a></li></ul></li><li><span class="tocitem">Simulation statistics</span><ul><li><a class="tocitem" href="../block_averages/">Block averages</a></li><li><a class="tocitem" href="../remd/">Replica exchange</a></li></ul></li><li><span class="tocitem">Interactions</span><ul><li><a class="tocitem" href="../Solvation_and_interactions/">Coordination numbers</a></li><li><a class="tocitem" href="../molecular_minimum_distances/">Molecular Minimum Distances</a></li></ul></li><li><span class="tocitem">Time-dependent properties</span><ul><li><a class="tocitem" href="../intermittent_correlation/">Intermittent correlation</a></li></ul></li><li><a class="tocitem" href="../system_setup/">System setup</a></li><li><a class="tocitem" href="../plotting_style/">Plotting style</a></li><li><a class="tocitem" href="../Developer/">Developer zone</a></li><li><span class="tocitem">Experimental</span><ul><li><a class="tocitem" href="../Reweighting/">Simulation Reweighting</a></li><li><a class="tocitem" href="../Coaraci/">Cluster submission management</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Structural analyses</a></li><li class="is-active"><a href>Secondary structure</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Secondary structure</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/m3g/MolSimToolkit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/m3g/MolSimToolkit.jl/blob/main/docs/src/secondary_structures.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Secondary-structures"><a class="docs-heading-anchor" href="#Secondary-structures">Secondary structures</a><a id="Secondary-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Secondary-structures" title="Permalink"></a></h1><p>This package provides convenience functions to analyze the protein secondary structure along molecular dynamics simulations. </p><h2 id="Secondary-structure-map"><a class="docs-heading-anchor" href="#Secondary-structure-map">Secondary structure map</a><a id="Secondary-structure-map-1"></a><a class="docs-heading-anchor-permalink" href="#Secondary-structure-map" title="Permalink"></a></h2><p>The secondary structure map is the profile of the secondary structure computed for  each frame of the trajectory. This computation may be costly, particularly with the  DSSP algorithm, so it is recommended to save the result. See <a href="#Saving-and-loading-a-map">Saving and loading a map</a> for further information. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolSimToolkit.ss_map" href="#MolSimToolkit.ss_map"><code>MolSimToolkit.ss_map</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ss_map(
    simulation::Simulation; 
    selection::Union{AbstractString,Function}=PDBTools.isprotein,
    ss_method=stride_run,
    show_progress=true
)</code></pre><p>Calculates the secondary structure map of the trajectory.  Returns a matrix of secondary structure codes, where each row is a residue and each column is a frame.</p><p>By default, all protein atoms are considered. The <code>selection</code> keyword argument can be used to choose a different selection. The <code>PDBTools</code> selection syntax can be used, for example <code>selection=&quot;protein and chain A&quot;</code>,  or general Julia functions, like <code>selection=at -&gt; chain(at) in (&#39;A&#39;, &#39;B&#39;)</code>.</p><p>The <code>ss_method</code> keyword argument can be used to choose the secondary structure prediction method, which can be either <code>stride_run</code> or <code>dssp_run</code>. The default is <code>stride_run</code>. STRIDE is a faster algorithm, while DSSP is the default one in PDB database.</p><p>The <code>show_progress</code> keyword argument controls whether a progress bar is shown.</p><p>For the classes, refer to the ProteinSecondaryStructures.jl package documentation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using MolSimToolkit, MolSimToolkit.Testing

julia&gt; simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);

julia&gt; ssmap = ss_map(simulation; selection=&quot;residue &gt;= 30 and residue &lt;= 35&quot;, show_progress=false)
6×5 Matrix{Int64}:
 5  9  5  5  5
 5  9  5  5  5
 5  1  5  5  5
 5  1  5  5  5
 5  1  5  5  5
 9  9  9  9  9

julia&gt; ss_name.(ssmap)
6×5 Matrix{String}:
 &quot;turn&quot;  &quot;coil&quot;       &quot;turn&quot;  &quot;turn&quot;  &quot;turn&quot;
 &quot;turn&quot;  &quot;coil&quot;       &quot;turn&quot;  &quot;turn&quot;  &quot;turn&quot;
 &quot;turn&quot;  &quot;310 helix&quot;  &quot;turn&quot;  &quot;turn&quot;  &quot;turn&quot;
 &quot;turn&quot;  &quot;310 helix&quot;  &quot;turn&quot;  &quot;turn&quot;  &quot;turn&quot;
 &quot;turn&quot;  &quot;310 helix&quot;  &quot;turn&quot;  &quot;turn&quot;  &quot;turn&quot;
 &quot;coil&quot;  &quot;coil&quot;       &quot;coil&quot;  &quot;coil&quot;  &quot;coil&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/MolSimToolkit.jl/blob/789149252aa8e4339ec9ac3000070f46393981b1/src/secondary_structure/secondary_structure.jl#L33-L83">source</a></section></article><p>A complete example for computing a secondary structure map is shown below:</p><pre><code class="language-julia-repl hljs">julia&gt; using MolSimToolkit, MolSimToolkit.Testing

julia&gt; simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);

julia&gt; ssmap = ss_map(simulation; selection=&quot;residue &gt;= 30 and residue &lt;= 35&quot;, show_progress=false)
6×5 Matrix{Int64}:
 5  9  5  5  5
 5  9  5  5  5
 5  1  5  5  5
 5  1  5  5  5
 5  1  5  5  5
 9  9  9  9  9
</code></pre><p>Here we have computed the secondary structure map for 6 residues of the structure, along the 5 frames of the trajectory. The resulting map is a matrix, where each code represents  a different class of secondary structure. The conversion between representations of  the classes can be done with these three functions of the <a href="https://github.com/m3g/ProteinSecondaryStructures.jl">ProteinSecondaryStructures.jl</a> package, which are reexported here:</p><ul><li><code>ss_code</code>: convert the representation to one-letter codes like <code>H</code>, <code>B</code>, <code>C</code>, etc.</li><li><code>ss_name</code>: convert the representation to secondary structure names like <code>Alpha-helix</code>, <code>Beta-bridge</code>, etc.</li><li><code>ss_number</code>: convert the representation to code numbers, like the ones used the matrix above. </li></ul><p>The list of classes and code associations of is available  <a href="https://BioJulia.dev/ProteinSecondaryStructures.jl/stable/overview/#Secondary-structure-classes">here, in the ProteinSecondaryStructures.jl documentation</a>.</p><p>For example, considering the secondary structure map matrix above, we can do:</p><pre><code class="language-julia-repl hljs">julia&gt; ss_name.(ssmap)
6×5 Matrix{String}:
 &quot;turn&quot;  &quot;coil&quot;       &quot;turn&quot;  &quot;turn&quot;  &quot;turn&quot;
 &quot;turn&quot;  &quot;coil&quot;       &quot;turn&quot;  &quot;turn&quot;  &quot;turn&quot;
 &quot;turn&quot;  &quot;310 helix&quot;  &quot;turn&quot;  &quot;turn&quot;  &quot;turn&quot;
 &quot;turn&quot;  &quot;310 helix&quot;  &quot;turn&quot;  &quot;turn&quot;  &quot;turn&quot;
 &quot;turn&quot;  &quot;310 helix&quot;  &quot;turn&quot;  &quot;turn&quot;  &quot;turn&quot;
 &quot;coil&quot;  &quot;coil&quot;       &quot;coil&quot;  &quot;coil&quot;  &quot;coil&quot;
</code></pre><h2 id="Calculation-methods:-STRIDE-and-DSSP"><a class="docs-heading-anchor" href="#Calculation-methods:-STRIDE-and-DSSP">Calculation methods: STRIDE and DSSP</a><a id="Calculation-methods:-STRIDE-and-DSSP-1"></a><a class="docs-heading-anchor-permalink" href="#Calculation-methods:-STRIDE-and-DSSP" title="Permalink"></a></h2><p>The STRIDE or DSSP methods can be used to compute the secondary structure. STRIDE is faster, and DSSP is the default method used in the Protein Data Bank. The method is chosen with the <code>method</code> keyword of <code>ss_map</code>:</p><pre><code class="language-julia hljs">ssmap = ss_map(atoms, trajectory; method=stride_run)
ssmap = ss_map(atoms, trajectory; method=dssp_run)</code></pre><h2 id="Plotting-the-map"><a class="docs-heading-anchor" href="#Plotting-the-map">Plotting the map</a><a id="Plotting-the-map-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-the-map" title="Permalink"></a></h2><p>The <code>ss_heatmap</code> function provides a convenient tool to plot the secondary structure along the trajectory:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolSimToolkit.ss_heatmap" href="#MolSimToolkit.ss_heatmap"><code>MolSimToolkit.ss_heatmap</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ss_heatmap(ssmap::Matrix{&lt;:Real}; scalex=1.0, kargs...)</code></pre><p>Plots a heatmap of the secondary structure map. </p><div class="admonition is-info" id="Note-286fdda40352d71f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-286fdda40352d71f" title="Permalink"></a></header><div class="admonition-body"><p>This function requires loading the <code>Plots</code> package. The <code>residue_ticks</code> function   is available in the <code>PDBTools</code>` package.</p></div></div><p>The <code>scalex</code> keyword argument can be used to scale the x-axis, which usually has the meaning of time in a simulation. By default, it is 1.0 and the x-axis is the frame number.</p><p>The <code>kargs</code> keyword arguments are passed to the <code>heatmap</code> function of the Plots package, to modify properties of the plot. In particular: </p><ul><li>the residue ticks can be set with <code>yticks</code>, and can be set to residue specific labels with the <code>residue_ticks</code> function of PDBTools.</li><li>the x-axis label can be set with <code>xlabel</code> to appropriate units, such as &quot;time / ns&quot;, in combination with <code>scalex</code>. </li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using MolSimToolkit, MolSimToolkit.Testing

julia&gt; using Plots, PDBTools

julia&gt; simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);

julia&gt; ssmap = ss_map(simulation; ss_method=stride_run, show_progress=false);

julia&gt; protein = select(atoms(simulation), &quot;protein&quot;);

julia&gt; ss_heatmap(ssmap; scalex=0.1, xlabel=&quot;time / ns&quot;, yticks=residue_ticks(prot; stride=5))</code></pre><p>Will plot a heatmap of the secondary structure map, with the x-axis scaled to 0.1, and residue ticks every 5 residues. The plot can be saved with the <code>savefig</code> function of the Plots package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/MolSimToolkit.jl/blob/789149252aa8e4339ec9ac3000070f46393981b1/src/secondary_structure/secondary_structure.jl#L245-L281">source</a></section></article><div class="admonition is-info" id="Note-de6cb856ead06664"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-de6cb856ead06664" title="Permalink"></a></header><div class="admonition-body"><p>This function requires loading the <code>Plots</code> package, and <code>residue_ticks</code> is provided by <code>PDBTools</code>. </p></div></div><p>For example:</p><pre><code class="language-julia-repl hljs">julia&gt; using MolSimToolkit, MolSimToolkit.Testing

julia&gt; using Plots, PDBTools

julia&gt; simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);

julia&gt; ssmap = ss_map(simulation; ss_method=stride_run, show_progress=false);

julia&gt; protein = select(atoms(simulation), &quot;protein&quot;);

julia&gt; ss_heatmap(ssmap; scalex=0.1, xlabel=&quot;time / ns&quot;, yticks=residue_ticks(prot; stride=5))</code></pre><p>The above code will produce the following plot, which can be saved with <code>savefig(&quot;plot.svg&quot;)</code>:</p><p><img src="../images/secondary_structure/heatmap1.svg" alt="heatmap1"/></p><h2 id="Saving-and-loading-a-map"><a class="docs-heading-anchor" href="#Saving-and-loading-a-map">Saving and loading a map</a><a id="Saving-and-loading-a-map-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-and-loading-a-map" title="Permalink"></a></h2><p>The secondary structure map computed is just a matrix of integer codes. Thus, it can be saved or read in any preferred format. As a suggestion, it is possible to use <code>writedlm</code> and <code>readdlm</code> function from the <code>DelimitedFiles</code> package: </p><pre><code class="language-julia hljs">using DelimitedFiles
# save data to ssmap.dat
writedlm(&quot;ssmap.dat&quot;, ssmap)
# load data
ssmat = readdlm(&quot;ssmap.dat&quot;, Int)</code></pre><h2 id="Average-structure-of-each-class"><a class="docs-heading-anchor" href="#Average-structure-of-each-class">Average structure of each class</a><a id="Average-structure-of-each-class-1"></a><a class="docs-heading-anchor-permalink" href="#Average-structure-of-each-class" title="Permalink"></a></h2><p>From a precomputed secondary structure map the <code>ss_mean</code> helper functions will provide the content of a specific call of secondary structure along the simulation:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolSimToolkit.ss_mean" href="#MolSimToolkit.ss_mean"><code>MolSimToolkit.ss_mean</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ss_mean(ssmap::AbstractMatrix{&lt;:Integer}; class, dims=nothing)</code></pre><p>Calculates the mean secondary structure class content of the trajectory, given the secondary structure map.</p><p>The secondary structure class to be considered must be defined by the <code>class</code> keyword argument.</p><p><code>class</code> can be either a string, a character, or an integer, or a set of values, setting the class(es)  of secondary structure to be consdiered. For example, for <code>alpha helix</code>, use &quot;H&quot;. It can also be a vector of classes,  such as <code>class=[&quot;H&quot;, &quot;E&quot;]</code>.</p><p>The mean can be calculated along the residues (default) or along the frames, by setting the <code>dims</code> keyword argument.</p><ul><li><code>dims=nothing</code> (default) calculates the mean occurence of <code>ss_class</code> of the whole matrix.</li><li><code>dims=1</code> calculates the mean occurence of <code>ss_class</code> along the frames, for each residue.</li><li><code>dims=2</code> calculates the mean occurence of <code>ss_class</code> along the residues, for each frame.</li></ul><p>The classes can be found in the ProteinSecondaryStructures.jl package documentation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using MolSimToolkit, MolSimToolkit.Testing

julia&gt; simulation = Simulation(Testing.namd_pdb, Testing.namd_traj);

julia&gt; ssmap = ss_map(simulation; # 5 frames 
                   selection=&quot;residue &gt;= 30 and residue &lt;= 35&quot;, # 6 residues
                   show_progress=false
               );

julia&gt; ss_mean(ssmap; class=&quot;C&quot;)
0.23333333333333334

julia&gt; ss_mean(ssmap; class=&quot;C&quot;, dims=1) # mean coil content per residue
5-element Vector{Float64}:
 0.16666666666666666
 0.5
 0.16666666666666666
 0.16666666666666666
 0.16666666666666666 

julia&gt; ss_mean(ssmap; class=&quot;C&quot;, dims=2) # mean coil content per frame
6-element Vector{Float64}:
 0.2
 0.2
 0.0
 0.0
 0.0
 1.0

julia&gt; ss_mean(ssmap; class=[&quot;C&quot;, &quot;T&quot;]) # mean coil or turn
0.9
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/MolSimToolkit.jl/blob/789149252aa8e4339ec9ac3000070f46393981b1/src/secondary_structure/secondary_structure.jl#L125-L181">source</a></section></article><p>For example, given the <code>ssmap</code> matrix of the examples above, compute the average content of alpha-helices with:</p><pre><code class="language-julia-repl hljs">julia&gt; ss_mean(ssmap; class=&quot;H&quot;)
0.6093023255813953</code></pre><p>The average content per frame is computed by averaging over the first dimension of the matrix (the residues):</p><pre><code class="language-julia-repl hljs">julia&gt; h = ss_mean(ssmap; class=&quot;H&quot;, dims=1)
5-element Vector{Float64}:
 0.627906976744186
 0.627906976744186
 0.5813953488372093
 0.6046511627906976
 0.6046511627906976</code></pre><p>Which can be plotted with:</p><pre><code class="language-julia-repl hljs">julia&gt; plot(MolSimStyle, h, 
           xlabel=&quot;frame&quot;, 
           ylabel=&quot;helical content&quot;
       )</code></pre><p>producing the time-dependence plot of the helical content:</p><p><img src="../images/secondary_structure/helical0.svg" alt="helical0"/></p><h2 id="Average-structure-per-residue"><a class="docs-heading-anchor" href="#Average-structure-per-residue">Average structure per residue</a><a id="Average-structure-per-residue-1"></a><a class="docs-heading-anchor-permalink" href="#Average-structure-per-residue" title="Permalink"></a></h2><p>And the average content per residue is obtained by averaging over the frames,  that is, the columns of the matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; h = ss_mean(ssmap; class=&quot;H&quot;, dims=2)
43-element Vector{Float64}:
 0.0
 0.0
 0.0
 ⋮
 1.0
 0.4
 0.0</code></pre><p>This can be plotted, for example, with:</p><pre><code class="language-julia-repl hljs">julia&gt; using Plots, PDBTools

julia&gt; ticks = residue_ticks(select(atoms(simulation), &quot;protein&quot;); stride=5)
(1:5:41, [&quot;I211&quot;, &quot;G216&quot;, &quot;I221&quot;, &quot;S226&quot;, &quot;F231&quot;, &quot;L236&quot;, &quot;C241&quot;, &quot;K246&quot;, &quot;I251&quot;])

julia&gt; plot(MolSimStyle, h, 
           xlabel=&quot;residue&quot;, xticks=ticks, xrotation=60,
           ylabel=&quot;helical content&quot;
       )</code></pre><p>Which will generate the following figure:</p><p><img src="../images/secondary_structure/helical1.svg" alt="helical1"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Dihedrals/">« Dihedral angle analysis</a><a class="docs-footer-nextpage" href="../structural_alignment/">Structural alignment »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Wednesday 2 July 2025 18:52">Wednesday 2 July 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
